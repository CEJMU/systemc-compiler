//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
);

// Variables generated for SystemC signals
logic clk;
logic arstn;
logic signed [31:0] out;
logic signed [31:0] in;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch1 (test_cthread_switch.cpp:83:5) 

// Thread-local variables
logic signed [31:0] j;
logic signed [31:0] j_next;
logic test_switch1_PROC_STATE;
logic test_switch1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch1_comb     // test_cthread_switch.cpp:83:5
    test_switch1_func;
end
function void test_switch1_func;
    integer i;
    j_next = j;
    test_switch1_PROC_STATE_next = test_switch1_PROC_STATE;
    
    case (test_switch1_PROC_STATE)
        0: begin
            i = j_next;
            case (i)
            0 : begin
                j_next = 1;
            end
            1 : begin
                j_next = 2;
            end
            default : begin
                j_next = 3;
            end
            endcase
            test_switch1_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:97:13;
        end
        1: begin
            i = 1;
            i = j_next;
            case (i)
            0 : begin
                j_next = 1;
            end
            1 : begin
                j_next = 2;
            end
            default : begin
                j_next = 3;
            end
            endcase
            test_switch1_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:97:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch1_ff
    if ( ~arstn ) begin
        j <= 0;
        test_switch1_PROC_STATE <= 0;    // test_cthread_switch.cpp:86:9;
    end
    else begin
        j <= j_next;
        test_switch1_PROC_STATE <= test_switch1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread (test_cthread_switch.cpp:210:5) 

// Thread-local variables
logic signed [31:0] out_next;
logic [2:0] test_thread_PROC_STATE;
logic [2:0] test_thread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_comb     // test_cthread_switch.cpp:210:5
    test_thread_func;
end
function void test_thread_func;
    out_next = out;
    test_thread_PROC_STATE_next = test_thread_PROC_STATE;
    
    case (test_thread_PROC_STATE)
        0: begin
            case (in)
            0 : begin  // Empty case without break
                out_next = 10;
            end
            1 : begin
                out_next = 10;
            end
            2 : begin
                out_next = 10;
                out_next = 11;
            end
            3 : begin  // Empty case without break
                out_next = 13;
            end
            default : begin
                out_next = 13;
            end
            endcase
            case (in)
            0 : begin
                out_next = 1;
            end
            1 : begin
                test_thread_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:238:17;
            end
            default : begin
                test_thread_PROC_STATE_next = 3; return;    // test_cthread_switch.cpp:244:17;
            end
            endcase
            test_thread_PROC_STATE_next = 4; return;    // test_cthread_switch.cpp:248:13;
        end
        1: begin
            out_next = 2;
            test_thread_PROC_STATE_next = 2; return;    // test_cthread_switch.cpp:240:17;
        end
        2: begin
            test_thread_PROC_STATE_next = 4; return;    // test_cthread_switch.cpp:248:13;
        end
        3: begin
            test_thread_PROC_STATE_next = 4; return;    // test_cthread_switch.cpp:248:13;
        end
        4: begin
            case (in)
            0 : begin  // Empty case without break
                out_next = 10;
            end
            1 : begin
                out_next = 10;
            end
            2 : begin
                out_next = 10;
                out_next = 11;
            end
            3 : begin  // Empty case without break
                out_next = 13;
            end
            default : begin
                out_next = 13;
            end
            endcase
            case (in)
            0 : begin
                out_next = 1;
            end
            1 : begin
                test_thread_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:238:17;
            end
            default : begin
                test_thread_PROC_STATE_next = 3; return;    // test_cthread_switch.cpp:244:17;
            end
            endcase
            test_thread_PROC_STATE_next = 4; return;    // test_cthread_switch.cpp:248:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_PROC_STATE <= 0;    // test_cthread_switch.cpp:213:9;
    end
    else begin
        out <= out_next;
        test_thread_PROC_STATE <= test_thread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch2 (test_cthread_switch.cpp:104:5) 

// Thread-local variables
logic signed [31:0] t0_next;
logic test_switch2_PROC_STATE;
logic test_switch2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch2_comb     // test_cthread_switch.cpp:104:5
    test_switch2_func;
end
function void test_switch2_func;
    integer j_1;
    integer i;
    t0_next = t0;
    test_switch2_PROC_STATE_next = test_switch2_PROC_STATE;
    
    case (test_switch2_PROC_STATE)
        0: begin
            i = 0;
            case (0)
            0 : begin
                j_1 = 1;
            end
            endcase
            t0_next = j_1;
            test_switch2_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:119:13;
        end
        1: begin
            i = 1;
            i = 0;
            case (0)
            0 : begin
                j_1 = 1;
            end
            endcase
            t0_next = j_1;
            test_switch2_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:119:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_switch2_PROC_STATE <= 0;    // test_cthread_switch.cpp:107:9;
    end
    else begin
        t0 <= t0_next;
        test_switch2_PROC_STATE <= test_switch2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch3 (test_cthread_switch.cpp:126:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic signed [31:0] t1_next;
logic test_switch3_PROC_STATE;
logic test_switch3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch3_comb     // test_cthread_switch.cpp:126:5
    test_switch3_func;
end
function void test_switch3_func;
    integer j_1;
    i_next = i0;
    t1_next = t1;
    test_switch3_PROC_STATE_next = test_switch3_PROC_STATE;
    
    case (test_switch3_PROC_STATE)
        0: begin
            i_next = 0;
            test_switch3_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:134:13;
        end
        1: begin
            case (0)
            0 : begin
                j_1 = 1;
            end
            endcase
            i_next = 1;
            t1_next = j_1;
            i_next = 0;
            test_switch3_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:134:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch3_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_switch3_PROC_STATE <= 0;    // test_cthread_switch.cpp:129:9;
    end
    else begin
        i0 <= i_next;
        t1 <= t1_next;
        test_switch3_PROC_STATE <= test_switch3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch4 (test_cthread_switch.cpp:149:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [31:0] k;
logic signed [31:0] k_next;
logic signed [31:0] t2_next;
logic signed [31:0] i1;
logic signed [31:0] i_next0;
logic [1:0] test_switch4_PROC_STATE;
logic [1:0] test_switch4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch4_comb     // test_cthread_switch.cpp:149:5
    test_switch4_func;
end
function void test_switch4_func;
    i_next0 = i1;
    j_next0 = j0;
    k_next = k;
    t2_next = t2;
    test_switch4_PROC_STATE_next = test_switch4_PROC_STATE;
    
    case (test_switch4_PROC_STATE)
        0: begin
            i_next0 = 0;
            test_switch4_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:157:13;
        end
        1: begin
            case (0)
            0 : begin
                j_next0 = 1;
                k_next = 0;
                test_switch4_PROC_STATE_next = 2; return;    // test_cthread_switch.cpp:163:29;
            end
            endcase
        end
        2: begin
            j_next0++;
            k_next++;
            if (k_next < 2)
            begin
                test_switch4_PROC_STATE_next = 2; return;    // test_cthread_switch.cpp:163:29;
            end
            i_next0 = 1;
            t2_next = j_next0;
            i_next0 = 0;
            test_switch4_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:157:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch4_ff
    if ( ~arstn ) begin
        j0 <= 0;
        test_switch4_PROC_STATE <= 0;    // test_cthread_switch.cpp:152:9;
    end
    else begin
        j0 <= j_next0;
        k <= k_next;
        t2 <= t2_next;
        i1 <= i_next0;
        test_switch4_PROC_STATE <= test_switch4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch5 (test_cthread_switch.cpp:179:5) 

// Thread-local variables
logic signed [31:0] t3_next;
logic test_switch5_PROC_STATE;
logic test_switch5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch5_comb     // test_cthread_switch.cpp:179:5
    test_switch5_func;
end
function void test_switch5_func;
    integer j_1;
    integer i;
    t3_next = t3;
    test_switch5_PROC_STATE_next = test_switch5_PROC_STATE;
    
    case (test_switch5_PROC_STATE)
        0: begin
            j_1 = 1;
            test_switch5_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:187:13;
        end
        1: begin
            j_1 = 2;
            if (|in)
            begin
                i = j_1;
            end
            t3_next = j_1;
            j_1 = 1;
            test_switch5_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:187:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch5_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_switch5_PROC_STATE <= 0;    // test_cthread_switch.cpp:182:9;
    end
    else begin
        t3 <= t3_next;
        test_switch5_PROC_STATE <= test_switch5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch6 (test_cthread_switch.cpp:198:5) 

// Thread-local variables
logic signed [31:0] j1;
logic signed [31:0] j_next1;
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic [1:0] test_switch6_PROC_STATE;
logic [1:0] test_switch6_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch6_comb     // test_cthread_switch.cpp:198:5
    test_switch6_func;
end
function void test_switch6_func;
    integer TMP_0;
    integer TMP_1;
    i_next1 = i2;
    j_next1 = j1;
    test_switch6_PROC_STATE_next = test_switch6_PROC_STATE;
    
    case (test_switch6_PROC_STATE)
        0: begin
            i_next1 = j_next1;
            // Call f2() begin
            case (i_next1)
            0 : begin
                TMP_0 = i_next1 + 1;
            end
            1 : begin
                test_switch6_PROC_STATE_next = 2; return;    // test_cthread_switch.cpp:76:21;
            end
            default : begin
                TMP_0 = i_next1;
            end
            endcase
            // Call f2() end
            j_next1 = TMP_0;
            test_switch6_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:206:13;
        end
        1: begin
            i_next1 = j_next1;
            // Call f2() begin
            case (i_next1)
            0 : begin
                TMP_1 = i_next1 + 1;
            end
            1 : begin
                test_switch6_PROC_STATE_next = 2; return;    // test_cthread_switch.cpp:76:21;
            end
            default : begin
                TMP_1 = i_next1;
            end
            endcase
            // Call f2() end
            j_next1 = TMP_1;
            test_switch6_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:206:13;
        end
        2: begin
            // Call f2() begin
            TMP_1 = i_next1 + 2;
            // Call f2() end
            j_next1 = TMP_1;
            test_switch6_PROC_STATE_next = 1; return;    // test_cthread_switch.cpp:206:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch6_ff
    if ( ~arstn ) begin
        j1 <= 0;
        test_switch6_PROC_STATE <= 0;    // test_cthread_switch.cpp:201:9;
    end
    else begin
        j1 <= j_next1;
        i2 <= i_next1;
        test_switch6_PROC_STATE <= test_switch6_PROC_STATE_next;
    end
end

endmodule



diff -crB --new-file systemc-2.3.4/CMakeLists.txt systemc-2.3.4_patched/CMakeLists.txt
*** systemc-2.3.4/CMakeLists.txt	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/CMakeLists.txt	2023-07-26 13:44:34.695125000 -0700
***************
*** 277,297 ****
         FORCE)
  endif (NOT CMAKE_BUILD_TYPE)
  
! set (CMAKE_CXX_STANDARD 98 CACHE STRING
!      "C++ standard to build all targets. Supported values are 98, 11, 14, and 17.")
! set (CMAKE_CXX_STANDARD_REQUIRED ON CACHE BOOL
!      "The with CMAKE_CXX_STANDARD selected C++ standard is a requirement.")
! mark_as_advanced (CMAKE_CXX_STANDARD_REQUIRED)
! 
! if (NOT (WIN32 OR CYGWIN))
!   option (BUILD_SHARED_LIBS "Build shared libraries." ON)
! else (NOT (WIN32 OR CYGWIN))
!   option (BUILD_SHARED_LIBS "Build shared libraries." OFF)
! endif (NOT (WIN32 OR CYGWIN))
! if (BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
!   message (WARNING "The compilation of SystemC as a DLL on Windows is currently not supported!")
!   set (BUILD_SHARED_LIBS CACHE BOOL "Build shared libraries." OFF FORCE)
! endif (BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
  
  option (BUILD_SOURCE_DOCUMENTATION "Build source documentation with Doxygen." OFF)
  
--- 277,300 ----
         FORCE)
  endif (NOT CMAKE_BUILD_TYPE)
  
! #set(BUILD_SHARED_LIBS OFF)
! # -- Set by SVC -----------------------
! #set (CMAKE_CXX_STANDARD 98 CACHE STRING
! #     "C++ standard to build all targets. Supported values are 98, 11, 14, and 17.")
! #set (CMAKE_CXX_STANDARD_REQUIRED ON CACHE BOOL
! #     "The with CMAKE_CXX_STANDARD selected C++ standard is a requirement.")
! #mark_as_advanced (CMAKE_CXX_STANDARD_REQUIRED)
! #
! #if (NOT (WIN32 OR CYGWIN))
! #  option (BUILD_SHARED_LIBS "Build shared libraries." ON)
! #else (NOT (WIN32 OR CYGWIN))
! #  option (BUILD_SHARED_LIBS "Build shared libraries." OFF)
! #endif (NOT (WIN32 OR CYGWIN))
! #if (BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
! #  message (WARNING "The compilation of SystemC as a DLL on Windows is currently not supported!")
! #  set (BUILD_SHARED_LIBS CACHE BOOL "Build shared libraries." OFF FORCE)
! #endif (BUILD_SHARED_LIBS AND (WIN32 OR CYGWIN))
! 
  
  option (BUILD_SOURCE_DOCUMENTATION "Build source documentation with Doxygen." OFF)
  
***************
*** 309,315 ****
  
  option (ENABLE_IMMEDIATE_SELF_NOTIFICATIONS "Enable immediate self-notification of processes, which is no longer supported due to changes in IEEE Std 1666-2011 (see sc_event::notify, 5.10.6)." OFF)
  
! option (ENABLE_PHASE_CALLBACKS "Enable the simulation phase callbacks (experimental)." OFF)
  
  option (ENABLE_PHASE_CALLBACKS_TRACING "Enable the use of the (experimental) simulation phase callbacks for the sc_trace() implementation." ON)
  
--- 312,318 ----
  
  option (ENABLE_IMMEDIATE_SELF_NOTIFICATIONS "Enable immediate self-notification of processes, which is no longer supported due to changes in IEEE Std 1666-2011 (see sc_event::notify, 5.10.6)." OFF)
  
! option (ENABLE_PHASE_CALLBACKS "Enable the simulation phase callbacks (experimental)." ON)
  
  option (ENABLE_PHASE_CALLBACKS_TRACING "Enable the use of the (experimental) simulation phase callbacks for the sc_trace() implementation." ON)
  
***************
*** 550,570 ****
  # Set the installation paths
  ###############################################################################
  
! if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
!   if (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
!     set (_CMAKE_INSTALL_PREFIX $ENV{SYSTEMC_HOME})
!   elseif (UNIX)
!     set (_CMAKE_INSTALL_PREFIX "/opt/systemc")
!   elseif (WIN32)
!     file (TO_CMAKE_PATH $ENV{ProgramFiles} _WIN32_INSTALL_PREFIX)
!     set (_CMAKE_INSTALL_PREFIX "${_WIN32_INSTALL_PREFIX}/SystemC")
!     unset (_WIN32_INSTALL_PREFIX)
!   else (EXISTS $ENV{SYSTEMC_ROOT_DIR})
!     set (_CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}/systemc")
!   endif (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
!   set (CMAKE_INSTALL_PREFIX ${_CMAKE_INSTALL_PREFIX} CACHE PATH "Installation root directory" FORCE)
!   unset (_CMAKE_INSTALL_PREFIX)
! endif (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  
  # Set the installation paths for headers, libraries, and documentation.
  set (CMAKE_INSTALL_DOCDIR "share/doc/systemc" CACHE PATH
--- 553,573 ----
  # Set the installation paths
  ###############################################################################
  
! #if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
! #  if (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
! #    set (_CMAKE_INSTALL_PREFIX $ENV{SYSTEMC_HOME})
! #  elseif (UNIX)
! #    set (_CMAKE_INSTALL_PREFIX "/opt/systemc")
! #  elseif (WIN32)
! #    file (TO_CMAKE_PATH $ENV{ProgramFiles} _WIN32_INSTALL_PREFIX)
! #    set (_CMAKE_INSTALL_PREFIX "${_WIN32_INSTALL_PREFIX}/SystemC")
! #    unset (_WIN32_INSTALL_PREFIX)
! #  else (EXISTS $ENV{SYSTEMC_ROOT_DIR})
! #    set (_CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}/systemc")
! #  endif (IS_ABSOLUTE $ENV{SYSTEMC_HOME})
! #  set (CMAKE_INSTALL_PREFIX ${_CMAKE_INSTALL_PREFIX} CACHE PATH "Installation root directory" FORCE)
! #  unset (_CMAKE_INSTALL_PREFIX)
! #endif (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  
  # Set the installation paths for headers, libraries, and documentation.
  set (CMAKE_INSTALL_DOCDIR "share/doc/systemc" CACHE PATH
***************
*** 724,730 ****
  ###############################################################################
  
  add_subdirectory (src)
! add_subdirectory (examples)
  
  
  ###############################################################################
--- 727,733 ----
  ###############################################################################
  
  add_subdirectory (src)
! # add_subdirectory (examples)
  
  
  ###############################################################################
***************
*** 746,792 ****
  # Provide package of the SystemC library to other programs using CMake
  ###############################################################################
  
! # Export the systemc library target for usage by other programs
! # ... to local build tree
! export (TARGETS systemc
!         NAMESPACE SystemC::
!         FILE SystemCLanguageTargets.cmake)
! # ... to installation tree
! install (EXPORT SystemCLanguageTargets
!          NAMESPACE SystemC::
!          DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR}
!          COMPONENT dev)
! 
! # Register the SystemCLanguage and SystemCTLM packages for use from the
! # build tree. (This registers the build tree with the global CMake-registry.)
! export (PACKAGE SystemCLanguage)
! export (PACKAGE SystemCTLM)
! 
! # Create the <Package>Config.cmake and <Package>ConfigVersion files
! include(CMakePackageConfigHelpers)
! configure_package_config_file(cmake/SystemCLanguageConfig.cmake.in
!   ${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfig.cmake
!   INSTALL_DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR})
! write_basic_package_version_file(
!   "${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
!   VERSION ${SystemCLanguage_VERSION_MAJOR}.${SystemCLanguage_VERSION_MINOR}.${SystemCLanguage_VERSION_PATCH}.${SystemCLanguage_VERSION_RELEASE_DATE}
!   COMPATIBILITY AnyNewerVersion
! )
! configure_package_config_file(cmake/SystemCTLMConfig.cmake.in
!   ${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfig.cmake
!   INSTALL_DESTINATION ${SystemCTLM_INSTALL_CMAKEDIR})
! write_basic_package_version_file(
!   "${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
!   VERSION ${SystemCTLM_VERSION_MAJOR}.${SystemCTLM_VERSION_MINOR}.${SystemCTLM_VERSION_PATCH}.${SystemCTLM_VERSION_RELEASE_DATE}
!   COMPATIBILITY AnyNewerVersion
! )
! 
! # Install the <Package>Config.cmake and <Package>ConfigVersion.cmake
! install(FILES "${PROJECT_BINARY_DIR}/SystemCLanguageConfig.cmake"
!               "${PROJECT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
!         DESTINATION "${SystemCLanguage_INSTALL_CMAKEDIR}"
!         COMPONENT dev)
! install(FILES "${PROJECT_BINARY_DIR}/SystemCTLMConfig.cmake"
!               "${PROJECT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
!         DESTINATION "${SystemCTLM_INSTALL_CMAKEDIR}"
!         COMPONENT dev)
--- 749,795 ----
  # Provide package of the SystemC library to other programs using CMake
  ###############################################################################
  
! ## Export the systemc library target for usage by other programs
! ## ... to local build tree
! #export (TARGETS systemc
! #        NAMESPACE SVC::
! #        FILE SystemCLanguageTargets.cmake)
! ## ... to installation tree
! #install (EXPORT SystemCLanguageTargets
! #         NAMESPACE SVC::
! #         DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR}
! #         COMPONENT dev)
! #
! ## Register the SystemCLanguage and SystemCTLM packages for use from the
! ## build tree. (This registers the build tree with the global CMake-registry.)
! #export (PACKAGE SystemCLanguage)
! #export (PACKAGE SystemCTLM)
! #
! ## Create the <Package>Config.cmake and <Package>ConfigVersion files
! #include(CMakePackageConfigHelpers)
! #configure_package_config_file(cmake/SystemCLanguageConfig.cmake.in
! #  ${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfig.cmake
! #  INSTALL_DESTINATION ${SystemCLanguage_INSTALL_CMAKEDIR})
! #write_basic_package_version_file(
! #  "${CMAKE_CURRENT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
! #  VERSION ${SystemCLanguage_VERSION_MAJOR}.${SystemCLanguage_VERSION_MINOR}.${SystemCLanguage_VERSION_PATCH}.${SystemCLanguage_VERSION_RELEASE_DATE}
! #  COMPATIBILITY AnyNewerVersion
! #)
! #configure_package_config_file(cmake/SystemCTLMConfig.cmake.in
! #  ${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfig.cmake
! #  INSTALL_DESTINATION ${SystemCTLM_INSTALL_CMAKEDIR})
! #write_basic_package_version_file(
! #  "${CMAKE_CURRENT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
! #  VERSION ${SystemCTLM_VERSION_MAJOR}.${SystemCTLM_VERSION_MINOR}.${SystemCTLM_VERSION_PATCH}.${SystemCTLM_VERSION_RELEASE_DATE}
! #  COMPATIBILITY AnyNewerVersion
! #)
! #
! ## Install the <Package>Config.cmake and <Package>ConfigVersion.cmake
! #install(FILES "${PROJECT_BINARY_DIR}/SystemCLanguageConfig.cmake"
! #              "${PROJECT_BINARY_DIR}/SystemCLanguageConfigVersion.cmake"
! #        DESTINATION "${SystemCLanguage_INSTALL_CMAKEDIR}"
! #        COMPONENT dev)
! #install(FILES "${PROJECT_BINARY_DIR}/SystemCTLMConfig.cmake"
! #              "${PROJECT_BINARY_DIR}/SystemCTLMConfigVersion.cmake"
! #        DESTINATION "${SystemCTLM_INSTALL_CMAKEDIR}"
! #        COMPONENT dev)
diff -crB --new-file systemc-2.3.4/src/CMakeLists.txt systemc-2.3.4_patched/src/CMakeLists.txt
*** systemc-2.3.4/src/CMakeLists.txt	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/CMakeLists.txt	2023-07-26 13:44:34.697134000 -0700
***************
*** 419,424 ****
--- 419,431 ----
                       tlm_utils/simple_initiator_socket.h
                       tlm_utils/simple_target_socket.h
                       tlm_utils/tlm_quantumkeeper.h
+ 
+                      # SVC SystemC Elaboration support
+                      sc_elab/elab_alloc.h
+                      sc_elab/elab_alloc.cpp
+                      sc_elab/sc_tool_opts.h
+                      sc_elab/sc_tool_opts.cpp
+ 
                       # QuickThreads
                       $<$<BOOL:${QT_ARCH}>:
                         sysc/packages/qt/qt.c
***************
*** 450,456 ****
                         sysc/packages/qt/qtmd.h
                       >)
  
! add_library (SystemC::systemc ALIAS systemc)
  
  target_compile_definitions (
    systemc
--- 457,463 ----
                         sysc/packages/qt/qtmd.h
                       >)
  
! add_library (SVC::systemc ALIAS systemc)
  
  target_compile_definitions (
    systemc
***************
*** 515,521 ****
  # Install rules for SystemC library
  ###############################################################################
  
! install (TARGETS systemc EXPORT  SystemCLanguageTargets
                           RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
                           LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
                           ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
--- 522,528 ----
  # Install rules for SystemC library
  ###############################################################################
  
! install (TARGETS systemc EXPORT  SVCTargets
                           RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
                           LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
                           ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
diff -crB --new-file systemc-2.3.4/src/sc_elab/allocated_node.h systemc-2.3.4_patched/src/sc_elab/allocated_node.h
*** systemc-2.3.4/src/sc_elab/allocated_node.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/allocated_node.h	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,41 ----
+ //
+ // Created by ripopov on 9/25/18.
+ //
+ 
+ #ifndef SCTOOL_ALLOCATED_NODE_H
+ #define SCTOOL_ALLOCATED_NODE_H
+ 
+ #include <string>
+ #include <vector>
+ 
+ namespace sc_core
+ {
+     class sc_module;
+ }
+ 
+ namespace sc_elab
+ {
+ 
+ /// allocated_node - information about memory allocation
+ struct allocated_node {
+     void *ptr; /// ptr to allocated block
+     sc_core::sc_module* host_mod_p; /// owning sc_module
+     std::size_t size_bytes; /// size of allocation in bytes
+     bool is_array; /// true for new[] allocations
+     std::string mangled_type_name;
+     std::size_t array_size; // number of elements in array for new [X]
+ };
+ 
+ /// get traced dynamic allocations for specified module
+ const std::vector<allocated_node>&
+ get_module_allocs(const sc_core::sc_module* mod_ptr);
+ 
+ /// Calls before_end_of_elaboration callbacks
+ void finalize_elaboration();
+ 
+ /// Generate mangled names for sc_objects, allocated using raw new or new[]
+ void finalize_module_allocations();
+ 
+ }
+ 
+ #endif //SCTOOL_ALLOCATED_NODE_H
diff -crB --new-file systemc-2.3.4/src/sc_elab/elab_alloc.cpp systemc-2.3.4_patched/src/sc_elab/elab_alloc.cpp
*** systemc-2.3.4/src/sc_elab/elab_alloc.cpp	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/elab_alloc.cpp	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,135 ----
+ //
+ // Created by ripopov on 12/18/17.
+ //
+ //
+ 
+ #include <sc_elab/elab_alloc.h>
+ #include <sysc/kernel/sc_module.h>
+ #include <sysc/kernel/sc_simcontext.h>
+ #include <sysc/kernel/sc_module_registry.h>
+ #include <sysc/communication/sc_prim_channel.h>
+ #include <sysc/communication/sc_port.h>
+ #include <sysc/communication/sc_export.h>
+ #include <iostream>
+ #include <unordered_map>
+ #include "elab_alloc.h"
+ 
+ namespace sc_elab
+ {
+ 
+ typedef std::unordered_map<const sc_core::sc_module *,
+                            std::vector<allocated_node>> node_map_t;
+ 
+ /// alloc_node_map stores information about dynamic allocations for each module
+ node_map_t *get_alloc_node_map()
+ {
+     static node_map_t *alloc_node_map = nullptr;
+ 
+     if (!alloc_node_map) {
+         alloc_node_map = new node_map_t{};
+     }
+ 
+     return alloc_node_map;
+ }
+ 
+ /// get current active module (parent of currently created sc_objects)
+ static sc_core::sc_module *curr_module()
+ {
+     auto *simctx = sc_core::sc_curr_simcontext;
+     if (!simctx)
+         return nullptr;
+     simctx->get_module_registry();
+     return simctx->hierarchy_curr();
+ }
+ 
+ /// get dynamic allocations for given module
+ const std::vector<allocated_node> &get_module_allocs(const sc_core::sc_module *mod_ptr)
+ {
+     return get_alloc_node_map()->operator[](mod_ptr);
+ }
+ 
+ void trace_alloc_impl(void *ptr,
+                       bool is_array,
+                       const char *type_name,
+                       size_t sizeof_alloc,
+                       size_t array_size)
+ {
+ 
+     if (curr_module()) {
+         allocated_node new_node;
+         new_node.ptr = ptr;
+         new_node.host_mod_p = curr_module();
+         new_node.size_bytes = sizeof_alloc;
+         new_node.is_array = is_array;
+         if (type_name)
+             new_node.mangled_type_name = type_name;
+         new_node.array_size = array_size;
+ 
+         (*get_alloc_node_map())[curr_module()].emplace_back(std::move(new_node));
+     }
+ }
+ 
+ void finalize_elaboration()
+ {
+     std::cout << "Finalize elaboration\n";
+     auto *context_p = sc_core::sc_get_curr_simcontext();
+     context_p->sc_tool_elaboration();
+ }
+ 
+ void finalize_module_allocations()
+ {
+     // Iterate over all dynamic allocations and add mangled name where it is absent
+     for (auto &allocIter : *get_alloc_node_map()) {
+ 
+         const sc_core::sc_module *mod_ptr = allocIter.first;
+         std::vector<allocated_node> &alloc_nodes = allocIter.second;
+ 
+         for (auto &node : alloc_nodes) {
+ 
+             // If mangled_type_name is empty, then it is sc_object allocated using raw new or new[]
+             if (node.mangled_type_name.empty()) {
+ 
+                 if (node.is_array) {
+                     // TODO:: optimize by reading Linux/Windows ABI manual
+                     // Current implementation should be safe, it
+                     // finds first child sc_object that is inside allocated node
+                     //
+                     // CXX ABI may store a cookie before actual array, so we
+                     // cant just dereference node.ptr (because it may point to cookie,
+                     // instead of first element of array )
+ 
+                     size_t array_size = 0;
+                     size_t node_addr = (size_t) node.ptr;
+                     node.ptr = nullptr;
+ 
+                     // Calculate array size by counting all sc_objects that are
+                     // inside allocated node
+                     for (auto child_obj : mod_ptr->get_child_objects()) {
+ 
+                         size_t child_addr = (size_t) child_obj;
+ 
+                         if (child_addr >= node_addr
+                             && child_addr < node_addr + node.size_bytes) {
+ 
+                             ++array_size;
+ 
+                             if (!node.ptr) {
+                                 node.ptr = dynamic_cast<void *>(child_obj);
+ 								node.mangled_type_name = MANGLED_TYPENAME(*child_obj);
+                             }
+                         }
+                     }
+ 
+                     node.array_size = array_size;
+ 
+                 }
+                 else {
+                     sc_core::sc_object *obj_ptr = static_cast<sc_core::sc_object *>(node.ptr);
+                     node.mangled_type_name = MANGLED_TYPENAME(*obj_ptr);
+                 }
+             }
+         }
+     }
+ }
+ 
+ }
diff -crB --new-file systemc-2.3.4/src/sc_elab/elab_alloc.h systemc-2.3.4_patched/src/sc_elab/elab_alloc.h
*** systemc-2.3.4/src/sc_elab/elab_alloc.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/elab_alloc.h	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,110 ----
+ //
+ // Created by ripopov on 12/18/17.
+ //
+ 
+ #ifndef ELAB_ALLOC_H
+ #define ELAB_ALLOC_H
+ 
+ #include <sc_elab/allocated_node.h>
+ 
+ #include <cstdint>
+ #include <typeinfo>
+ 
+ #ifndef _MSC_VER
+ 
+ template<typename T> std::string MANGLED_TYPENAME() {
+     return typeid(T).name();
+ }
+ 
+ template<typename T> std::string MANGLED_TYPENAME(T &&var) {
+     return typeid(var).name();
+ }
+ 
+ #else
+ 
+ inline std::string adjust_msvc_rawname (const char *rawname)
+ {
+     std::string name = (rawname + 1);
+     if (name[0] == '?')
+         return name;
+     else
+         return "?A" + name;
+ }
+ 
+ template<typename T> std::string MANGLED_TYPENAME() {
+     return adjust_msvc_rawname(typeid(T).raw_name());
+ }
+ 
+ template<typename T> std::string MANGLED_TYPENAME(T &&var) {
+     return adjust_msvc_rawname(typeid(var).raw_name());
+ }
+ 
+ 
+ #endif // !_MSC_VER
+ 
+ /**
+  *  Dynamic memory allocation tracking for SystemC elaboration
+  *
+  *  Currently elaborator supports following allocation methods:
+  *
+  *  1.
+  *  template<class T, class... Args>
+  *  T* sc_new(Args&&... args)
+  *
+  *  usage example:  my_module = sc_new<my_module> ("my_module");
+  *
+  *  2.
+  *  template<class T>
+  *  T* sc_new_array(size_t n)
+  *
+  *  usage example:   int * array_ptr = sc_new_array<int> (10);  // create int[10]
+  *
+  *  3.
+  *  All classes derived from sc_objects can use raw new, it is overloaded in
+  *  sc_object
+  *
+  */
+ namespace sc_elab {
+ 
+ ///
+ /// Store information about dynamically allocated object
+ /// @param ptr - pointer to newly allocated object
+ /// @param is_array - true for new[]
+ /// @param type_name - mangled type name
+ /// @param sizeof_alloc - size of object
+ /// @param array_size - N, number of array elements for new[N]
+ ///
+ void trace_alloc_impl(void *ptr,
+                       bool is_array,
+                       const char *type_name,
+                       size_t sizeof_alloc,
+                       size_t array_size = 0);
+ 
+ 
+ }
+ 
+ namespace sc_core
+ {
+ 
+ /// Allocate singular object dynamically and store information for SVC elaboration
+ template<class T, class... Args>
+ T* sc_new(Args&&... args)
+ {
+     T* rptr = ::new T(std::forward<Args>(args)...);
+     sc_elab::trace_alloc_impl(rptr, false, MANGLED_TYPENAME<T>().c_str() , sizeof(T));
+     return rptr;
+ }
+ 
+ /// Allocate array dynamically and store information for SVC elaboration
+ template<class T>
+ T* sc_new_array(size_t n)
+ {
+     T* rptr = ::new T[n];
+     if (n > 0)
+         sc_elab::trace_alloc_impl(rptr, true, MANGLED_TYPENAME<T>().c_str(), sizeof(T)*n, n);
+     return rptr;
+ }
+ 
+ }
+ 
+ #endif // ELAB_ALLOC_H
\ No newline at end of file
diff -crB --new-file systemc-2.3.4/src/sc_elab/process_type_info.h systemc-2.3.4_patched/src/sc_elab/process_type_info.h
*** systemc-2.3.4/src/sc_elab/process_type_info.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/process_type_info.h	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,18 ----
+ //
+ // Created by ripopov on 10/3/18.
+ //
+ 
+ #ifndef SCTOOL_PROCESS_TYPE_INFO_H
+ #define SCTOOL_PROCESS_TYPE_INFO_H
+ 
+ namespace sc_elab
+ {
+ 
+ struct process_type_info {
+     std::string mangled_host_type; /// Linkage name of host module
+     std::string function_name; /// Name of function
+ };
+ 
+ }
+ 
+ #endif //SCTOOL_PROCESS_TYPE_INFO_H
diff -crB --new-file systemc-2.3.4/src/sc_elab/sc_tool_opts.cpp systemc-2.3.4_patched/src/sc_elab/sc_tool_opts.cpp
*** systemc-2.3.4/src/sc_elab/sc_tool_opts.cpp	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/sc_tool_opts.cpp	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,7 ----
+ //
+ // Created by ripopov on 10/30/18.
+ //
+ 
+ #include "sc_tool_opts.h"
+ 
+ std::string *sctool_extra_opts = nullptr;
diff -crB --new-file systemc-2.3.4/src/sc_elab/sc_tool_opts.h systemc-2.3.4_patched/src/sc_elab/sc_tool_opts.h
*** systemc-2.3.4/src/sc_elab/sc_tool_opts.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/sc_tool_opts.h	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,12 ----
+ //
+ // Created by ripopov on 10/30/18.
+ //
+ 
+ #ifndef SCTOOL_SC_TOOL_OPTS_H
+ #define SCTOOL_SC_TOOL_OPTS_H
+ 
+ #include <string>
+ 
+ extern std::string *sctool_extra_opts;
+ 
+ #endif //SCTOOL_SC_TOOL_OPTS_H
diff -crB --new-file systemc-2.3.4/src/sc_elab/sensitivity.h systemc-2.3.4_patched/src/sc_elab/sensitivity.h
*** systemc-2.3.4/src/sc_elab/sensitivity.h	1969-12-31 16:00:00.000000000 -0800
--- systemc-2.3.4_patched/src/sc_elab/sensitivity.h	2022-12-13 14:27:42.000000000 -0800
***************
*** 0 ****
--- 1,21 ----
+ //
+ // Created by ripopov on 9/28/18.
+ //
+ 
+ #ifndef SCTOOL_SENSITIVITY_H
+ #define SCTOOL_SENSITIVITY_H
+ 
+ namespace sc_core {
+     class sc_process_b;
+ }
+ 
+ namespace sc_elab {
+ 
+ struct port_sens_proc {
+     enum EVENT_KIND {DEFAULT, POSEDGE, NEGEDGE} kind;
+     sc_core::sc_process_b * proc_ptr;
+ };
+ 
+ }
+ 
+ #endif //SCTOOL_SENSITIVITY_H
diff -crB --new-file systemc-2.3.4/src/sysc/communication/sc_event_finder.h systemc-2.3.4_patched/src/sysc/communication/sc_event_finder.h
*** systemc-2.3.4/src/sysc/communication/sc_event_finder.h	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/communication/sc_event_finder.h	2023-07-26 13:44:34.700129000 -0700
***************
*** 110,115 ****
--- 110,121 ----
  
      virtual const sc_event& find_event( sc_interface* if_p = 0 ) const;
  
+     typedef const sc_event& (IF::*event_method_t) () const;
+ 
+     event_method_t get_event_method() {
+         return m_event_method;
+     }
+ 
  private:
  
      const sc_event& (IF::*m_event_method) () const;
diff -crB --new-file systemc-2.3.4/src/sysc/communication/sc_port.cpp systemc-2.3.4_patched/src/sysc/communication/sc_port.cpp
*** systemc-2.3.4/src/sysc/communication/sc_port.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/communication/sc_port.cpp	2023-07-26 13:44:34.703121000 -0700
***************
*** 771,776 ****
--- 771,835 ----
      }
  }
  
+ // SVC
+ 
+ sc_port_base ** sc_port_base::first_parent_port_ptr()
+ {
+     int i = first_parent();
+     if ( i >= 0 ) {
+         return &m_bind_info->vec[i]->parent;
+     }
+ 
+     return nullptr;
+ }
+ 
+ static sc_elab::port_sens_proc create_sens_proc (sc_bind_ef* bind_ef) {
+     sc_elab::port_sens_proc sens;
+     sens.proc_ptr = bind_ef->handle;
+ 
+     if (bind_ef->event_finder) {
+ 
+         typedef sc_core::sc_signal_in_if<bool> bool_in_if;
+         typedef sc_event_finder_t<bool_in_if> bool_in_if_finder;
+ 
+         if (bool_in_if_finder *inif = dynamic_cast<bool_in_if_finder*>(bind_ef->event_finder)) {
+             if ( inif->get_event_method() == &bool_in_if::posedge_event)
+                 sens.kind = sc_elab::port_sens_proc::POSEDGE;
+             else if ( inif->get_event_method() == &bool_in_if::negedge_event)
+                 sens.kind = sc_elab::port_sens_proc::NEGEDGE;
+             else
+                 sens.kind = sc_elab::port_sens_proc::DEFAULT;
+         }
+     } else {
+         sens.kind = sc_elab::port_sens_proc::DEFAULT;
+     }
+ 
+     return sens;
+ 
+ }
+ 
+ std::vector<sc_elab::port_sens_proc> sc_port_base::get_sensitive_procs() const
+ {
+ 
+     std::vector<sc_elab::port_sens_proc> res;
+ 
+     if ( m_bind_info ) {
+ 
+         for (auto met_bind : m_bind_info->method_vec) {
+             res.push_back(create_sens_proc(met_bind));
+         }
+ 
+         for (auto thread_bind : m_bind_info->thread_vec) {
+             res.push_back(create_sens_proc(thread_bind));
+         }
+ 
+     }
+ 
+     return res;
+ }
+ 
+ 
+ 
  } // namespace sc_core
  
  
diff -crB --new-file systemc-2.3.4/src/sysc/communication/sc_port.h systemc-2.3.4_patched/src/sysc/communication/sc_port.h
*** systemc-2.3.4/src/sysc/communication/sc_port.h	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/communication/sc_port.h	2023-07-26 13:44:34.705150000 -0700
***************
*** 37,42 ****
--- 37,44 ----
  #include "sysc/kernel/sc_process.h"
  #include "sysc/utils/sc_typeindex.h"
  
+ #include "sc_elab/sensitivity.h"
+ 
  #if ! defined( SC_DISABLE_VIRTUAL_BIND )
  #  define SC_VIRTUAL_ virtual
  #else
***************
*** 103,108 ****
--- 105,114 ----
      // return RTTI information of associated interface
      virtual sc_type_index get_interface_type() const = 0;
  
+     this_type ** first_parent_port_ptr();
+ 
+     std::vector<sc_elab::port_sens_proc>   get_sensitive_procs() const;
+ 
  protected:
  
      // constructors
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_main.cpp systemc-2.3.4_patched/src/sysc/kernel/sc_main.cpp
*** systemc-2.3.4/src/sysc/kernel/sc_main.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_main.cpp	2023-07-26 13:44:34.708122000 -0700
***************
*** 30,38 ****
--- 30,55 ----
  #include "sysc/kernel/sc_cmnhdr.h"
  #include "sysc/kernel/sc_externs.h"
  
+ #include "sc_elab/sc_tool_opts.h"
+ #include <iostream>
+ 
  int
  main( int argc, char* argv[] )
  {
+     // arguments prefixed with  -sctool  go to SVC, used for debug output options
+     for (int i = 0; i < argc; ++i) {
+         if (std::string(argv[i]) == "-sctool") {
+             if (sctool_extra_opts == nullptr)
+                 sctool_extra_opts = new std::string();
+ 
+             if (i == argc - 1) {
+                 std::cerr << "-sctool specified without passing an option\n";
+                 std::cerr << "Usage: -sctool -some_option\n";
+             }
+ 
+             *sctool_extra_opts = *sctool_extra_opts + " " + argv[i+1];
+         }
+     }
  	return sc_core::sc_elab_and_sim( argc, argv );
  }
  
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_main_main.cpp systemc-2.3.4_patched/src/sysc/kernel/sc_main_main.cpp
*** systemc-2.3.4/src/sysc/kernel/sc_main_main.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_main_main.cpp	2023-07-26 13:44:34.710127000 -0700
***************
*** 96,110 ****
          sc_report_handler::get_handler()
              ( x, sc_report_handler::get_catch_actions() );
      }
!     catch( ... )
!     {
!         // translate other escaping exceptions
!         sc_report*  err_p = sc_handle_exception();
!         if( err_p )
!             sc_report_handler::get_handler()
!                 ( *err_p, sc_report_handler::get_catch_actions() );
!         delete err_p;
!     }
  
      for ( int i = 0; i < argc; ++i ) {
          delete[] argv_copy[i];
--- 96,111 ----
          sc_report_handler::get_handler()
              ( x, sc_report_handler::get_catch_actions() );
      }
! //  In SVC we want to crash regularly on exceptions
! //    catch( ... )
! //    {
! //        // translate other escaping exceptions
! //        sc_report*  err_p = sc_handle_exception();
! //        if( err_p )
! //            sc_report_handler::get_handler()
! //                ( *err_p, sc_report_handler::get_catch_actions() );
! //        delete err_p;
! //    }
  
      for ( int i = 0; i < argc; ++i ) {
          delete[] argv_copy[i];
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_module.cpp systemc-2.3.4_patched/src/sysc/kernel/sc_module.cpp
*** systemc-2.3.4/src/sysc/kernel/sc_module.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_module.cpp	2023-07-26 13:44:34.712152000 -0700
***************
*** 54,59 ****
--- 54,62 ----
  
  namespace sc_core {
  
+ std::unordered_map<const sc_core::sc_process_b *, sc_elab::process_type_info>
+     proc_info_map;
+ 
  // ----------------------------------------------------------------------------
  //  CLASS : sc_module_dynalloc_list
  //
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_module.h systemc-2.3.4_patched/src/sysc/kernel/sc_module.h
*** systemc-2.3.4/src/sysc/kernel/sc_module.h	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_module.h	2023-07-26 13:44:34.715135000 -0700
***************
*** 42,47 ****
--- 42,51 ----
  #include "sysc/kernel/sc_process_handle.h"
  #include "sysc/utils/sc_list.h"
  
+ #include <sc_elab/process_type_info.h>
+ #include <unordered_map>
+ 
+ 
  namespace sc_core {
  
  class sc_name_gen;
***************
*** 413,424 ****
--- 417,440 ----
  // template<typename X>
  // class A : public B<X>
  
+ extern
+ std::unordered_map<const sc_core::sc_process_b *, sc_elab::process_type_info>
+     proc_info_map;
+ 
+ // Save process class and method name so SVC can use it to find in Clang AST
+ #define register_process(handle, func_name) \
+         sc_core::sc_process_b *proc = handle; \
+         std::string hostType = MANGLED_TYPENAME<typename std::remove_reference<decltype(*this)>::type>(); \
+         std::string methodName = func_name; \
+         sc_core::proc_info_map[proc] = sc_elab::process_type_info{hostType, methodName};
+ 
  #define declare_method_process(handle, name, host_tag, func)        \
      {		                                                    \
          ::sc_core::sc_process_handle handle =                      \
  	    sc_core::sc_get_curr_simcontext()->create_method_process( \
  		name,  false, SC_MAKE_FUNC_PTR( host_tag, func ), \
  		this, 0 ); \
+         register_process(handle, #func) \
          this->sensitive << handle;                                        \
          this->sensitive_pos << handle;                                    \
          this->sensitive_neg << handle;                                    \
***************
*** 430,435 ****
--- 446,452 ----
  	     sc_core::sc_get_curr_simcontext()->create_thread_process( \
                   name,  false,           \
                   SC_MAKE_FUNC_PTR( host_tag, func ), this, 0 ); \
+         register_process(handle, #func) \
          this->sensitive << handle;                                        \
          this->sensitive_pos << handle;                                    \
          this->sensitive_neg << handle;                                    \
***************
*** 441,446 ****
--- 458,464 ----
  	     sc_core::sc_get_curr_simcontext()->create_cthread_process( \
              name,  false,          \
                       SC_MAKE_FUNC_PTR( host_tag, func ), this, 0 ); \
+         register_process(handle, #func) \
          this->sensitive.operator() ( handle, edge );\
      }
  
***************
*** 472,477 ****
--- 490,500 ----
  typedef sc_module sc_channel;
  typedef sc_module sc_behavior;
  
+ // Not a modular interface  (Prevent module inherited from sc_interface to become modular interface)
+ struct sc_dont_collapse {};
+ // Modular interface
+ struct sc_modular_interface : sc_module {};
+ 
  } // namespace sc_core
  
  /*****************************************************************************
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_object.h systemc-2.3.4_patched/src/sysc/kernel/sc_object.h
*** systemc-2.3.4/src/sysc/kernel/sc_object.h	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_object.h	2023-07-26 13:44:34.719140000 -0700
***************
*** 31,36 ****
--- 31,37 ----
  #define SC_OBJECT_H
  
  #include "sysc/kernel/sc_attribute.h"
+ #include "sc_elab/elab_alloc.h"
  #include <iostream>
  
  #if defined(_MSC_VER) && !defined(SC_WIN_DLL_WARN)
***************
*** 116,121 ****
--- 117,139 ----
      sc_object* get_parent() const;
      sc_object* get_parent_object() const { return m_parent; }
  
+     void* operator new(std::size_t sz)
+     {
+         void *rptr = ::operator new(sz);
+         // we don't know type of allocation yet, it will be filled later
+         sc_elab::trace_alloc_impl(rptr, false, nullptr, sz);
+         return rptr;
+     }
+ 
+     void* operator new[](std::size_t sz)
+     {
+         void *rptr = ::operator new(sz);
+         if (sz >= sizeof(sc_object)) {
+             sc_elab::trace_alloc_impl(rptr, true, nullptr, sz);
+         }
+         return rptr;
+     }
+ 
  protected:
  
      sc_object();
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_process.h systemc-2.3.4_patched/src/sysc/kernel/sc_process.h
*** systemc-2.3.4/src/sysc/kernel/sc_process.h	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_process.h	2023-07-26 13:44:34.722126000 -0700
***************
*** 356,361 ****
--- 356,362 ----
      inline sc_curr_proc_kind proc_kind() const;
      sc_event& reset_event();
      sc_event& terminated_event();
+     const std::vector<const sc_event*>& get_static_events() {return m_static_events;}
  
    public:
      static inline sc_process_handle last_created_process_handle();
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_reset.cpp systemc-2.3.4_patched/src/sysc/kernel/sc_reset.cpp
*** systemc-2.3.4/src/sysc/kernel/sc_reset.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_reset.cpp	2023-07-26 13:44:34.725122000 -0700
***************
*** 220,229 ****
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
!         iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
!         if ( iface_p )
!             reset_signal_is( async, *iface_p, level );
!         else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
--- 220,231 ----
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
! 
! // SVC elaborator : Always use finders to keep ports
! //        iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
! //        if ( iface_p )
! //            reset_signal_is( async, *iface_p, level );
! //        else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
***************
*** 246,255 ****
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
!         iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
!         if ( iface_p )
!             reset_signal_is( async, *iface_p, level );
!         else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
--- 248,259 ----
        case SC_THREAD_PROC_:
        case SC_METHOD_PROC_:
        case SC_CTHREAD_PROC_:
! 
! // SVC elaborator : Always use finders to keep ports
! //        iface_p = dynamic_cast<const sc_signal_in_if<bool>*>(port.get_interface());
! //        if ( iface_p )
! //            reset_signal_is( async, *iface_p, level );
! //        else
              new sc_reset_finder( async, &port, level, process_p );
          break;
        default:
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_simcontext.cpp systemc-2.3.4_patched/src/sysc/kernel/sc_simcontext.cpp
*** systemc-2.3.4/src/sysc/kernel/sc_simcontext.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_simcontext.cpp	2023-07-26 13:44:34.728130000 -0700
***************
*** 621,626 ****
--- 621,643 ----
  }
  
  void
+ sc_simcontext::sc_tool_elaboration()
+ {
+     if( m_elaboration_done || sim_status() != SC_SIM_OK ) {
+         return;
+     }
+ 
+     // Instantiate the method invocation module
+     // (not added to public object hierarchy)
+ 
+     m_method_invoker_p =
+         new sc_invoke_method("$$$$kernel_module$$$$_invoke_method" );
+ 
+     m_simulation_status = SC_BEFORE_END_OF_ELABORATION;
+     m_module_registry->construction_done();
+ }
+ 
+ void
  sc_simcontext::elaborate()
  {
      if( m_elaboration_done || sim_status() != SC_SIM_OK ) {
diff -crB --new-file systemc-2.3.4/src/sysc/kernel/sc_simcontext.h systemc-2.3.4_patched/src/sysc/kernel/sc_simcontext.h
*** systemc-2.3.4/src/sysc/kernel/sc_simcontext.h	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/kernel/sc_simcontext.h	2023-07-26 13:44:34.731123000 -0700
***************
*** 287,292 ****
--- 287,293 ----
  
      const ::std::vector<sc_object*>& get_child_objects() const;
  
+     void sc_tool_elaboration();
      void elaborate();
      void prepare_to_simulate();
      inline void initial_crunch( bool no_crunch );
diff -crB --new-file systemc-2.3.4/src/sysc/tracing/sc_vcd_trace.cpp systemc-2.3.4_patched/src/sysc/tracing/sc_vcd_trace.cpp
*** systemc-2.3.4/src/sysc/tracing/sc_vcd_trace.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/tracing/sc_vcd_trace.cpp	2023-07-26 13:44:34.734126000 -0700
***************
*** 2217,2223 ****
  SC_API sc_trace_file*
  sc_create_vcd_trace_file(const char * name)
  {
!     sc_trace_file * tf = new vcd_trace_file(name);
      return tf;
  }
  
--- 2217,2223 ----
  SC_API sc_trace_file*
  sc_create_vcd_trace_file(const char * name)
  {
!     sc_trace_file * tf = ::new vcd_trace_file(name);
      return tf;
  }
  
diff -crB --new-file systemc-2.3.4/src/sysc/tracing/sc_wif_trace.cpp systemc-2.3.4_patched/src/sysc/tracing/sc_wif_trace.cpp
*** systemc-2.3.4/src/sysc/tracing/sc_wif_trace.cpp	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/sysc/tracing/sc_wif_trace.cpp	2023-07-26 13:44:34.737123000 -0700
***************
*** 1904,1910 ****
  SC_API sc_trace_file*
  sc_create_wif_trace_file(const char * name)
  {
!     sc_trace_file *tf = new wif_trace_file(name);
      return tf;
  }
  
--- 1904,1910 ----
  SC_API sc_trace_file*
  sc_create_wif_trace_file(const char * name)
  {
!     sc_trace_file *tf = ::new wif_trace_file(name);
      return tf;
  }
  
diff -crB --new-file systemc-2.3.4/src/systemc systemc-2.3.4_patched/src/systemc
*** systemc-2.3.4/src/systemc	2022-12-02 08:13:58.000000000 -0800
--- systemc-2.3.4_patched/src/systemc	2023-07-26 13:44:34.739121000 -0700
***************
*** 74,79 ****
--- 74,82 ----
  #include "sysc/kernel/sc_module.h"
  #include "sysc/kernel/sc_simcontext.h"
  #include "sysc/kernel/sc_process_handle.h"
+ #include "sysc/kernel/sc_method_process.h"
+ #include "sysc/kernel/sc_thread_process.h"
+ #include "sysc/kernel/sc_cthread_process.h"
  #include "sysc/kernel/sc_ver.h"
  
  #include "sysc/communication/sc_buffer.h"
***************
*** 117,122 ****
--- 120,127 ----
  #include "sysc/utils/sc_string_view.h"
  #include "sysc/utils/sc_vector.h"
  
+ #include "sc_elab/elab_alloc.h"
+ 
  #endif // !defined(SYSTEMC_INCLUDED)
  
  #ifdef SC_INCLUDE_DYNAMIC_PROCESSES

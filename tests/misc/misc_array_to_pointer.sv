//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
);

// SystemC signals
logic clk;
logic nrst;


//------------------------------------------------------------------------------

A a_mod
(
  .clk(clk),
  .nrst(nrst)
);

endmodule



//==============================================================================
//
// Module: A (test_array_to_pointer.cpp:104:5)
//
module A // "b_mod.a_mod"
(
    input logic clk,
    input logic nrst
);

// SystemC signals
logic signed [31:0] s;

//------------------------------------------------------------------------------
// Method process: read_array (test_array_to_pointer.cpp:66:5) 

// Process-local variables
logic signed [31:0] pi[3];
logic signed [31:0] pa[3];
logic signed [31:0] pb[3];

always_comb 
begin : read_array     // test_array_to_pointer.cpp:66:5
    integer i;
    i = pi[0];
    i = pa[1];
    i = pb[s];
end

//------------------------------------------------------------------------------
// Clocked THREAD: write_array (test_array_to_pointer.cpp:74:5) 

// Thread-local variables
logic signed [31:0] pj[3];
logic signed [31:0] pj_next[3];
logic signed [31:0] pc[3];
logic signed [31:0] pc_next[3];
logic signed [31:0] pd[3];
logic write_array_PROC_STATE;
logic write_array_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : write_array_comb     // test_array_to_pointer.cpp:74:5
    write_array_func;
end
function void write_array_func;
    pc_next = pc;
    pj_next = pj;
    write_array_PROC_STATE_next = write_array_PROC_STATE;
    
    case (write_array_PROC_STATE)
        0: begin
            pc_next[s] = pj_next[1];
            write_array_PROC_STATE_next = 1; return;    // test_array_to_pointer.cpp:83:13;
        end
        1: begin
            pd[s + 1] = pc_next[1];
            pc_next[s] = pj_next[1];
            write_array_PROC_STATE_next = 1; return;    // test_array_to_pointer.cpp:83:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(negedge clk or negedge nrst) 
begin : write_array_ff
    if ( ~nrst ) begin
        for (integer i = 0; i < 3; i++)
        begin
            pj[i] <= i;
        end
        write_array_PROC_STATE <= 0;    // test_array_to_pointer.cpp:79:9;
    end
    else begin
        pj <= pj_next;
        pc <= pc_next;
        write_array_PROC_STATE <= write_array_PROC_STATE_next;
    end
end

endmodule



//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.35
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "test_top.a_mod"
(
    input logic clk,
    input logic rstn
);

// Variables generated for SystemC signals
logic signed [31:0] s;
logic signed [31:0] s_d;
logic signed [31:0] s_d2;
logic signed [31:0] s_d3;
logic signed [31:0] ps;
logic st;
logic [3:0] st1;
logic st2;
logic st_enbl;
logic st_enbl_d;
logic [3:0] cntr;

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread (test_sva_generate_stable.cpp:66:5) 

// Thread-local variables
logic signed [31:0] s_next;
logic signed [31:0] s_d_next;
logic signed [31:0] s_d2_next;
logic signed [31:0] s_d3_next;
logic signed [31:0] ps_next;
logic [3:0] st1_next;
logic st2_next;
logic st_enbl_next;
logic st_enbl_d_next;
logic [3:0] cntr_;
logic [3:0] cntr__next;
logic [3:0] cntr_next;

// Next-state combinational logic
always_comb begin : test_thread_comb     // test_sva_generate_stable.cpp:66:5
    test_thread_func;
end
function void test_thread_func;
    cntr__next = cntr_;
    cntr_next = cntr;
    ps_next = ps;
    s_d2_next = s_d2;
    s_d3_next = s_d3;
    s_d_next = s_d;
    s_next = s;
    st1_next = st1;
    st2_next = st2;
    st_enbl_d_next = st_enbl_d;
    st_enbl_next = st_enbl;
    s_d_next = s;
    s_d2_next = s_d;
    s_d3_next = s_d2;
    ps_next = s;
    s_next = !(|s);
    if (cntr__next >= 7 || cntr__next == 0)
    begin
        st1_next = 1;
    end else begin
        st1_next = s;
    end
    if (st_enbl)
    begin
        st2_next = 1;
    end else begin
        st2_next = 0;
    end
    st_enbl_next = cntr >= 7;
    st_enbl_d_next = st_enbl;
    cntr_next = cntr__next;
    cntr__next++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : test_thread_ff
    if ( ~rstn ) begin
        s <= 0;
        s_d <= 0;
        s_d2 <= 0;
        s_d3 <= 0;
        ps <= 0;
        st <= 1;
        st1 <= 0;
        st2 <= 0;
        cntr_ <= 0;
        st_enbl <= 0;
        st_enbl_d <= 0;
    end
    else begin
        s <= s_next;
        s_d <= s_d_next;
        s_d2 <= s_d2_next;
        s_d3 <= s_d3_next;
        ps <= ps_next;
        st1 <= st1_next;
        st2 <= st2_next;
        st_enbl <= st_enbl_next;
        st_enbl_d <= st_enbl_d_next;
        cntr_ <= cntr__next;
        cntr <= cntr_next;
    end
end

`ifndef INTEL_SVA_OFF
sctAssertLine45 : assert property (
    @(posedge clk) rstn |-> $stable(st) );
sctAssertLine46 : assert property (
    @(posedge clk) st_enbl |=> $stable(|st1) );
sctAssertLine47 : assert property (
    @(posedge clk) st_enbl && !st_enbl_d |=> $rose(st2) );
sctAssertLine48 : assert property (
    @(posedge clk) cntr == 1 |-> $fell(|s) );
sctAssertLine49 : assert property (
    @(posedge clk) cntr == 2 |=> $fell(|s) );
sctAssertLine50 : assert property (
    @(posedge clk) cntr == 2 |-> $rose(|s) );
sctAssertLine52 : assert property (
    @(posedge clk) cntr == 8 |-> $stable(|st1) );
sctAssertLine53 : assert property (
    @(posedge clk) cntr == 7 |=> $stable(|st1) );
sctAssertLine54 : assert property (
    @(posedge clk) cntr == 8 |-> $stable(|st1)[*2] );
sctAssertLine55 : assert property (
    @(posedge clk) cntr == 7 |=> $stable(|st1)[*2] );
sctAssertLine57 : assert property (
    @(posedge clk) cntr == 7 |=> $stable(|st1)[*4] );
sctAssertLine58 : assert property (
    @(posedge clk) cntr == 15 |=> $stable(|st1)[*2] );
sctAssertLine59 : assert property (
    @(posedge clk) cntr == 15 |-> $stable(|st1)[*3] );
sctAssertLine61 : assert property (
    @(posedge clk) cntr > 7 && cntr < 15 |-> $stable(|st1)[*3] );
sctAssertLine62 : assert property (
    @(posedge clk) cntr > 7 && cntr < 15 |=> $stable(|st1)[*3] );
`endif // INTEL_SVA_OFF

endmodule



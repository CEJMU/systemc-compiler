//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// SystemC signals
logic nrst;
logic [3:0] s;
logic signed [31:0] t;
logic signed [3:0] s1;
logic signed [63:0] s2;
logic signed [3:0] s3;

// C++ data variables
localparam logic signed [31:0] NARR[3] = '{ -'d1, -'d2, -'d3 };
localparam logic [31:0] ARR[3] = '{ 'd1, 'd2, 'd3 };
localparam logic [3:0] marr[3] = '{ 'd4, 'd5, 'd6 };
localparam logic grec1_a = 0;
localparam logic [3:0] grec1_b = 'd4;
localparam logic grec2_a = 1;
localparam logic [3:0] grec2_b = 'd5;

//------------------------------------------------------------------------------
// Method process: const_range1 (test_const_remove.cpp:108:5) 

always_comb 
begin : const_range1     // test_const_remove.cpp:108:5
    logic [3:0] larr[3];
    integer l;
    larr[0] = 1; larr[1] = 2; larr[2] = 3;
    l = R[s];
    l = L[2 : 1];
    l = larr[2][2 : 1];
    l = marr[0][1];
    l = larr[s][2 : 1] + marr[s][1];
end

//------------------------------------------------------------------------------
// Method process: const_range2 (test_const_remove.cpp:126:5) 

always_comb 
begin : const_range2     // test_const_remove.cpp:126:5
    logic [2:0] val;
    integer l;
    val = 1;
    // Call cval() begin
    l = val[2 : 1];
    // Call cval() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: negative_cost_ref1 (test_const_remove.cpp:153:5) 

// Thread-local variables
logic signed [3:0] s1_next;
logic negative_cost_ref1_PROC_STATE;
logic negative_cost_ref1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : negative_cost_ref1_comb     // test_const_remove.cpp:153:5
    negative_cost_ref1_func;
end
function void negative_cost_ref1_func;
    logic signed [3:0] x;
    logic signed [3:0] par;
    s1_next = s1;
    negative_cost_ref1_PROC_STATE_next = negative_cost_ref1_PROC_STATE;
    
    case (negative_cost_ref1_PROC_STATE)
        0: begin
            x = -3'sd3;
            par = x + 1;
            // Call cref1() begin
            s1_next = par;
            // Call cref1() end
            negative_cost_ref1_PROC_STATE_next = 1; return;    // test_const_remove.cpp:159:13;
        end
        1: begin
            par = -2'sd1;
            // Call cref1() begin
            s1_next = par;
            // Call cref1() end
            x = -3'sd3;
            par = x + 1;
            // Call cref1() begin
            s1_next = par;
            // Call cref1() end
            negative_cost_ref1_PROC_STATE_next = 1; return;    // test_const_remove.cpp:159:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : negative_cost_ref1_ff
    if ( ~nrst ) begin
        negative_cost_ref1_PROC_STATE <= 0;    // test_const_remove.cpp:155:9;
    end
    else begin
        s1 <= s1_next;
        negative_cost_ref1_PROC_STATE <= negative_cost_ref1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: negative_cost_ref2 (test_const_remove.cpp:164:5) 

// Thread-local variables
logic signed [63:0] s2_next;
logic [1:0] negative_cost_ref2_PROC_STATE;
logic [1:0] negative_cost_ref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : negative_cost_ref2_comb     // test_const_remove.cpp:164:5
    negative_cost_ref2_func;
end
function void negative_cost_ref2_func;
    logic signed [63:0] par;
    s2_next = s2;
    negative_cost_ref2_PROC_STATE_next = negative_cost_ref2_PROC_STATE;
    
    case (negative_cost_ref2_PROC_STATE)
        0: begin
            par = -7'sd42;
            // Call cref2() begin
            s2_next = par + 1;
            // Call cref2() end
            negative_cost_ref2_PROC_STATE_next = 1; return;    // test_const_remove.cpp:169:13;
        end
        1: begin
            // Call cref2() begin
            s2_next = NARR[s] + 1;
            // Call cref2() end
            negative_cost_ref2_PROC_STATE_next = 2; return;    // test_const_remove.cpp:171:13;
        end
        2: begin
            par = -7'sd42;
            // Call cref2() begin
            s2_next = par + 1;
            // Call cref2() end
            negative_cost_ref2_PROC_STATE_next = 1; return;    // test_const_remove.cpp:169:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : negative_cost_ref2_ff
    if ( ~nrst ) begin
        negative_cost_ref2_PROC_STATE <= 0;    // test_const_remove.cpp:166:9;
    end
    else begin
        s2 <= s2_next;
        negative_cost_ref2_PROC_STATE <= negative_cost_ref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: negative_cost_ref3 (test_const_remove.cpp:175:5) 

// Thread-local variables
logic signed [3:0] l;
logic signed [3:0] l_next;
logic signed [3:0] s3_next;
logic signed [3:0] l0;
logic signed [3:0] l_next0;
logic signed [3:0] par;
logic signed [3:0] par_next;
logic [1:0] negative_cost_ref3_PROC_STATE;
logic [1:0] negative_cost_ref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : negative_cost_ref3_comb     // test_const_remove.cpp:175:5
    negative_cost_ref3_func;
end
function void negative_cost_ref3_func;
    l_next = l;
    l_next0 = l0;
    par_next = par;
    s3_next = s3;
    negative_cost_ref3_PROC_STATE_next = negative_cost_ref3_PROC_STATE;
    
    case (negative_cost_ref3_PROC_STATE)
        0: begin
            par_next = -4'sd6;
            // Call cref3() begin
            l_next0 = 1;
            negative_cost_ref3_PROC_STATE_next = 1; return;    // test_const_remove.cpp:148:9;
            // Call cref3() end
        end
        1: begin
            // Call cref3() begin
            l_next0 = l_next0 + par_next;
            s3_next = l_next0;
            // Call cref3() end
            // Call cref3() begin
            l_next = 1;
            negative_cost_ref3_PROC_STATE_next = 2; return;    // test_const_remove.cpp:148:9;
            // Call cref3() end
        end
        2: begin
            // Call cref3() begin
            l_next = l_next + NARR[2];
            s3_next = l_next;
            // Call cref3() end
            par_next = -4'sd6;
            // Call cref3() begin
            l_next0 = 1;
            negative_cost_ref3_PROC_STATE_next = 1; return;    // test_const_remove.cpp:148:9;
            // Call cref3() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : negative_cost_ref3_ff
    if ( ~nrst ) begin
        negative_cost_ref3_PROC_STATE <= 0;    // test_const_remove.cpp:177:9;
    end
    else begin
        l <= l_next;
        s3 <= s3_next;
        l0 <= l_next0;
        par <= par_next;
        negative_cost_ref3_PROC_STATE <= negative_cost_ref3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: static_const_thread (test_const_remove.cpp:193:5) 

// Thread-local constants
logic signed [31:0] cs;
logic signed [31:0] c;

// Next-state combinational logic
always_comb begin : static_const_thread_comb     // test_const_remove.cpp:193:5
    static_const_thread_func;
end
function void static_const_thread_func;
    integer TMP_0;
    integer TMP_3;
    integer k;
    k = c % cs;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : static_const_thread_ff
    if ( ~nrst ) begin
        integer TMP_0;
        integer TMP_3;
        // Call ff() begin
        TMP_0 = 42;
        // Call ff() end
        c = TMP_0;
        // Call ff() begin
        TMP_3 = 42;
        // Call ff() end
        cs = TMP_3 - 1;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: sig_init_method (test_const_remove.cpp:215:5) 

always_comb 
begin : sig_init_method     // test_const_remove.cpp:215:5
    integer LC1;
    logic [3:0] LC2;
    integer h;
    LC1 = t;
    LC2 = s;
    h = 42 + LC1 + signed'({1'b0, LC2});
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_init_thread (test_const_remove.cpp:225:5) 

// Thread-local constants
logic signed [31:0] TC1;
logic signed [31:0] TC2;

// Next-state combinational logic
always_comb begin : sig_init_thread_comb     // test_const_remove.cpp:225:5
    sig_init_thread_func;
end
function void sig_init_thread_func;
    integer TMP_0;
    logic [3:0] TC4;
    integer TMP_3;
    integer TC5;
    integer n;
    integer m;
    TC4 = s;
    // Call f() begin
    TMP_3 = 42;
    // Call f() end
    TC5 = TMP_3;
    n = signed'({1'b0, TC4}) + TC5 + 44;
    m = 42 + TC1 + TC2 + 43;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : sig_init_thread_ff
    if ( ~nrst ) begin
        integer TMP_0;
        TC1 = t;
        // Call f() begin
        TMP_0 = 42;
        // Call f() end
        TC2 = TMP_0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: no_sens_method (test_const_remove.cpp:243:5) 

integer a;
assign a = 43 + 43 + 45;

//------------------------------------------------------------------------------
// Method process: const_method (test_const_remove.cpp:248:5) 

always_comb 
begin : const_method     // test_const_remove.cpp:248:5
    integer unsigned b;
    b = 42 + 43 + 45 + 3;
end

//------------------------------------------------------------------------------
// Method process: const_array_method (test_const_remove.cpp:253:5) 

always_comb 
begin : const_array_method     // test_const_remove.cpp:253:5
    integer unsigned sum;
    integer e;
    sum = 0;
    for (integer i = 0; i < 3; ++i)
    begin
        sum = sum + ARR[i];
    end
    e = 2;
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_thread (test_const_remove.cpp:262:5) 

// Thread-local variables
logic const_thread_PROC_STATE;
logic const_thread_PROC_STATE_next;

// Thread-local constants

// Next-state combinational logic
always_comb begin : const_thread_comb     // test_const_remove.cpp:262:5
    const_thread_func;
end
function void const_thread_func;
    integer unsigned d;
    const_thread_PROC_STATE_next = const_thread_PROC_STATE;
    
    case (const_thread_PROC_STATE)
        0: begin
            d = 42 + 44 + 46 + 43;
            const_thread_PROC_STATE_next = 1; return;    // test_const_remove.cpp:272:13;
        end
        1: begin
            d = 42 + 44 + 46 + 43;
            const_thread_PROC_STATE_next = 1; return;    // test_const_remove.cpp:272:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_thread_ff
    if ( ~nrst ) begin
        integer c;
        c = 44;
        const_thread_PROC_STATE <= 0;    // test_const_remove.cpp:267:9;
    end
    else begin
        const_thread_PROC_STATE <= const_thread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: const_local_array_method (test_const_remove.cpp:277:5) 

always_comb 
begin : const_local_array_method     // test_const_remove.cpp:277:5
    integer unsigned LARR[3];
    integer unsigned lsum;
    integer f;
    LARR[0] = 1; LARR[1] = 2; LARR[2] = 3;
    lsum = 0;
    for (integer i = 0; i < 3; ++i)
    begin
        lsum = lsum + LARR[i];
    end
    f = 2;
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_local_array_thread (test_const_remove.cpp:289:5) 

// Thread-local constants
logic [31:0] TARR[3];

// Next-state combinational logic
always_comb begin : const_local_array_thread_comb     // test_const_remove.cpp:289:5
    const_local_array_thread_func;
end
function void const_local_array_thread_func;
    integer unsigned tsum;
    integer g;
    tsum = 0;
    for (integer i = 0; i < 3; ++i)
    begin
        tsum = tsum + TARR[i];
    end
    g = 2;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_local_array_thread_ff
    if ( ~nrst ) begin
        TARR[0] = 1; TARR[1] = 2; TARR[2] = 3;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_ref_call_thread (test_const_remove.cpp:312:5) 

// Next-state combinational logic
always_comb begin : const_ref_call_thread_comb     // test_const_remove.cpp:312:5
    const_ref_call_thread_func;
end
function void const_ref_call_thread_func;
    integer par;
    integer aa;
    par = 42;
    // Call g() begin
    aa = par + 1;
    // Call g() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_ref_call_thread_ff
    if ( ~nrst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: const_record_method (test_const_remove.cpp:336:5) 

always_comb 
begin : const_record_method     // test_const_remove.cpp:336:5
    logic a_1;
    logic [3:0] b;
    logic rec_a;
    logic [3:0] rec_b;
    logic c;
    a_1 = 0; b = 1;
    rec_a = a_1;
    rec_b = b;
    c = rec_a || grec1_a;
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread (test_const_remove.cpp:342:5) 

// Thread-local variables
logic [3:0] trec3_b;
logic [3:0] trec3_b_next;
logic const_record_thread_PROC_STATE;
logic const_record_thread_PROC_STATE_next;

// Thread-local constants
logic trec1_a;
logic [3:0] trec1_b;

// Next-state combinational logic
always_comb begin : const_record_thread_comb     // test_const_remove.cpp:342:5
    const_record_thread_func;
end
function void const_record_thread_func;
    logic a;
    logic [3:0] b;
    logic trec2_a;
    logic [3:0] trec2_b;
    logic trec3_a;
    integer i;
    trec3_b_next = trec3_b;
    const_record_thread_PROC_STATE_next = const_record_thread_PROC_STATE;
    
    case (const_record_thread_PROC_STATE)
        0: begin
            a = 1; b = 2;
            trec2_a = a;
            trec2_b = b;
            a = 1; b = 3;
            trec3_a = a;
            trec3_b_next = b;
            i = trec1_b + trec2_b;
            const_record_thread_PROC_STATE_next = 1; return;    // test_const_remove.cpp:353:13;
        end
        1: begin
            i = trec3_b_next + grec2_b;
            a = 1; b = 2;
            trec2_a = a;
            trec2_b = b;
            a = 1; b = 3;
            trec3_a = a;
            trec3_b_next = b;
            i = trec1_b + trec2_b;
            const_record_thread_PROC_STATE_next = 1; return;    // test_const_remove.cpp:353:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread_ff
    if ( ~nrst ) begin
        logic a;
        logic [3:0] b;
        logic c;
        a = 0; b = 1;
        trec1_a = a;
        trec1_b = b;
        c = trec1_a;
        const_record_thread_PROC_STATE <= 0;    // test_const_remove.cpp:347:9;
    end
    else begin
        trec3_b <= trec3_b_next;
        const_record_thread_PROC_STATE <= const_record_thread_PROC_STATE_next;
    end
end

`ifndef INTEL_SVA_OFF
sctAssertLine210 : assert property (
    @(posedge clk) 1 |-> s != 4 - 1 );
`endif // INTEL_SVA_OFF

endmodule



//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test_split_shared ()
//
module test_split_shared // "test"
(
);

// SystemC signals
logic clk;
logic rstn;
logic signed [31:0] a_sig;
logic signed [31:0] b_sig;
logic signed [31:0] c_sig;

//------------------------------------------------------------------------------
// Clocked THREAD: thread_0 (test_cthread_shared_vars.cpp:27:5) 

// Thread-local variables
logic signed [31:0] a_sig_next;
logic signed [31:0] z;
logic signed [31:0] z_next;
logic signed [31:0] comb;
logic [1:0] thread_0_PROC_STATE;
logic [1:0] thread_0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_0_comb     // test_cthread_shared_vars.cpp:27:5
    thread_0_func;
end
function void thread_0_func;
    a_sig_next = a_sig;
    z_next = z;
    thread_0_PROC_STATE_next = thread_0_PROC_STATE;
    
    case (thread_0_PROC_STATE)
        0: begin
            z_next = 0;
            comb = z_next;
            a_sig_next = 1 + comb;
            thread_0_PROC_STATE_next = 1; return;    // test_cthread_shared_vars.cpp:34:13;
        end
        1: begin
            a_sig_next = 2 + z_next;
            thread_0_PROC_STATE_next = 2; return;    // test_cthread_shared_vars.cpp:36:13;
        end
        2: begin
            a_sig_next = 12;
            z_next = 0;
            comb = z_next;
            a_sig_next = 1 + comb;
            thread_0_PROC_STATE_next = 1; return;    // test_cthread_shared_vars.cpp:34:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_0_ff
    if ( ~rstn ) begin
        a_sig <= 0;
        thread_0_PROC_STATE <= 0;    // test_cthread_shared_vars.cpp:29:9;
    end
    else begin
        a_sig <= a_sig_next;
        z <= z_next;
        thread_0_PROC_STATE <= thread_0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_1 (test_cthread_shared_vars.cpp:42:5) 

// Thread-local variables
logic signed [31:0] b_sig_next;
logic signed [31:0] c_sig_next;
logic [1:0] thread_1_PROC_STATE;
logic [1:0] thread_1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_1_comb     // test_cthread_shared_vars.cpp:42:5
    thread_1_func;
end
function void thread_1_func;
    b_sig_next = b_sig;
    c_sig_next = c_sig;
    thread_1_PROC_STATE_next = thread_1_PROC_STATE;
    
    case (thread_1_PROC_STATE)
        0: begin
            c_sig_next = a_sig + c_sig;
            thread_1_PROC_STATE_next = 1; return;    // test_cthread_shared_vars.cpp:48:13;
        end
        1: begin
            b_sig_next = 12;
            thread_1_PROC_STATE_next = 2; return;    // test_cthread_shared_vars.cpp:50:13;
        end
        2: begin
            c_sig_next = a_sig + c_sig;
            thread_1_PROC_STATE_next = 1; return;    // test_cthread_shared_vars.cpp:48:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_1_ff
    if ( ~rstn ) begin
        b_sig <= 0;
        c_sig <= 0;
        thread_1_PROC_STATE <= 0;    // test_cthread_shared_vars.cpp:45:9;
    end
    else begin
        b_sig <= b_sig_next;
        c_sig <= c_sig_next;
        thread_1_PROC_STATE <= thread_1_PROC_STATE_next;
    end
end

endmodule



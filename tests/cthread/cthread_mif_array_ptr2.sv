//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// SystemC signals
logic rst;
logic [3:0] minst_s[2];
logic [3:0] minst_ss[2];

//------------------------------------------------------------------------------
// Method process: minst_meth (test_cthread_mif_array_ptr2.cpp:24:5) 

always_comb 
begin : minst_meth     // test_cthread_mif_array_ptr2.cpp:24:5
    logic [3:0] a;
    a = minst_s[0];
end

//------------------------------------------------------------------------------
// Method process: minst_meth0 (test_cthread_mif_array_ptr2.cpp:24:5) 

always_comb 
begin : minst_meth0     // test_cthread_mif_array_ptr2.cpp:24:5
    logic [3:0] a;
    a = minst_s[1];
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_comb (test_cthread_mif_array_ptr2.cpp:83:5) 

// Thread-local variables
logic [3:0] minst_vv[2];

// Next-state combinational logic
always_comb begin : top_thread_comb_comb     // test_cthread_mif_array_ptr2.cpp:83:5
    top_thread_comb_func;
end
function void top_thread_comb_func;
    logic [3:0] a;
    minst_vv[1] = 2;
    a = minst_vv[1];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_comb_ff
    if (rst ) begin
        logic [3:0] minst_vv[2];
        minst_vv[1] = 1;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_reg (test_cthread_mif_array_ptr2.cpp:96:5) 

// Thread-local variables
logic [3:0] minst_vv[2];
logic [3:0] minst_vv_next[2];
logic top_thread_reg_PROC_STATE;
logic top_thread_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : top_thread_reg_comb     // test_cthread_mif_array_ptr2.cpp:96:5
    top_thread_reg_func;
end
function void top_thread_reg_func;
    logic [3:0] a;
    minst_vv_next = minst_vv;
    top_thread_reg_PROC_STATE_next = top_thread_reg_PROC_STATE;
    
    case (top_thread_reg_PROC_STATE)
        0: begin
            minst_vv_next[1] = 2;
            top_thread_reg_PROC_STATE_next = 1; return;    // test_cthread_mif_array_ptr2.cpp:103:13;
        end
        1: begin
            a = minst_vv_next[1];
            minst_vv_next[1] = 2;
            top_thread_reg_PROC_STATE_next = 1; return;    // test_cthread_mif_array_ptr2.cpp:103:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_reg_ff
    if (rst ) begin
        minst_vv[1] <= 1;
        top_thread_reg_PROC_STATE <= 0;    // test_cthread_mif_array_ptr2.cpp:99:9;
    end
    else begin
        minst_vv <= minst_vv_next;
        top_thread_reg_PROC_STATE <= top_thread_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_sig_reg (test_cthread_mif_array_ptr2.cpp:108:5) 

// Thread-local variables
logic [3:0] minst_ss_next[2];
logic top_thread_sig_reg_PROC_STATE;
logic top_thread_sig_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : top_thread_sig_reg_comb     // test_cthread_mif_array_ptr2.cpp:108:5
    top_thread_sig_reg_func;
end
function void top_thread_sig_reg_func;
    logic [3:0] a;
    minst_ss_next = minst_ss;
    top_thread_sig_reg_PROC_STATE_next = top_thread_sig_reg_PROC_STATE;
    
    case (top_thread_sig_reg_PROC_STATE)
        0: begin
            minst_ss_next[1] = 2;
            top_thread_sig_reg_PROC_STATE_next = 1; return;    // test_cthread_mif_array_ptr2.cpp:115:13;
        end
        1: begin
            a = minst_ss[1];
            minst_ss_next[1] = 2;
            top_thread_sig_reg_PROC_STATE_next = 1; return;    // test_cthread_mif_array_ptr2.cpp:115:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_sig_reg_ff
    if (rst ) begin
        minst_ss[1] <= 1;
        top_thread_sig_reg_PROC_STATE <= 0;    // test_cthread_mif_array_ptr2.cpp:111:9;
    end
    else begin
        minst_ss <= minst_ss_next;
        top_thread_sig_reg_PROC_STATE <= top_thread_sig_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_ro (test_cthread_mif_array_ptr2.cpp:121:5) 

// Next-state combinational logic
always_comb begin : top_thread_ro_comb     // test_cthread_mif_array_ptr2.cpp:121:5
    top_thread_ro_func;
end
function void top_thread_ro_func;
    logic [3:0] a;
    a = minst_ss[1];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_ro_ff
    if (rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_fcall (test_cthread_mif_array_ptr2.cpp:131:5) 

// Thread-local variables
logic [3:0] minst_v[2];
logic [3:0] minst_v_next[2];
logic a;
logic a_next;
logic [1:0] top_thread_fcall_PROC_STATE;
logic [1:0] top_thread_fcall_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : top_thread_fcall_comb     // test_cthread_mif_array_ptr2.cpp:131:5
    top_thread_fcall_func;
end
function void top_thread_fcall_func;
    logic b;
    a_next = a;
    minst_v_next = minst_v;
    top_thread_fcall_PROC_STATE_next = top_thread_fcall_PROC_STATE;
    
    case (top_thread_fcall_PROC_STATE)
        0: begin
            // Call f_loc_reg() begin
            a_next = |minst_v_next[1];
            top_thread_fcall_PROC_STATE_next = 1; return;    // test_cthread_mif_array_ptr2.cpp:39:9;
            // Call f_loc_reg() end
        end
        1: begin
            // Call f_loc_reg() begin
            b = a_next;
            // Call f_loc_reg() end
            top_thread_fcall_PROC_STATE_next = 2; return;    // test_cthread_mif_array_ptr2.cpp:137:13;
        end
        2: begin
            // Call f_loc_reg() begin
            a_next = |minst_v_next[1];
            top_thread_fcall_PROC_STATE_next = 1; return;    // test_cthread_mif_array_ptr2.cpp:39:9;
            // Call f_loc_reg() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_fcall_ff
    if (rst ) begin
        top_thread_fcall_PROC_STATE <= 0;    // test_cthread_mif_array_ptr2.cpp:133:9;
    end
    else begin
        minst_v <= minst_v_next;
        a <= a_next;
        top_thread_fcall_PROC_STATE <= top_thread_fcall_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread_fcall_loc (test_cthread_mif_array_ptr2.cpp:141:5) 

// Next-state combinational logic
always_comb begin : top_thread_fcall_loc_comb     // test_cthread_mif_array_ptr2.cpp:141:5
    top_thread_fcall_loc_func;
end
function void top_thread_fcall_loc_func;
    logic a;
    // Call f_loc() begin
    a = |minst_s[1];
    // Call f_loc() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_fcall_loc_ff
    if (rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: top_method (test_cthread_mif_array_ptr2.cpp:151:5) 

// Process-local variables
logic [3:0] minst_vv[2];

always_comb 
begin : top_method     // test_cthread_mif_array_ptr2.cpp:151:5
    minst_vv[1] = 2;
end

endmodule



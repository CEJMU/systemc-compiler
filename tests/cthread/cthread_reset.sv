//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// SystemC signals
logic arstn;
logic a;
logic [2:0] s1;
logic s2[3];
logic [2:0] s3;
logic [2:0] s4;
logic [2:0] s5;
logic arr2[3];

//------------------------------------------------------------------------------
// Clocked THREAD: sct_assert_test (test_cthread_reset.cpp:98:5) 

// Thread-local variables
logic c;
logic c_next;

// Next-state combinational logic
always_comb begin : sct_assert_test_comb     // test_cthread_reset.cpp:98:5
    sct_assert_test_func;
end
function void sct_assert_test_func;
    c_next = c;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : sct_assert_test_ff
    if ( ~arstn ) begin
        c <= 0;
    end
    else begin
        c <= c_next;
    end

`ifndef INTEL_SVA_OFF
    sctAssertLine101 : assert property ( a |=> c_next );
`endif // INTEL_SVA_OFF
end

//------------------------------------------------------------------------------
// Clocked THREAD: var_in_reset_only1 (test_cthread_reset.cpp:110:5) 

// Thread-local variables
logic var_in_reset_only1_PROC_STATE;
logic var_in_reset_only1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : var_in_reset_only1_comb     // test_cthread_reset.cpp:110:5
    var_in_reset_only1_func;
end
function void var_in_reset_only1_func;
    integer kk;
    var_in_reset_only1_PROC_STATE_next = var_in_reset_only1_PROC_STATE;
    
    case (var_in_reset_only1_PROC_STATE)
        0: begin
            var_in_reset_only1_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:120:13;
        end
        1: begin
            if (a)
            begin
                kk = 1;
            end
            var_in_reset_only1_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:120:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : var_in_reset_only1_ff
    if ( ~arstn ) begin
        integer ii;
        logic signed [7:0] jj;
        jj = 1;
        ii = jj + 42;
        var_in_reset_only1_PROC_STATE <= 0;    // test_cthread_reset.cpp:117:9;
    end
    else begin
        var_in_reset_only1_PROC_STATE <= var_in_reset_only1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait1 (test_cthread_reset.cpp:131:5) 

// Next-state combinational logic
always_comb begin : common_wait1_comb     // test_cthread_reset.cpp:131:5
    common_wait1_func;
end
function void common_wait1_func;
    integer kk;
    if (a)
    begin
        kk = 1;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait1_ff
    if ( ~arstn ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait2 (test_cthread_reset.cpp:143:5) 

// Thread-local variables
logic [2:0] y;
logic [2:0] y_next;
logic [2:0] s1_next;

// Next-state combinational logic
always_comb begin : common_wait2_comb     // test_cthread_reset.cpp:143:5
    common_wait2_func;
end
function void common_wait2_func;
    s1_next = s1;
    y_next = y;
    if (a)
    begin
        s1_next = 1;
        y_next++;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait2_ff
    if ( ~arstn ) begin
        logic [2:0] x;
        x = 0;
        y <= 0;
        s1 <= 0;
    end
    else begin
        y <= y_next;
        s1 <= s1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait3 (test_cthread_reset.cpp:160:5) 

// Thread-local variables
logic s2_next[3];
logic [2:0] y0;
logic [2:0] y_next0;
logic common_wait3_PROC_STATE;
logic common_wait3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : common_wait3_comb     // test_cthread_reset.cpp:160:5
    common_wait3_func;
end
function void common_wait3_func;
    s2_next = s2;
    y_next0 = y0;
    common_wait3_PROC_STATE_next = common_wait3_PROC_STATE;
    
    case (common_wait3_PROC_STATE)
        0: begin
            if (a)
            begin
                s2_next[s1] = 1;
                y_next0++;
                common_wait3_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:174:17;
            end
            common_wait3_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:169:13;
        end
        1: begin
            common_wait3_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:169:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait3_ff
    if ( ~arstn ) begin
        logic [2:0] x;
        x = 0;
        y0 <= 0;
        for (integer i = 0; i < 3; i++)
        begin
            s2[i] <= 0;
        end
        common_wait3_PROC_STATE <= 0;    // test_cthread_reset.cpp:169:13;
    end
    else begin
        s2 <= s2_next;
        y0 <= y_next0;
        common_wait3_PROC_STATE <= common_wait3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait4 (test_cthread_reset.cpp:179:5) 

// Thread-local variables
logic [2:0] x;
logic [2:0] x_next;
logic [1:0] common_wait4_PROC_STATE;
logic [1:0] common_wait4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : common_wait4_comb     // test_cthread_reset.cpp:179:5
    common_wait4_func;
end
function void common_wait4_func;
    logic [2:0] y;
    x_next = x;
    common_wait4_PROC_STATE_next = common_wait4_PROC_STATE;
    
    case (common_wait4_PROC_STATE)
        0: begin
            y = x_next + 1;
            x_next = s2[x_next];
            if (!(|s1))
            begin
                common_wait4_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:190:32;
            end
            x_next++;
            common_wait4_PROC_STATE_next = 2; return;    // test_cthread_reset.cpp:193:13;
        end
        1: begin
            if (!(|s1))
            begin
                common_wait4_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:190:32;
            end
            x_next++;
            common_wait4_PROC_STATE_next = 2; return;    // test_cthread_reset.cpp:193:13;
        end
        2: begin
            common_wait4_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:186:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait4_ff
    if ( ~arstn ) begin
        logic [2:0] y;
        x <= 0;
        y = 0;
        x <= 1;
        common_wait4_PROC_STATE <= 0;    // test_cthread_reset.cpp:186:13;
    end
    else begin
        x <= x_next;
        common_wait4_PROC_STATE <= common_wait4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: common_wait5 (test_cthread_reset.cpp:199:5) 

// Thread-local variables
logic [2:0] x0;
logic [2:0] x_next0;
logic [2:0] s3_next;
logic common_wait5_PROC_STATE;
logic common_wait5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : common_wait5_comb     // test_cthread_reset.cpp:199:5
    common_wait5_func;
end
function void common_wait5_func;
    s3_next = s3;
    x_next0 = x0;
    common_wait5_PROC_STATE_next = common_wait5_PROC_STATE;
    
    case (common_wait5_PROC_STATE)
        0: begin
            if (!(|s1))
            begin
                common_wait5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:206:32;
            end
            x_next0 = x_next0 + s1;
            common_wait5_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:208:13;
        end
        1: begin
            s3_next = x_next0;
            if (!(|s1))
            begin
                common_wait5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:206:32;
            end
            x_next0 = x_next0 + s1;
            common_wait5_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:208:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : common_wait5_ff
    if ( ~arstn ) begin
        x0 <= 0;
        x0 <= 1;
        s3 <= 0;
        if (!(|s1))
        begin
            common_wait5_PROC_STATE <= 0;    // test_cthread_reset.cpp:206:32;
        end
        x0 <= x0 + s1;
        common_wait5_PROC_STATE <= 1;    // test_cthread_reset.cpp:208:13;
    end
    else begin
        x0 <= x_next0;
        s3 <= s3_next;
        common_wait5_PROC_STATE <= common_wait5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset1 (test_cthread_reset.cpp:218:5) 

// Next-state combinational logic
always_comb begin : no_reset1_comb     // test_cthread_reset.cpp:218:5
    no_reset1_func;
end
function void no_reset1_func;
    integer jj;
    integer kk;
    jj = 42;
    if (a)
    begin
        kk = 43;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset1_ff
    if ( ~arstn ) begin
        integer jj;
        integer kk;
        jj = 42;
        if (a)
        begin
            kk = 43;
        end
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset10 (test_cthread_reset.cpp:218:5) 

// Thread-local variables
logic no_reset1_PROC_STATE;
logic no_reset1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset10_comb     // test_cthread_reset.cpp:218:5
    no_reset10_func;
end
function void no_reset10_func;
    integer jj;
    integer kk;
    no_reset1_PROC_STATE_next = no_reset1_PROC_STATE;
    
    case (no_reset1_PROC_STATE)
        default : begin
            jj = 42;
            if (a)
            begin
                kk = 43;
            end
            no_reset1_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:225:13;
        end
        0: begin
            jj = 42;
            if (a)
            begin
                kk = 43;
            end
            no_reset1_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:225:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk) 
begin : no_reset10_ff
    begin
        no_reset1_PROC_STATE <= no_reset1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset2 (test_cthread_reset.cpp:230:5) 

// Thread-local variables
logic signed [31:0] ll;
logic signed [31:0] ll_next;

// Next-state combinational logic
always_comb begin : no_reset2_comb     // test_cthread_reset.cpp:230:5
    no_reset2_func;
end
function void no_reset2_func;
    ll_next = ll;
    ll_next++;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset2_ff
    if ( ~arstn ) begin
        ll <= 0;
        ll++;
    end
    else begin
        ll <= ll_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset3 (test_cthread_reset.cpp:240:5) 

// Thread-local variables
logic [2:0] v;
logic [2:0] v_next;
logic no_reset3_PROC_STATE;
logic no_reset3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset3_comb     // test_cthread_reset.cpp:240:5
    no_reset3_func;
end
function void no_reset3_func;
    v_next = v;
    no_reset3_PROC_STATE_next = no_reset3_PROC_STATE;
    
    case (no_reset3_PROC_STATE)
        0: begin
            v_next++;
            no_reset3_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:247:13;
        end
        1: begin
            v_next = s3;
            no_reset3_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:244:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset3_ff
    if ( ~arstn ) begin
        v <= s3;
        no_reset3_PROC_STATE <= 0;    // test_cthread_reset.cpp:244:13;
    end
    else begin
        v <= v_next;
        no_reset3_PROC_STATE <= no_reset3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset4 (test_cthread_reset.cpp:256:5) 

// Thread-local variables
logic [2:0] s4_next;
logic signed [31:0] w;
logic signed [31:0] w_next;
logic no_reset4_PROC_STATE;
logic no_reset4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset4_comb     // test_cthread_reset.cpp:256:5
    no_reset4_func;
end
function void no_reset4_func;
    integer TMP_0;
    integer val;
    logic [2:0] z;
    integer TMP_2;
    s4_next = s4;
    w_next = w;
    no_reset4_PROC_STATE_next = no_reset4_PROC_STATE;
    
    case (no_reset4_PROC_STATE)
        0: begin
            z = w_next + 1;
            s4_next = z;
            no_reset4_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:265:13;
        end
        1: begin
            s4_next = 0;
            val = s3;
            // Call g() begin
            TMP_2 = val + 1;
            // Call g() end
            w_next = TMP_2;
            no_reset4_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:261:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset4_ff
    if ( ~arstn ) begin
        integer TMP_0;
        integer val;
        s4 <= 0;
        val = s3;
        // Call g() begin
        TMP_0 = val + 1;
        // Call g() end
        w <= TMP_0;
        no_reset4_PROC_STATE <= 0;    // test_cthread_reset.cpp:261:13;
    end
    else begin
        s4 <= s4_next;
        w <= w_next;
        no_reset4_PROC_STATE <= no_reset4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: no_reset5 (test_cthread_reset.cpp:270:5) 

// Thread-local variables
logic [2:0] s5_next;
logic [2:0] z;
logic [2:0] z_next;
logic no_reset5_PROC_STATE;
logic no_reset5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : no_reset5_comb     // test_cthread_reset.cpp:270:5
    no_reset5_func;
end
function void no_reset5_func;
    s5_next = s5;
    z_next = z;
    no_reset5_PROC_STATE_next = no_reset5_PROC_STATE;
    
    case (no_reset5_PROC_STATE)
        0: begin
            if (!(|s1))
            begin
                no_reset5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:276:32;
            end
            s5_next = z_next;
            no_reset5_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:279:13;
        end
        1: begin
            s5_next = s1 + 1;
            z_next = s3;
            if (!(|s1))
            begin
                no_reset5_PROC_STATE_next = 0; return;    // test_cthread_reset.cpp:276:32;
            end
            s5_next = z_next;
            no_reset5_PROC_STATE_next = 1; return;    // test_cthread_reset.cpp:279:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : no_reset5_ff
    if ( ~arstn ) begin
        s5 <= s1 + 1;
        z <= s3;
        if (!(|s1))
        begin
            no_reset5_PROC_STATE <= 0;    // test_cthread_reset.cpp:276:32;
        end
        s5 <= z;
        no_reset5_PROC_STATE <= 1;    // test_cthread_reset.cpp:279:13;
    end
    else begin
        s5 <= s5_next;
        z <= z_next;
        no_reset5_PROC_STATE <= no_reset5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: var_fcall_in_reset_only (test_cthread_reset.cpp:292:5) 

// Next-state combinational logic
always_comb begin : var_fcall_in_reset_only_comb     // test_cthread_reset.cpp:292:5
    var_fcall_in_reset_only_func;
end
function void var_fcall_in_reset_only_func;
    integer TMP_0;
    logic A;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : var_fcall_in_reset_only_ff
    if ( ~arstn ) begin
        integer TMP_0;
        logic A;
        logic b;
        integer i;
        // Call f() begin
        A = a;
        b = a;
        TMP_0 = A ^ b;
        // Call f() end
        i = TMP_0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: comb_init_in_reset (test_cthread_reset.cpp:306:5) 

// Next-state combinational logic
always_comb begin : comb_init_in_reset_comb     // test_cthread_reset.cpp:306:5
    comb_init_in_reset_func;
end
function void comb_init_in_reset_func;
    logic [3:0] i;
    integer j;
    integer k;
    i = 1;
    j = 1;
    k = 1;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : comb_init_in_reset_ff
    if ( ~arstn ) begin
        logic [3:0] i;
        integer k;
        i = 0;
        k = 1;
        a <= |k;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: not_used (test_cthread_reset.cpp:324:5) 

// Next-state combinational logic
always_comb begin : not_used_comb     // test_cthread_reset.cpp:324:5
    not_used_func;
end
function void not_used_func;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : not_used_ff
    if ( ~arstn ) begin
        logic [3:0] kk;
        kk = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: comb_assign_in_reset (test_cthread_reset.cpp:335:5) 

// Next-state combinational logic
always_comb begin : comb_assign_in_reset_comb     // test_cthread_reset.cpp:335:5
    comb_assign_in_reset_func;
end
function void comb_assign_in_reset_func;
    integer i;
    integer j;
    integer k;
    integer l;
    logic [1:0] x;
    i = 1;
    j = 1;
    k = 1;
    l = 1;
    x = 1;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : comb_assign_in_reset_ff
    if ( ~arstn ) begin
        integer j;
        integer k;
        integer l;
        logic [1:0] x;
        j = 1;
        k = 2;
        a <= |k;
        l = 0;
        l = l - 1;
        x = 0;
        x = x + 1;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: reg_init_in_reset (test_cthread_reset.cpp:360:5) 

// Thread-local variables
logic a_next1;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] k;
logic signed [31:0] k_next;

// Next-state combinational logic
always_comb begin : reg_init_in_reset_comb     // test_cthread_reset.cpp:360:5
    reg_init_in_reset_func;
end
function void reg_init_in_reset_func;
    a_next1 = a;
    i_next = i;
    j_next = j;
    k_next = k;
    a_next1 = |i_next;
    a_next1 = |j_next;
    a_next1 = |k_next;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : reg_init_in_reset_ff
    if ( ~arstn ) begin
        j <= 1;
        k <= 2;
        a <= |k;
    end
    else begin
        a <= a_next1;
        i <= i_next;
        j <= j_next;
        k <= k_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: reg_assign_in_reset (test_cthread_reset.cpp:379:5) 

// Thread-local variables
logic a_next2;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic signed [31:0] l;
logic signed [31:0] l_next;
logic [1:0] x1;
logic [1:0] x_next1;
logic signed [31:0] arr0[3];
logic signed [31:0] arr0_next[3];

// Next-state combinational logic
always_comb begin : reg_assign_in_reset_comb     // test_cthread_reset.cpp:379:5
    reg_assign_in_reset_func;
end
function void reg_assign_in_reset_func;
    a_next2 = a;
    arr0_next = arr0;
    i_next0 = i0;
    j_next0 = j0;
    k_next0 = k0;
    l_next = l;
    x_next1 = x1;
    a_next2 = |i_next0;
    a_next2 = |j_next0;
    a_next2 = |k_next0;
    a_next2 = |l_next;
    a_next2 = |x_next1;
    a_next2 = |arr0_next[1];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : reg_assign_in_reset_ff
    if ( ~arstn ) begin
        j0 <= 1;
        k0 <= 2;
        a <= |k0;
        l <= 0;
        l <= l - 1;
        x1 <= 0;
        x1 <= x1 + 1;
        arr0[1] <= 0;
        arr0[1] <= arr0[1] + 1;
    end
    else begin
        a <= a_next2;
        i0 <= i_next0;
        j0 <= j_next0;
        k0 <= k_next0;
        l <= l_next;
        x1 <= x_next1;
        arr0 <= arr0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: read_only_in_reset (test_cthread_reset.cpp:408:5) 

// Thread-local variables
logic signed [31:0] aa;

// Next-state combinational logic
always_comb begin : read_only_in_reset_comb     // test_cthread_reset.cpp:408:5
    read_only_in_reset_func;
end
function void read_only_in_reset_func;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : read_only_in_reset_ff
    if ( ~arstn ) begin
        integer jj;
        integer aaa;
        integer aa;
        aa = 1;
        jj = 0;
        aaa = jj + aa;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: write_only_in_reset (test_cthread_reset.cpp:422:5) 

// Next-state combinational logic
always_comb begin : write_only_in_reset_comb     // test_cthread_reset.cpp:422:5
    write_only_in_reset_func;
end
function void write_only_in_reset_func;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : write_only_in_reset_ff
    if ( ~arstn ) begin
        integer i;
        integer j;
        i = 0;
        j = 1;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: array_init_in_reset (test_cthread_reset.cpp:440:5) 

// Thread-local variables
logic arr2_next[3];
logic signed [31:0] arr3[2];
logic signed [31:0] arr3_next[2];
logic a_next3;
logic signed [1:0] arr1[3];

// Next-state combinational logic
always_comb begin : array_init_in_reset_comb     // test_cthread_reset.cpp:440:5
    array_init_in_reset_func;
end
function void array_init_in_reset_func;
    a_next3 = a;
    arr2_next = arr2;
    arr3_next = arr3;
    arr1[0] = 1;
    arr1[1] = 2;
    a_next3 = |arr1[0];
    a_next3 = arr2[1];
    a_next3 = |arr3_next[0];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : array_init_in_reset_ff
    if ( ~arstn ) begin
        logic signed [1:0] arr1[3];
        arr1[0] = 1;
        arr2[1] <= 1;
        arr3[0] <= 1; arr3[1] <= 2;
    end
    else begin
        arr2 <= arr2_next;
        arr3 <= arr3_next;
        a <= a_next3;
    end
end

endmodule



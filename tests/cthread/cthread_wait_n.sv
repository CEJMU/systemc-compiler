//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test_mod ()
//
module test_mod // "tmod"
(
);

// SystemC signals
logic clk;
logic rstn;
logic a;
logic [2:0] cntr_name_conflict_WAIT_N_COUNTER_next;

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_reset_decl (test_cthread_wait_n.cpp:80:5) 

// Thread-local variables
logic [1:0] wait_n_reset_decl_WAIT_N_COUNTER;
logic [1:0] wait_n_reset_decl_WAIT_N_COUNTER_next;
logic wait_n_reset_decl_PROC_STATE;
logic wait_n_reset_decl_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_reset_decl_comb     // test_cthread_wait_n.cpp:80:5
    wait_n_reset_decl_func;
end
function void wait_n_reset_decl_func;
    wait_n_reset_decl_WAIT_N_COUNTER_next = wait_n_reset_decl_WAIT_N_COUNTER;
    wait_n_reset_decl_PROC_STATE_next = wait_n_reset_decl_PROC_STATE;
    
    case (wait_n_reset_decl_PROC_STATE)
        0: begin
            wait_n_reset_decl_WAIT_N_COUNTER_next = 2;
            wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:87:13;
        end
        1: begin
            if (wait_n_reset_decl_WAIT_N_COUNTER != 1) begin
                wait_n_reset_decl_WAIT_N_COUNTER_next = wait_n_reset_decl_WAIT_N_COUNTER - 1;
                wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:87:13;
            end;
            wait_n_reset_decl_WAIT_N_COUNTER_next = 2;
            wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:87:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_reset_decl_ff
    if ( ~rstn ) begin
        integer unsigned k;
        integer unsigned i;
        k = 1;
        i = k + 1;
        wait_n_reset_decl_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:84:9;
        wait_n_reset_decl_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_reset_decl_WAIT_N_COUNTER <= wait_n_reset_decl_WAIT_N_COUNTER_next;
        wait_n_reset_decl_PROC_STATE <= wait_n_reset_decl_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: one_wait_n (test_cthread_wait_n.cpp:91:5) 

// Thread-local variables
logic [1:0] one_wait_n_WAIT_N_COUNTER;
logic [1:0] one_wait_n_WAIT_N_COUNTER_next;
logic [1:0] i;
logic [1:0] i_next;
logic [1:0] one_wait_n_PROC_STATE;
logic [1:0] one_wait_n_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : one_wait_n_comb     // test_cthread_wait_n.cpp:91:5
    one_wait_n_func;
end
function void one_wait_n_func;
    i_next = i;
    one_wait_n_WAIT_N_COUNTER_next = one_wait_n_WAIT_N_COUNTER;
    one_wait_n_PROC_STATE_next = one_wait_n_PROC_STATE;
    
    case (one_wait_n_PROC_STATE)
        0: begin
            one_wait_n_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:95:13;
        end
        1: begin
            i_next++;
            one_wait_n_WAIT_N_COUNTER_next = 2;
            one_wait_n_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:97:13;
        end
        2: begin
            if (one_wait_n_WAIT_N_COUNTER != 1) begin
                one_wait_n_WAIT_N_COUNTER_next = one_wait_n_WAIT_N_COUNTER - 1;
                one_wait_n_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:97:13;
            end;
            one_wait_n_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:95:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : one_wait_n_ff
    if ( ~rstn ) begin
        i <= 0;
        one_wait_n_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:93:9;
        one_wait_n_WAIT_N_COUNTER <= 0;
    end
    else begin
        one_wait_n_WAIT_N_COUNTER <= one_wait_n_WAIT_N_COUNTER_next;
        i <= i_next;
        one_wait_n_PROC_STATE <= one_wait_n_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread0 (test_cthread_wait_n.cpp:101:5) 

// Thread-local variables
logic [1:0] thread0_WAIT_N_COUNTER;
logic [1:0] thread0_WAIT_N_COUNTER_next;
logic [1:0] thread0_PROC_STATE;
logic [1:0] thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread0_comb     // test_cthread_wait_n.cpp:101:5
    thread0_func;
end
function void thread0_func;
    thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER;
    thread0_PROC_STATE_next = thread0_PROC_STATE;
    
    case (thread0_PROC_STATE)
        0: begin
            thread0_WAIT_N_COUNTER_next = 1;
            thread0_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:104:13;
        end
        1: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:104:13;
            end;
            thread0_WAIT_N_COUNTER_next = 2;
            thread0_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:105:13;
        end
        2: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:105:13;
            end;
            thread0_WAIT_N_COUNTER_next = 3;
            thread0_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:106:13;
        end
        3: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:106:13;
            end;
            thread0_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:103:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread0_ff
    if ( ~rstn ) begin
        thread0_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:103:13;
        thread0_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread0_WAIT_N_COUNTER <= thread0_WAIT_N_COUNTER_next;
        thread0_PROC_STATE <= thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1 (test_cthread_wait_n.cpp:112:5) 

// Thread-local variables
logic [1:0] thread1_WAIT_N_COUNTER;
logic [1:0] thread1_WAIT_N_COUNTER_next;
logic thread1_PROC_STATE;
logic thread1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1_comb     // test_cthread_wait_n.cpp:112:5
    thread1_func;
end
function void thread1_func;
    thread1_WAIT_N_COUNTER_next = thread1_WAIT_N_COUNTER;
    thread1_PROC_STATE_next = thread1_PROC_STATE;
    
    case (thread1_PROC_STATE)
        0: begin
            if (thread1_WAIT_N_COUNTER != 1) begin
                thread1_WAIT_N_COUNTER_next = thread1_WAIT_N_COUNTER - 1;
                thread1_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:114:13;
            end;
            thread1_WAIT_N_COUNTER_next = 3;
            thread1_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:114:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1_ff
    if ( ~rstn ) begin
        thread1_WAIT_N_COUNTER <= 3;
        thread1_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:114:13;
        thread1_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1_WAIT_N_COUNTER <= thread1_WAIT_N_COUNTER_next;
        thread1_PROC_STATE <= thread1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1a (test_cthread_wait_n.cpp:118:5) 

// Thread-local variables
logic [1:0] thread1a_WAIT_N_COUNTER;
logic [1:0] thread1a_WAIT_N_COUNTER_next;
logic thread1a_PROC_STATE;
logic thread1a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1a_comb     // test_cthread_wait_n.cpp:118:5
    thread1a_func;
end
function void thread1a_func;
    thread1a_WAIT_N_COUNTER_next = thread1a_WAIT_N_COUNTER;
    thread1a_PROC_STATE_next = thread1a_PROC_STATE;
    
    case (thread1a_PROC_STATE)
        0: begin
            thread1a_WAIT_N_COUNTER_next = 3;
            thread1a_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:121:13;
        end
        1: begin
            if (thread1a_WAIT_N_COUNTER != 1) begin
                thread1a_WAIT_N_COUNTER_next = thread1a_WAIT_N_COUNTER - 1;
                thread1a_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:121:13;
            end;
            thread1a_WAIT_N_COUNTER_next = 3;
            thread1a_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:121:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1a_ff
    if ( ~rstn ) begin
        thread1a_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:119:9;
        thread1a_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1a_WAIT_N_COUNTER <= thread1a_WAIT_N_COUNTER_next;
        thread1a_PROC_STATE <= thread1a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1b (test_cthread_wait_n.cpp:125:5) 

// Thread-local variables
logic [1:0] thread1b_WAIT_N_COUNTER;
logic [1:0] thread1b_WAIT_N_COUNTER_next;
logic thread1b_PROC_STATE;
logic thread1b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1b_comb     // test_cthread_wait_n.cpp:125:5
    thread1b_func;
end
function void thread1b_func;
    integer i;
    thread1b_WAIT_N_COUNTER_next = thread1b_WAIT_N_COUNTER;
    thread1b_PROC_STATE_next = thread1b_PROC_STATE;
    
    case (thread1b_PROC_STATE)
        0: begin
            i = 0;
            thread1b_WAIT_N_COUNTER_next = 3;
            thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:129:13;
        end
        1: begin
            if (thread1b_WAIT_N_COUNTER != 1) begin
                thread1b_WAIT_N_COUNTER_next = thread1b_WAIT_N_COUNTER - 1;
                thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:129:13;
            end;
            i = 0;
            thread1b_WAIT_N_COUNTER_next = 3;
            thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:129:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1b_ff
    if ( ~rstn ) begin
        thread1b_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:126:9;
        thread1b_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1b_WAIT_N_COUNTER <= thread1b_WAIT_N_COUNTER_next;
        thread1b_PROC_STATE <= thread1b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1c (test_cthread_wait_n.cpp:133:5) 

// Thread-local variables
logic [1:0] thread1c_WAIT_N_COUNTER;
logic [1:0] thread1c_WAIT_N_COUNTER_next;
logic thread1c_PROC_STATE;
logic thread1c_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1c_comb     // test_cthread_wait_n.cpp:133:5
    thread1c_func;
end
function void thread1c_func;
    integer i;
    thread1c_WAIT_N_COUNTER_next = thread1c_WAIT_N_COUNTER;
    thread1c_PROC_STATE_next = thread1c_PROC_STATE;
    
    case (thread1c_PROC_STATE)
        0: begin
            thread1c_WAIT_N_COUNTER_next = 3;
            thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:136:13;
        end
        1: begin
            if (thread1c_WAIT_N_COUNTER != 1) begin
                thread1c_WAIT_N_COUNTER_next = thread1c_WAIT_N_COUNTER - 1;
                thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:136:13;
            end;
            i = 0;
            thread1c_WAIT_N_COUNTER_next = 3;
            thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:136:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1c_ff
    if ( ~rstn ) begin
        thread1c_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:134:9;
        thread1c_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1c_WAIT_N_COUNTER <= thread1c_WAIT_N_COUNTER_next;
        thread1c_PROC_STATE <= thread1c_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1d (test_cthread_wait_n.cpp:141:5) 

// Thread-local variables
logic [1:0] thread1d_WAIT_N_COUNTER;
logic [1:0] thread1d_WAIT_N_COUNTER_next;
logic thread1d_PROC_STATE;
logic thread1d_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1d_comb     // test_cthread_wait_n.cpp:141:5
    thread1d_func;
end
function void thread1d_func;
    thread1d_WAIT_N_COUNTER_next = thread1d_WAIT_N_COUNTER;
    thread1d_PROC_STATE_next = thread1d_PROC_STATE;
    
    case (thread1d_PROC_STATE)
        0: begin
            thread1d_WAIT_N_COUNTER_next = 3;
            thread1d_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:145:13;
        end
        1: begin
            if (thread1d_WAIT_N_COUNTER != 1) begin
                thread1d_WAIT_N_COUNTER_next = thread1d_WAIT_N_COUNTER - 1;
                thread1d_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:145:13;
            end;
            thread1d_WAIT_N_COUNTER_next = 3;
            thread1d_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:145:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1d_ff
    if ( ~rstn ) begin
        integer i;
        i = 1;
        thread1d_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:143:9;
        thread1d_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1d_WAIT_N_COUNTER <= thread1d_WAIT_N_COUNTER_next;
        thread1d_PROC_STATE <= thread1d_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread2 (test_cthread_wait_n.cpp:149:5) 

// Thread-local variables
logic [2:0] thread2_WAIT_N_COUNTER;
logic [2:0] thread2_WAIT_N_COUNTER_next;
logic thread2_PROC_STATE;
logic thread2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread2_comb     // test_cthread_wait_n.cpp:149:5
    thread2_func;
end
function void thread2_func;
    thread2_WAIT_N_COUNTER_next = thread2_WAIT_N_COUNTER;
    thread2_PROC_STATE_next = thread2_PROC_STATE;
    
    case (thread2_PROC_STATE)
        0: begin
            if (thread2_WAIT_N_COUNTER != 1) begin
                thread2_WAIT_N_COUNTER_next = thread2_WAIT_N_COUNTER - 1;
                thread2_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:151:13;
            end;
            thread2_WAIT_N_COUNTER_next = 1 + 1 + 1;
            thread2_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:152:13;
        end
        1: begin
            if (thread2_WAIT_N_COUNTER != 1) begin
                thread2_WAIT_N_COUNTER_next = thread2_WAIT_N_COUNTER - 1;
                thread2_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:152:13;
            end;
            thread2_WAIT_N_COUNTER_next = 2 * 2;
            thread2_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:151:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread2_ff
    if ( ~rstn ) begin
        thread2_WAIT_N_COUNTER <= 2 * 2;
        thread2_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:151:13;
        thread2_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread2_WAIT_N_COUNTER <= thread2_WAIT_N_COUNTER_next;
        thread2_PROC_STATE <= thread2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread3 (test_cthread_wait_n.cpp:156:5) 

// Thread-local variables
logic [1:0] thread3_WAIT_N_COUNTER;
logic [1:0] thread3_WAIT_N_COUNTER_next;
logic signed [31:0] n;
logic signed [31:0] n_next;
logic [1:0] thread3_PROC_STATE;
logic [1:0] thread3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread3_comb     // test_cthread_wait_n.cpp:156:5
    thread3_func;
end
function void thread3_func;
    n_next = n;
    thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER;
    thread3_PROC_STATE_next = thread3_PROC_STATE;
    
    case (thread3_PROC_STATE)
        0: begin
            n_next = 2;
            thread3_WAIT_N_COUNTER_next = n_next;
            thread3_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:163:13;
        end
        1: begin
            if (thread3_WAIT_N_COUNTER != 1) begin
                thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER - 1;
                thread3_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:163:13;
            end;
            thread3_WAIT_N_COUNTER_next = n_next + 1;
            thread3_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:164:13;
        end
        2: begin
            if (thread3_WAIT_N_COUNTER != 1) begin
                thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER - 1;
                thread3_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:164:13;
            end;
            thread3_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:161:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread3_ff
    if ( ~rstn ) begin
        thread3_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:161:13;
        thread3_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread3_WAIT_N_COUNTER <= thread3_WAIT_N_COUNTER_next;
        n <= n_next;
        thread3_PROC_STATE <= thread3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread4_no_waitn (test_cthread_wait_n.cpp:168:5) 

// Thread-local variables
logic [63:0] i0;
logic [63:0] i_next0;
logic thread4_no_waitn_PROC_STATE;
logic thread4_no_waitn_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread4_no_waitn_comb     // test_cthread_wait_n.cpp:168:5
    thread4_no_waitn_func;
end
function void thread4_no_waitn_func;
    i_next0 = i0;
    thread4_no_waitn_PROC_STATE_next = thread4_no_waitn_PROC_STATE;
    
    case (thread4_no_waitn_PROC_STATE)
        0: begin
            i_next0 = 0;
            thread4_no_waitn_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:172:17;
        end
        1: begin
            ++i_next0;
            if (i_next0 < 3)
            begin
                thread4_no_waitn_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:172:17;
            end
            thread4_no_waitn_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:170:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread4_no_waitn_ff
    if ( ~rstn ) begin
        thread4_no_waitn_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:170:13;
    end
    else begin
        i0 <= i_next0;
        thread4_no_waitn_PROC_STATE <= thread4_no_waitn_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_const (test_cthread_wait_n.cpp:177:5) 

// Thread-local variables
logic [1:0] wait_n_const_WAIT_N_COUNTER;
logic [1:0] wait_n_const_WAIT_N_COUNTER_next;
logic wait_n_const_PROC_STATE;
logic wait_n_const_PROC_STATE_next;

// Thread-local constants

// Next-state combinational logic
always_comb begin : wait_n_const_comb     // test_cthread_wait_n.cpp:177:5
    wait_n_const_func;
end
function void wait_n_const_func;
    wait_n_const_WAIT_N_COUNTER_next = wait_n_const_WAIT_N_COUNTER;
    wait_n_const_PROC_STATE_next = wait_n_const_PROC_STATE;
    
    case (wait_n_const_PROC_STATE)
        0: begin
            wait_n_const_WAIT_N_COUNTER_next = 2;
            wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:182:13;
        end
        1: begin
            if (wait_n_const_WAIT_N_COUNTER != 1) begin
                wait_n_const_WAIT_N_COUNTER_next = wait_n_const_WAIT_N_COUNTER - 1;
                wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:182:13;
            end;
            wait_n_const_WAIT_N_COUNTER_next = 2;
            wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:182:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_const_ff
    if ( ~rstn ) begin
        wait_n_const_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:179:9;
        wait_n_const_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_const_WAIT_N_COUNTER <= wait_n_const_WAIT_N_COUNTER_next;
        wait_n_const_PROC_STATE <= wait_n_const_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_var (test_cthread_wait_n.cpp:186:5) 

// Thread-local variables
logic [1:0] wait_n_var_WAIT_N_COUNTER;
logic [1:0] wait_n_var_WAIT_N_COUNTER_next;
logic wait_n_var_PROC_STATE;
logic wait_n_var_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_var_comb     // test_cthread_wait_n.cpp:186:5
    wait_n_var_func;
end
function void wait_n_var_func;
    integer unsigned n;
    wait_n_var_WAIT_N_COUNTER_next = wait_n_var_WAIT_N_COUNTER;
    wait_n_var_PROC_STATE_next = wait_n_var_PROC_STATE;
    
    case (wait_n_var_PROC_STATE)
        0: begin
            n = 2;
            wait_n_var_WAIT_N_COUNTER_next = n;
            wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:192:13;
        end
        1: begin
            if (wait_n_var_WAIT_N_COUNTER != 1) begin
                wait_n_var_WAIT_N_COUNTER_next = wait_n_var_WAIT_N_COUNTER - 1;
                wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:192:13;
            end;
            n = 2;
            wait_n_var_WAIT_N_COUNTER_next = n;
            wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:192:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_var_ff
    if ( ~rstn ) begin
        integer unsigned n;
        n = 0;
        wait_n_var_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:188:9;
        wait_n_var_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_var_WAIT_N_COUNTER <= wait_n_var_WAIT_N_COUNTER_next;
        wait_n_var_PROC_STATE <= wait_n_var_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc (test_cthread_wait_n.cpp:196:5) 

// Thread-local variables
logic [2:0] wait_n_calc_WAIT_N_COUNTER;
logic [2:0] wait_n_calc_WAIT_N_COUNTER_next;
logic [31:0] n1;
logic [31:0] n_next0;
logic [1:0] wait_n_calc_PROC_STATE;
logic [1:0] wait_n_calc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_comb     // test_cthread_wait_n.cpp:196:5
    wait_n_calc_func;
end
function void wait_n_calc_func;
    integer unsigned m;
    n_next0 = n1;
    wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER;
    wait_n_calc_PROC_STATE_next = wait_n_calc_PROC_STATE;
    
    case (wait_n_calc_PROC_STATE)
        0: begin
            n_next0 = 2;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 - 1;
            wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:203:13;
        end
        1: begin
            if (wait_n_calc_WAIT_N_COUNTER != 1) begin
                wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER - 1;
                wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:203:13;
            end;
            n_next0++;
            m = 1;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 + m;
            wait_n_calc_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:206:13;
        end
        2: begin
            if (wait_n_calc_WAIT_N_COUNTER != 1) begin
                wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER - 1;
                wait_n_calc_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:206:13;
            end;
            n_next0 = 2;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 - 1;
            wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:203:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_ff
    if ( ~rstn ) begin
        wait_n_calc_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:199:9;
        wait_n_calc_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_calc_WAIT_N_COUNTER <= wait_n_calc_WAIT_N_COUNTER_next;
        n1 <= n_next0;
        wait_n_calc_PROC_STATE <= wait_n_calc_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc_if (test_cthread_wait_n.cpp:211:5) 

// Thread-local variables
logic [1:0] wait_n_calc_if_WAIT_N_COUNTER;
logic [1:0] wait_n_calc_if_WAIT_N_COUNTER_next;
logic [1:0] wait_n_calc_if_PROC_STATE;
logic [1:0] wait_n_calc_if_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_if_comb     // test_cthread_wait_n.cpp:211:5
    wait_n_calc_if_func;
end
function void wait_n_calc_if_func;
    integer unsigned n;
    wait_n_calc_if_WAIT_N_COUNTER_next = wait_n_calc_if_WAIT_N_COUNTER;
    wait_n_calc_if_PROC_STATE_next = wait_n_calc_if_PROC_STATE;
    
    case (wait_n_calc_if_PROC_STATE)
        0: begin
            n = 2;
            if (a)
            begin
                wait_n_calc_if_WAIT_N_COUNTER_next = n++;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:218:27;
            end
            wait_n_calc_if_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:220:13;
        end
        1: begin
            if (wait_n_calc_if_WAIT_N_COUNTER != 1) begin
                wait_n_calc_if_WAIT_N_COUNTER_next = wait_n_calc_if_WAIT_N_COUNTER - 1;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:218:27;
            end;
            wait_n_calc_if_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:220:13;
        end
        2: begin
            n = 2;
            if (a)
            begin
                wait_n_calc_if_WAIT_N_COUNTER_next = n++;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:218:27;
            end
            wait_n_calc_if_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:220:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_if_ff
    if ( ~rstn ) begin
        wait_n_calc_if_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:214:9;
        wait_n_calc_if_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_calc_if_WAIT_N_COUNTER <= wait_n_calc_if_WAIT_N_COUNTER_next;
        wait_n_calc_if_PROC_STATE <= wait_n_calc_if_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc_for (test_cthread_wait_n.cpp:225:5) 

// Thread-local variables
logic [1:0] wait_n_calc_for_WAIT_N_COUNTER;
logic [1:0] wait_n_calc_for_WAIT_N_COUNTER_next;
logic [31:0] n2;
logic [31:0] n_next1;
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic wait_n_calc_for_PROC_STATE;
logic wait_n_calc_for_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_for_comb     // test_cthread_wait_n.cpp:225:5
    wait_n_calc_for_func;
end
function void wait_n_calc_for_func;
    i_next1 = i1;
    n_next1 = n2;
    wait_n_calc_for_WAIT_N_COUNTER_next = wait_n_calc_for_WAIT_N_COUNTER;
    wait_n_calc_for_PROC_STATE_next = wait_n_calc_for_PROC_STATE;
    
    case (wait_n_calc_for_PROC_STATE)
        0: begin
            i_next1 = 0;
            wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
            wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:17;
        end
        1: begin
            if (wait_n_calc_for_WAIT_N_COUNTER != 1) begin
                wait_n_calc_for_WAIT_N_COUNTER_next = wait_n_calc_for_WAIT_N_COUNTER - 1;
                wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:17;
            end;
            i_next1++;
            if (i_next1 < 2)
            begin
                wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
                wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:17;
            end
            i_next1 = 0;
            wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
            wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_for_ff
    if ( ~rstn ) begin
        n2 <= 3;
        wait_n_calc_for_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:228:9;
        wait_n_calc_for_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_calc_for_WAIT_N_COUNTER <= wait_n_calc_for_WAIT_N_COUNTER_next;
        n2 <= n_next1;
        i1 <= i_next1;
        wait_n_calc_for_PROC_STATE <= wait_n_calc_for_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: three_wait (test_cthread_wait_n.cpp:237:5) 

// Thread-local variables
logic [1:0] three_wait_PROC_STATE;
logic [1:0] three_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : three_wait_comb     // test_cthread_wait_n.cpp:237:5
    three_wait_func;
end
function void three_wait_func;
    three_wait_PROC_STATE_next = three_wait_PROC_STATE;
    
    case (three_wait_PROC_STATE)
        0: begin
            three_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:242:13;
        end
        1: begin
            three_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:243:13;
        end
        2: begin
            three_wait_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:244:13;
        end
        3: begin
            three_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:242:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : three_wait_ff
    if ( ~rstn ) begin
        three_wait_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:239:9;
    end
    else begin
        three_wait_PROC_STATE <= three_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: four_wait (test_cthread_wait_n.cpp:249:5) 

// Thread-local variables
logic [2:0] four_wait_PROC_STATE;
logic [2:0] four_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : four_wait_comb     // test_cthread_wait_n.cpp:249:5
    four_wait_func;
end
function void four_wait_func;
    four_wait_PROC_STATE_next = four_wait_PROC_STATE;
    
    case (four_wait_PROC_STATE)
        0: begin
            four_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:254:13;
        end
        1: begin
            four_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:255:13;
        end
        2: begin
            four_wait_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:256:13;
        end
        3: begin
            four_wait_PROC_STATE_next = 4; return;    // test_cthread_wait_n.cpp:257:13;
        end
        4: begin
            four_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:254:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : four_wait_ff
    if ( ~rstn ) begin
        four_wait_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:251:9;
    end
    else begin
        four_wait_PROC_STATE <= four_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: cntr_name_conflict (test_cthread_wait_n.cpp:264:5) 

// Thread-local variables
logic [1:0] cntr_name_conflict_WAIT_N_COUNTER0;
logic [1:0] cntr_name_conflict_WAIT_N_COUNTER_next0;
logic [2:0] cntr_name_conflict_WAIT_N_COUNTER_next_next;
logic cntr_name_conflict_WAIT_N_COUNTER;
logic cntr_name_conflict_WAIT_N_COUNTER_next1;
logic cntr_name_conflict_PROC_STATE;
logic cntr_name_conflict_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : cntr_name_conflict_comb     // test_cthread_wait_n.cpp:264:5
    cntr_name_conflict_func;
end
function void cntr_name_conflict_func;
    cntr_name_conflict_WAIT_N_COUNTER_next1 = cntr_name_conflict_WAIT_N_COUNTER;
    cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next;
    cntr_name_conflict_WAIT_N_COUNTER_next0 = cntr_name_conflict_WAIT_N_COUNTER0;
    cntr_name_conflict_PROC_STATE_next = cntr_name_conflict_PROC_STATE;
    
    case (cntr_name_conflict_PROC_STATE)
        0: begin
            cntr_name_conflict_WAIT_N_COUNTER_next1 = !cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next0 = 3;
            cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:273:13;
        end
        1: begin
            if (cntr_name_conflict_WAIT_N_COUNTER0 != 1) begin
                cntr_name_conflict_WAIT_N_COUNTER_next0 = cntr_name_conflict_WAIT_N_COUNTER0 - 1;
                cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:273:13;
            end;
            cntr_name_conflict_WAIT_N_COUNTER_next1 = !cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next0 = 3;
            cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:273:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : cntr_name_conflict_ff
    if ( ~rstn ) begin
        cntr_name_conflict_WAIT_N_COUNTER <= 0;
        cntr_name_conflict_WAIT_N_COUNTER_next <= cntr_name_conflict_WAIT_N_COUNTER;
        cntr_name_conflict_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:268:9;
        cntr_name_conflict_WAIT_N_COUNTER0 <= 0;
    end
    else begin
        cntr_name_conflict_WAIT_N_COUNTER0 <= cntr_name_conflict_WAIT_N_COUNTER_next0;
        cntr_name_conflict_WAIT_N_COUNTER_next <= cntr_name_conflict_WAIT_N_COUNTER_next_next;
        cntr_name_conflict_WAIT_N_COUNTER <= cntr_name_conflict_WAIT_N_COUNTER_next1;
        cntr_name_conflict_PROC_STATE <= cntr_name_conflict_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: while_wait (test_cthread_wait_n.cpp:277:5) 

// Thread-local variables
logic [1:0] while_wait_WAIT_N_COUNTER;
logic [1:0] while_wait_WAIT_N_COUNTER_next;
logic [1:0] while_wait_PROC_STATE;
logic [1:0] while_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : while_wait_comb     // test_cthread_wait_n.cpp:277:5
    while_wait_func;
end
function void while_wait_func;
    while_wait_WAIT_N_COUNTER_next = while_wait_WAIT_N_COUNTER;
    while_wait_PROC_STATE_next = while_wait_PROC_STATE;
    
    case (while_wait_PROC_STATE)
        0: begin
            if (a)
            begin
                while_wait_WAIT_N_COUNTER_next = 3;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:23;
            end
            while_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:283:13;
        end
        1: begin
            if (while_wait_WAIT_N_COUNTER != 1) begin
                while_wait_WAIT_N_COUNTER_next = while_wait_WAIT_N_COUNTER - 1;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:23;
            end;
            if (a)
            begin
                while_wait_WAIT_N_COUNTER_next = 3;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:23;
            end
            while_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:283:13;
        end
        2: begin
            if (a)
            begin
                while_wait_WAIT_N_COUNTER_next = 3;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:23;
            end
            while_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:283:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : while_wait_ff
    if ( ~rstn ) begin
        while_wait_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:279:9;
        while_wait_WAIT_N_COUNTER <= 0;
    end
    else begin
        while_wait_WAIT_N_COUNTER <= while_wait_WAIT_N_COUNTER_next;
        while_wait_PROC_STATE <= while_wait_PROC_STATE_next;
    end
end

endmodule



//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test ()
//
module test // "t_inst"
(
    input logic clk
);

// SystemC signals
logic rst;
logic [3:0] s;
logic [7:0] a_mif_s;
logic t;

//------------------------------------------------------------------------------
// Clocked THREAD: return_func1 (test_return.cpp:60:5) 

// Next-state combinational logic
always_comb begin : return_func1_comb     // test_return.cpp:60:5
    return_func1_func;
end
function void return_func1_func;
    logic TMP_0;
    integer unsigned bitIndx;
    logic [3:0] res;
    integer i;
    logic [3:0] TMP_2;
    integer unsigned rangeLo;
    logic [15:0] res_1;
    bitIndx = s;
    // Call f1() begin
    res = s;
    TMP_0 = 1'(res[bitIndx - 1]);
    // Call f1() end
    i = TMP_0;
    rangeLo = s;
    // Call f2() begin
    res_1 = s;
    TMP_2 = res_1[rangeLo +: 5];
    // Call f2() end
    i = TMP_2[1];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rst) 
begin : return_func1_ff
    if ( ~rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: mif_method_call (test_return.cpp:78:5) 

// Next-state combinational logic
always_comb begin : mif_method_call_comb     // test_return.cpp:78:5
    mif_method_call_func;
end
function void mif_method_call_func;
    logic [7:0] TMP_0;
    integer unsigned addr;
    logic [7:0] TMP_1;
    integer unsigned addr_1;
    addr = s;
    // Call read() begin
    addr_1 = addr;
    // Call read() begin
    TMP_1 = a_mif_s + addr_1;
    // Call read() end
    TMP_0 = TMP_1;
    // Call read() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rst) 
begin : mif_method_call_ff
    if ( ~rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: return_func4 (test_return.cpp:103:5) 

// Thread-local variables
logic [3:0] blockIndx;
logic [3:0] blockIndx_next;
logic arrp[10];
logic arrp_next[10];
logic [1:0] return_func4_PROC_STATE;
logic [1:0] return_func4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : return_func4_comb     // test_return.cpp:103:5
    return_func4_func;
end
function void return_func4_func;
    logic TMP_0;
    logic [3:0] blockIndx_1;
    arrp_next = arrp;
    blockIndx_next = blockIndx;
    return_func4_PROC_STATE_next = return_func4_PROC_STATE;
    
    case (return_func4_PROC_STATE)
        0: begin
            blockIndx_next = s;
            // Call ff5() begin
            return_func4_PROC_STATE_next = 1; return;    // test_return.cpp:98:13;
            // Call ff5() end
        end
        1: begin
            // Call ff5() begin
            blockIndx_1 = blockIndx_next;
            // Call f5() begin
            TMP_0 = !arrp_next[blockIndx_1] || t;
            // Call f5() end
            if (!TMP_0)
            begin
                return_func4_PROC_STATE_next = 1; return;    // test_return.cpp:98:13;
            end
            // Call ff5() end
            return_func4_PROC_STATE_next = 2; return;    // test_return.cpp:109:13;
        end
        2: begin
            blockIndx_next = s;
            // Call ff5() begin
            return_func4_PROC_STATE_next = 1; return;    // test_return.cpp:98:13;
            // Call ff5() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rst) 
begin : return_func4_ff
    if ( ~rst ) begin
        return_func4_PROC_STATE <= 0;    // test_return.cpp:105:9;
    end
    else begin
        blockIndx <= blockIndx_next;
        arrp <= arrp_next;
        return_func4_PROC_STATE <= return_func4_PROC_STATE_next;
    end
end

endmodule



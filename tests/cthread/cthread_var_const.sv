//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// SystemC signals
logic rstn;
logic signed [31:0] in;
logic [2:0] s;
logic [2:0] s2;
logic [2:0] s3;
logic [2:0] s4;

//------------------------------------------------------------------------------
// Clocked THREAD: local_rnd1 (test_cthread_var_const.cpp:44:5) 

// Thread-local variables
logic [2:0] D;
logic [2:0] D_next;
logic local_rnd1_PROC_STATE;
logic local_rnd1_PROC_STATE_next;

// Thread-local constants
logic signed [31:0] C;

// Next-state combinational logic
always_comb begin : local_rnd1_comb     // test_cthread_var_const.cpp:44:5
    local_rnd1_func;
end
function void local_rnd1_func;
    integer i;
    D_next = D;
    local_rnd1_PROC_STATE_next = local_rnd1_PROC_STATE;
    
    case (local_rnd1_PROC_STATE)
        0: begin
            D_next = s;
            local_rnd1_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:51:13;
        end
        1: begin
            if (|C)
            begin
                i = D_next;
            end
            D_next = s;
            local_rnd1_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:51:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : local_rnd1_ff
    if ( ~rstn ) begin
        integer i;
        i = 0;
        C = in;
        local_rnd1_PROC_STATE <= 0;    // test_cthread_var_const.cpp:47:9;
    end
    else begin
        D <= D_next;
        local_rnd1_PROC_STATE <= local_rnd1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_rnd2 (test_cthread_var_const.cpp:57:5) 

// Thread-local variables
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [2:0] G;
logic [2:0] G_next;
logic [2:0] s2_next;
logic [1:0] local_rnd2_PROC_STATE;
logic [1:0] local_rnd2_PROC_STATE_next;

// Thread-local constants
logic signed [31:0] ARR[3];

// Next-state combinational logic
always_comb begin : local_rnd2_comb     // test_cthread_var_const.cpp:57:5
    local_rnd2_func;
end
function void local_rnd2_func;
    G_next = G;
    i_next = i;
    s2_next = s2;
    local_rnd2_PROC_STATE_next = local_rnd2_PROC_STATE;
    
    case (local_rnd2_PROC_STATE)
        0: begin
            G_next = ARR[2];
            local_rnd2_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:64:13;
        end
        1: begin
            if (|s)
            begin
                i_next = ARR[s];
            end
            local_rnd2_PROC_STATE_next = 2; return;    // test_cthread_var_const.cpp:67:13;
        end
        2: begin
            s2_next = signed'({1'b0, G_next}) + i_next;
            G_next = ARR[2];
            local_rnd2_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:64:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : local_rnd2_ff
    if ( ~rstn ) begin
        i <= 0;
        ARR[0] = 1; ARR[1] = 2; ARR[2] = in;
        local_rnd2_PROC_STATE <= 0;    // test_cthread_var_const.cpp:60:9;
    end
    else begin
        i <= i_next;
        G <= G_next;
        s2 <= s2_next;
        local_rnd2_PROC_STATE <= local_rnd2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_rnd3 (test_cthread_var_const.cpp:75:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic signed [3:0] Y;
logic signed [3:0] Y_next;
logic [3:0] X;
logic [3:0] X_next;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic [2:0] s3_next;
logic [2:0] local_rnd3_PROC_STATE;
logic [2:0] local_rnd3_PROC_STATE_next;

// Thread-local constants
logic [3:0] Z;

// Next-state combinational logic
always_comb begin : local_rnd3_comb     // test_cthread_var_const.cpp:75:5
    local_rnd3_func;
end
function void local_rnd3_func;
    X_next = X;
    Y_next = Y;
    i_next0 = i0;
    j_next = j;
    s3_next = s3;
    local_rnd3_PROC_STATE_next = local_rnd3_PROC_STATE;
    
    case (local_rnd3_PROC_STATE)
        0: begin
            i_next0 = Z + 1;
            local_rnd3_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:82:9;
        end
        1: begin
            if (|s)
            begin
                Y_next = i_next0;
                local_rnd3_PROC_STATE_next = 2; return;    // test_cthread_var_const.cpp:87:17;
            end
            local_rnd3_PROC_STATE_next = 4; return;    // test_cthread_var_const.cpp:95:13;
        end
        2: begin
            j_next = 0;
            X_next = Y_next + j_next;
            local_rnd3_PROC_STATE_next = 3; return;    // test_cthread_var_const.cpp:91:21;
        end
        3: begin
            s3_next = X_next;
            ++j_next;
            if (j_next < 3)
            begin
                X_next = Y_next + j_next;
                local_rnd3_PROC_STATE_next = 3; return;    // test_cthread_var_const.cpp:91:21;
            end
            local_rnd3_PROC_STATE_next = 4; return;    // test_cthread_var_const.cpp:95:13;
        end
        4: begin
            if (|s)
            begin
                Y_next = i_next0;
                local_rnd3_PROC_STATE_next = 2; return;    // test_cthread_var_const.cpp:87:17;
            end
            local_rnd3_PROC_STATE_next = 4; return;    // test_cthread_var_const.cpp:95:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : local_rnd3_ff
    if ( ~rstn ) begin
        i0 <= 0;
        if (1)
        begin
            Z = in;
            local_rnd3_PROC_STATE <= 0;    // test_cthread_var_const.cpp:79:13;
        end
    end
    else begin
        i0 <= i_next0;
        Y <= Y_next;
        X <= X_next;
        j <= j_next;
        s3 <= s3_next;
        local_rnd3_PROC_STATE <= local_rnd3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_def_read1 (test_cthread_var_const.cpp:100:5) 

// Next-state combinational logic
always_comb begin : local_def_read1_comb     // test_cthread_var_const.cpp:100:5
    local_def_read1_func;
end
function void local_def_read1_func;
    integer E;
    integer i;
    logic [2:0] F;
    F = s;
    i = F;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : local_def_read1_ff
    if ( ~rstn ) begin
        integer E;
        integer i;
        E = in;
        i = E;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_def_read2 (test_cthread_var_const.cpp:113:5) 

// Thread-local variables
logic signed [31:0] ARRB[3];
logic signed [31:0] ARRB_next[3];
logic [2:0] L;
logic [2:0] L_next;
logic [2:0] s4_next;
logic local_def_read2_PROC_STATE;
logic local_def_read2_PROC_STATE_next;

// Thread-local constants

// Next-state combinational logic
always_comb begin : local_def_read2_comb     // test_cthread_var_const.cpp:113:5
    local_def_read2_func;
end
function void local_def_read2_func;
    logic [2:0] ARRA[3];
    ARRB_next = ARRB;
    L_next = L;
    s4_next = s4;
    local_def_read2_PROC_STATE_next = local_def_read2_PROC_STATE;
    
    case (local_def_read2_PROC_STATE)
        0: begin
            ARRB_next[0] = in + 1; ARRB_next[1] = in + 2; ARRB_next[2] = in + 3;
            L_next = ARRB_next[1 + s];
            local_def_read2_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:122:13;
        end
        1: begin
            s4_next = L_next;
            ARRB_next[0] = in + 1; ARRB_next[1] = in + 2; ARRB_next[2] = in + 3;
            L_next = ARRB_next[1 + s];
            local_def_read2_PROC_STATE_next = 1; return;    // test_cthread_var_const.cpp:122:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : local_def_read2_ff
    if ( ~rstn ) begin
        logic [2:0] ARRA[3];
        ARRA[0] = 1; ARRA[1] = 2; ARRA[2] = 3;
        local_def_read2_PROC_STATE <= 0;    // test_cthread_var_const.cpp:116:9;
    end
    else begin
        ARRB <= ARRB_next;
        L <= L_next;
        s4 <= s4_next;
        local_def_read2_PROC_STATE <= local_def_read2_PROC_STATE_next;
    end
end

endmodule



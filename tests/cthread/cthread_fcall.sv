//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
);

// SystemC signals
logic clk;
logic arstn;
logic signed [31:0] out;
logic signed [31:0] in;
logic [3:0] s0;

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread0 (test_cthread_fcall.cpp:221:5) 

// Thread-local variables
logic signed [31:0] out_next;
logic test_thread0_PROC_STATE;
logic test_thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread0_comb     // test_cthread_fcall.cpp:221:5
    test_thread0_func;
end
function void test_thread0_func;
    integer k;
    out_next = out;
    test_thread0_PROC_STATE_next = test_thread0_PROC_STATE;
    
    case (test_thread0_PROC_STATE)
        0: begin
            out_next = 1;
            // Call f1() begin
            k = 0;
            test_thread0_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next = 2;
            out_next = 1;
            // Call f1() begin
            k = 0;
            test_thread0_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread0_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread0_PROC_STATE <= 0;    // test_cthread_fcall.cpp:224:9;
    end
    else begin
        out <= out_next;
        test_thread0_PROC_STATE <= test_thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if1 (test_cthread_fcall.cpp:234:5) 

// Thread-local variables
logic signed [31:0] out_next0;
logic [1:0] test_thread_in_if1_PROC_STATE;
logic [1:0] test_thread_in_if1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if1_comb     // test_cthread_fcall.cpp:234:5
    test_thread_in_if1_func;
end
function void test_thread_in_if1_func;
    integer k;
    out_next0 = out;
    test_thread_in_if1_PROC_STATE_next = test_thread_in_if1_PROC_STATE;
    
    case (test_thread_in_if1_PROC_STATE)
        0: begin
            out_next0 = 1;
            if (in > 1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_if1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            out_next0 = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:247:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next0 = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:247:13;
        end
        2: begin
            out_next0 = 3;
            out_next0 = 1;
            if (in > 1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_if1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            out_next0 = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:247:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if1_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_if1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:237:9;
    end
    else begin
        out <= out_next0;
        test_thread_in_if1_PROC_STATE <= test_thread_in_if1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if2 (test_cthread_fcall.cpp:254:5) 

// Thread-local variables
logic signed [31:0] out_next1;
logic [1:0] test_thread_in_if2_PROC_STATE;
logic [1:0] test_thread_in_if2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if2_comb     // test_cthread_fcall.cpp:254:5
    test_thread_in_if2_func;
end
function void test_thread_in_if2_func;
    integer k;
    out_next1 = out;
    test_thread_in_if2_PROC_STATE_next = test_thread_in_if2_PROC_STATE;
    
    case (test_thread_in_if2_PROC_STATE)
        0: begin
            out_next1 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    // Call f1() begin
                    k = 0;
                    test_thread_in_if2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                    // Call f1() end
                end
            end
            out_next1 = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:269:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next1 = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:269:13;
        end
        2: begin
            out_next1 = 3;
            out_next1 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    // Call f1() begin
                    k = 0;
                    test_thread_in_if2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                    // Call f1() end
                end
            end
            out_next1 = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:269:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if2_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_if2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:257:9;
    end
    else begin
        out <= out_next1;
        test_thread_in_if2_PROC_STATE <= test_thread_in_if2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_for1 (test_cthread_fcall.cpp:300:5) 

// Thread-local variables
logic signed [31:0] out_next2;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [1:0] test_thread_in_for1_PROC_STATE;
logic [1:0] test_thread_in_for1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_for1_comb     // test_cthread_fcall.cpp:300:5
    test_thread_in_for1_func;
end
function void test_thread_in_for1_func;
    integer k;
    i_next = i;
    out_next2 = out;
    test_thread_in_for1_PROC_STATE_next = test_thread_in_for1_PROC_STATE;
    
    case (test_thread_in_for1_PROC_STATE)
        0: begin
            out_next2 = 1;
            i_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            i_next++;
            if (i_next < 3)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            out_next2 = 2;
            test_thread_in_for1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:313:13;
        end
        2: begin
            out_next2 = 3;
            out_next2 = 1;
            i_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_for1_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_for1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:303:9;
    end
    else begin
        out <= out_next2;
        i <= i_next;
        test_thread_in_for1_PROC_STATE <= test_thread_in_for1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_for2 (test_cthread_fcall.cpp:320:5) 

// Thread-local variables
logic signed [31:0] out_next3;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] test_thread_in_for2_PROC_STATE;
logic [1:0] test_thread_in_for2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_for2_comb     // test_cthread_fcall.cpp:320:5
    test_thread_in_for2_func;
end
function void test_thread_in_for2_func;
    integer k;
    i_next0 = i0;
    j_next = j;
    out_next3 = out;
    test_thread_in_for2_PROC_STATE_next = test_thread_in_for2_PROC_STATE;
    
    case (test_thread_in_for2_PROC_STATE)
        0: begin
            out_next3 = 1;
            i_next0 = 0;
            j_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_next++;
            if (j_next < 3)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            i_next0++;
            if (i_next0 < 3)
            begin
                j_next = 0;
                // Call f1() begin
                k = 0;
                test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            out_next3 = 2;
            test_thread_in_for2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:335:13;
        end
        2: begin
            out_next3 = 3;
            out_next3 = 1;
            i_next0 = 0;
            j_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_for2_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_for2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:323:9;
    end
    else begin
        out <= out_next3;
        j <= j_next;
        i0 <= i_next0;
        test_thread_in_for2_PROC_STATE <= test_thread_in_for2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if3 (test_cthread_fcall.cpp:276:5) 

// Thread-local variables
logic signed [31:0] out_next4;
logic [1:0] test_thread_in_if3_PROC_STATE;
logic [1:0] test_thread_in_if3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if3_comb     // test_cthread_fcall.cpp:276:5
    test_thread_in_if3_func;
end
function void test_thread_in_if3_func;
    integer k;
    out_next4 = out;
    test_thread_in_if3_PROC_STATE_next = test_thread_in_if3_PROC_STATE;
    
    case (test_thread_in_if3_PROC_STATE)
        0: begin
            out_next4 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    out_next4 = 4;
                end
                // Call f1() begin
                k = 0;
                test_thread_in_if3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            out_next4 = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:293:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next4 = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:293:13;
        end
        2: begin
            out_next4 = 3;
            out_next4 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    out_next4 = 4;
                end
                // Call f1() begin
                k = 0;
                test_thread_in_if3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            out_next4 = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:293:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if3_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_if3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:279:9;
    end
    else begin
        out <= out_next4;
        test_thread_in_if3_PROC_STATE <= test_thread_in_if3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple1 (test_cthread_fcall.cpp:420:5) 

// Thread-local variables
logic [1:0] test_thread_multiple1_PROC_STATE;
logic [1:0] test_thread_multiple1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple1_comb     // test_cthread_fcall.cpp:420:5
    test_thread_multiple1_func;
end
function void test_thread_multiple1_func;
    integer j;
    integer k;
    test_thread_multiple1_PROC_STATE_next = test_thread_multiple1_PROC_STATE;
    
    case (test_thread_multiple1_PROC_STATE)
        0: begin
            j = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j = 2;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        2: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple1_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_multiple1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:423:9;
    end
    else begin
        test_thread_multiple1_PROC_STATE <= test_thread_multiple1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple2 (test_cthread_fcall.cpp:435:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic [1:0] test_thread_multiple2_PROC_STATE;
logic [1:0] test_thread_multiple2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple2_comb     // test_cthread_fcall.cpp:435:5
    test_thread_multiple2_func;
end
function void test_thread_multiple2_func;
    integer j;
    integer k;
    i_next1 = i1;
    test_thread_multiple2_PROC_STATE_next = test_thread_multiple2_PROC_STATE;
    
    case (test_thread_multiple2_PROC_STATE)
        0: begin
            j = 1;
            i_next1 = 1;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
            // Call f2() end
        end
        1: begin
            // Call f2() begin
            k = i_next1 + 1;
            // Call f2() end
            j = 2;
            i_next1 = 2;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:133:9;
            // Call f2() end
        end
        2: begin
            // Call f2() begin
            k = i_next1 + 1;
            // Call f2() end
            j = 1;
            i_next1 = 1;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
            // Call f2() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple2_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_multiple2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:438:9;
    end
    else begin
        i1 <= i_next1;
        test_thread_multiple2_PROC_STATE <= test_thread_multiple2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple3 (test_cthread_fcall.cpp:450:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next2;
logic [2:0] test_thread_multiple3_PROC_STATE;
logic [2:0] test_thread_multiple3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple3_comb     // test_cthread_fcall.cpp:450:5
    test_thread_multiple3_func;
end
function void test_thread_multiple3_func;
    integer j;
    integer k;
    integer k_1;
    i_next2 = i2;
    test_thread_multiple3_PROC_STATE_next = test_thread_multiple3_PROC_STATE;
    
    case (test_thread_multiple3_PROC_STATE)
        0: begin
            j = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j = 2;
            i_next2 = 1;
            // Call f2() begin
            k_1 = i_next2;
            test_thread_multiple3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:133:9;
            // Call f2() end
        end
        2: begin
            // Call f2() begin
            k_1 = i_next2 + 1;
            // Call f2() end
            if (|in)
            begin
                // Call f1() begin
                k = 0;
                test_thread_multiple3_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 5; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        3: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            i_next2 = 2;
            // Call f2() begin
            k_1 = i_next2;
            test_thread_multiple3_PROC_STATE_next = 4; return;    // test_cthread_fcall.cpp:133:9;
            // Call f2() end
        end
        4: begin
            // Call f2() begin
            k_1 = i_next2 + 1;
            // Call f2() end
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 5; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
        5: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple3_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_multiple3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:453:9;
    end
    else begin
        i2 <= i_next2;
        test_thread_multiple3_PROC_STATE <= test_thread_multiple3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params1 (test_cthread_fcall.cpp:500:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [31:0] i3;
logic signed [31:0] i_next3;
logic [1:0] test_thread_params1_PROC_STATE;
logic [1:0] test_thread_params1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params1_comb     // test_cthread_fcall.cpp:500:5
    test_thread_params1_func;
end
function void test_thread_params1_func;
    integer TMP_0;
    integer TMP_1;
    i_next3 = i3;
    j_next0 = j0;
    test_thread_params1_PROC_STATE_next = test_thread_params1_PROC_STATE;
    
    case (test_thread_params1_PROC_STATE)
        0: begin
            i_next3 = j_next0;
            // Call f3() begin
            if (|i_next3)
            begin
                test_thread_params1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:140:13;
            end
            TMP_0 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_0;
            test_thread_params1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:508:13;
        end
        1: begin
            i_next3 = j_next0;
            // Call f3() begin
            if (|i_next3)
            begin
                test_thread_params1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:140:13;
            end
            TMP_1 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_1;
            test_thread_params1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:508:13;
        end
        2: begin
            // Call f3() begin
            TMP_1 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_1;
            test_thread_params1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:508:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params1_ff
    if ( ~arstn ) begin
        j0 <= 0;
        test_thread_params1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:503:9;
    end
    else begin
        j0 <= j_next0;
        i3 <= i_next3;
        test_thread_params1_PROC_STATE <= test_thread_params1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params2 (test_cthread_fcall.cpp:513:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next4;
logic signed [31:0] N;
logic signed [31:0] N_next;
logic test_thread_params2_PROC_STATE;
logic test_thread_params2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params2_comb     // test_cthread_fcall.cpp:513:5
    test_thread_params2_func;
end
function void test_thread_params2_func;
    integer j;
    N_next = N;
    i_next4 = i4;
    test_thread_params2_PROC_STATE_next = test_thread_params2_PROC_STATE;
    
    case (test_thread_params2_PROC_STATE)
        0: begin
            j = 1;
            N_next = 1;
            // Call f4() begin
            i_next4 = 0;
            test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:148:13;
            // Call f4() end
        end
        1: begin
            // Call f4() begin
            i_next4++;
            if (i_next4 < N_next)
            begin
                test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:148:13;
            end
            // Call f4() end
            j = 2;
            j = 1;
            N_next = 1;
            // Call f4() begin
            i_next4 = 0;
            test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:148:13;
            // Call f4() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params2_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_params2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:516:9;
    end
    else begin
        i4 <= i_next4;
        N <= N_next;
        test_thread_params2_PROC_STATE <= test_thread_params2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params3 (test_cthread_fcall.cpp:526:5) 

// Thread-local variables
logic signed [31:0] val;
logic signed [31:0] val_next;
logic [1:0] test_thread_params3_PROC_STATE;
logic [1:0] test_thread_params3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params3_comb     // test_cthread_fcall.cpp:526:5
    test_thread_params3_func;
end
function void test_thread_params3_func;
    integer j;
    integer TMP_0;
    val_next = val;
    test_thread_params3_PROC_STATE_next = test_thread_params3_PROC_STATE;
    
    case (test_thread_params3_PROC_STATE)
        0: begin
            test_thread_params3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:532:13;
        end
        1: begin
            val_next = 1;
            // Call f6() begin
            test_thread_params3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:178:9;
            // Call f6() end
        end
        2: begin
            // Call f6() begin
            TMP_0 = val_next - 1;
            // Call f6() end
            j = TMP_0;
            test_thread_params3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:532:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params3_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_params3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:529:9;
    end
    else begin
        val <= val_next;
        test_thread_params3_PROC_STATE <= test_thread_params3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params4 (test_cthread_fcall.cpp:538:5) 

// Thread-local variables
logic signed [31:0] j1;
logic signed [31:0] j_next1;
logic b;
logic b_next;
logic signed [31:0] out_next5;
logic signed [2:0] val0;
logic signed [2:0] val_next0;
logic [1:0] test_thread_params4_PROC_STATE;
logic [1:0] test_thread_params4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params4_comb     // test_cthread_fcall.cpp:538:5
    test_thread_params4_func;
end
function void test_thread_params4_func;
    logic TMP_0;
    logic TMP_2;
    b_next = b;
    j_next1 = j1;
    out_next5 = out;
    val_next0 = val0;
    test_thread_params4_PROC_STATE_next = test_thread_params4_PROC_STATE;
    
    case (test_thread_params4_PROC_STATE)
        0: begin
            val_next0 = j_next1;
            // Call f6_() begin
            test_thread_params4_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:183:9;
            // Call f6_() end
        end
        1: begin
            // Call f6_() begin
            TMP_0 = |val_next0;
            // Call f6_() end
            b_next = TMP_0;
            test_thread_params4_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:545:13;
        end
        2: begin
            out_next5 = b_next;
            val_next0 = j_next1;
            // Call f6_() begin
            test_thread_params4_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:183:9;
            // Call f6_() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params4_ff
    if ( ~arstn ) begin
        j1 <= 0;
        test_thread_params4_PROC_STATE <= 0;    // test_cthread_fcall.cpp:541:9;
    end
    else begin
        j1 <= j_next1;
        b <= b_next;
        out <= out_next5;
        val0 <= val_next0;
        test_thread_params4_PROC_STATE <= test_thread_params4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params5 (test_cthread_fcall.cpp:552:5) 

// Thread-local variables
logic signed [31:0] j2;
logic signed [31:0] j_next2;
logic [2:0] x;
logic [2:0] x_next;
logic signed [31:0] out_next6;
logic signed [31:0] val2;
logic signed [31:0] val2_next;
logic [1:0] test_thread_params5_PROC_STATE;
logic [1:0] test_thread_params5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params5_comb     // test_cthread_fcall.cpp:552:5
    test_thread_params5_func;
end
function void test_thread_params5_func;
    logic b;
    integer TMP_0;
    logic val1;
    integer TMP_1;
    j_next2 = j2;
    out_next6 = out;
    val2_next = val2;
    x_next = x;
    test_thread_params5_PROC_STATE_next = test_thread_params5_PROC_STATE;
    
    case (test_thread_params5_PROC_STATE)
        0: begin
            b = |in;
            x_next = 5;
            val1 = b; val2_next = j_next2;
            // Call f6__() begin
            if (val1)
            begin
                test_thread_params5_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:190:13;
            end else begin
                x_next = signed'({1'b0, x_next}) + val2_next;
                TMP_0 = val2_next + 2;
            end
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:561:13;
        end
        1: begin
            // Call f6__() begin
            TMP_0 = val2_next + 1;
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:561:13;
        end
        2: begin
            out_next6 = x_next;
            b = |in;
            x_next = 5;
            val1 = b; val2_next = j_next2;
            // Call f6__() begin
            if (val1)
            begin
                test_thread_params5_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:190:13;
            end else begin
                x_next = signed'({1'b0, x_next}) + val2_next;
                TMP_1 = val2_next + 2;
            end
            // Call f6__() end
            j_next2 = TMP_1;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:561:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params5_ff
    if ( ~arstn ) begin
        j2 <= 1;
        test_thread_params5_PROC_STATE <= 0;    // test_cthread_fcall.cpp:555:9;
    end
    else begin
        j2 <= j_next2;
        x <= x_next;
        out <= out_next6;
        val2 <= val2_next;
        test_thread_params5_PROC_STATE <= test_thread_params5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple_wait1 (test_cthread_fcall.cpp:570:5) 

// Thread-local variables
logic [1:0] test_thread_multiple_wait1_PROC_STATE;
logic [1:0] test_thread_multiple_wait1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple_wait1_comb     // test_cthread_fcall.cpp:570:5
    test_thread_multiple_wait1_func;
end
function void test_thread_multiple_wait1_func;
    integer j;
    integer k;
    test_thread_multiple_wait1_PROC_STATE_next = test_thread_multiple_wait1_PROC_STATE;
    
    case (test_thread_multiple_wait1_PROC_STATE)
        0: begin
            j = 1;
            // Call f5() begin
            k = 0;
            test_thread_multiple_wait1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:156:9;
            // Call f5() end
        end
        1: begin
            // Call f5() begin
            k = 1;
            test_thread_multiple_wait1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:159:9;
            // Call f5() end
        end
        2: begin
            // Call f5() begin
            k = 2;
            // Call f5() end
            j = 2;
            j = 1;
            // Call f5() begin
            k = 0;
            test_thread_multiple_wait1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:156:9;
            // Call f5() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple_wait1_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_multiple_wait1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:573:9;
    end
    else begin
        test_thread_multiple_wait1_PROC_STATE <= test_thread_multiple_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple_wait2 (test_cthread_fcall.cpp:583:5) 

// Thread-local variables
logic [1:0] test_thread_multiple_wait2_PROC_STATE;
logic [1:0] test_thread_multiple_wait2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple_wait2_comb     // test_cthread_fcall.cpp:583:5
    test_thread_multiple_wait2_func;
end
function void test_thread_multiple_wait2_func;
    integer j;
    integer k;
    test_thread_multiple_wait2_PROC_STATE_next = test_thread_multiple_wait2_PROC_STATE;
    
    case (test_thread_multiple_wait2_PROC_STATE)
        0: begin
            j = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:9;
            // Call f5_() end
        end
        1: begin
            // Call f5_() begin
            if (|in)
            begin
                k = 1;
                test_thread_multiple_wait2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:171:13;
            end
            k = 2;
            // Call f5_() end
            j = 2;
            j = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:9;
            // Call f5_() end
        end
        2: begin
            // Call f5_() begin
            k = 2;
            // Call f5_() end
            j = 2;
            j = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:9;
            // Call f5_() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple_wait2_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_multiple_wait2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:586:9;
    end
    else begin
        test_thread_multiple_wait2_PROC_STATE <= test_thread_multiple_wait2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_inside_call1 (test_cthread_fcall.cpp:472:5) 

// Thread-local variables
logic test_thread_inside_call1_PROC_STATE;
logic test_thread_inside_call1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_inside_call1_comb     // test_cthread_fcall.cpp:472:5
    test_thread_inside_call1_func;
end
function void test_thread_inside_call1_func;
    integer j;
    integer l;
    integer k;
    test_thread_inside_call1_PROC_STATE_next = test_thread_inside_call1_PROC_STATE;
    
    case (test_thread_inside_call1_PROC_STATE)
        0: begin
            j = 1;
            // Call f7() begin
            l = 0;
            // Call f1() begin
            k = 0;
            test_thread_inside_call1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
            // Call f7() end
        end
        1: begin
            // Call f7() begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            l = 1;
            // Call f7() end
            j = 2;
            j = 1;
            // Call f7() begin
            l = 0;
            // Call f1() begin
            k = 0;
            test_thread_inside_call1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
            // Call f1() end
            // Call f7() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_inside_call1_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_inside_call1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:475:9;
    end
    else begin
        test_thread_inside_call1_PROC_STATE <= test_thread_inside_call1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_inside_call2 (test_cthread_fcall.cpp:485:5) 

// Thread-local variables
logic [1:0] test_thread_inside_call2_PROC_STATE;
logic [1:0] test_thread_inside_call2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_inside_call2_comb     // test_cthread_fcall.cpp:485:5
    test_thread_inside_call2_func;
end
function void test_thread_inside_call2_func;
    integer j;
    integer val;
    integer l;
    integer k;
    test_thread_inside_call2_PROC_STATE_next = test_thread_inside_call2_PROC_STATE;
    
    case (test_thread_inside_call2_PROC_STATE)
        0: begin
            j = 1;
            val = j;
            // Call f7_() begin
            l = 0;
            if (1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_inside_call2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            // Call f7_() end
        end
        1: begin
            // Call f7_() begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            l = 1;
            test_thread_inside_call2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:211:9;
            // Call f7_() end
        end
        2: begin
            j = 2;
            j = 1;
            val = j;
            // Call f7_() begin
            l = 0;
            if (1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_inside_call2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:127:9;
                // Call f1() end
            end
            // Call f7_() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_inside_call2_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_thread_inside_call2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:488:9;
    end
    else begin
        test_thread_inside_call2_PROC_STATE <= test_thread_inside_call2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_while1 (test_cthread_fcall.cpp:342:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next5;
logic signed [31:0] N0;
logic signed [31:0] N_next0;
logic signed [31:0] j3;
logic signed [31:0] j_next3;
logic [1:0] test_thread_in_while1_PROC_STATE;
logic [1:0] test_thread_in_while1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_while1_comb     // test_cthread_fcall.cpp:342:5
    test_thread_in_while1_func;
end
function void test_thread_in_while1_func;
    N_next0 = N0;
    i_next5 = i5;
    j_next3 = j3;
    test_thread_in_while1_PROC_STATE_next = test_thread_in_while1_PROC_STATE;
    
    case (test_thread_in_while1_PROC_STATE)
        0: begin
            j_next3 = 0;
            N_next0 = j_next3;
            // Call f4() begin
            i_next5 = 0;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:148:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:351:17;
        end
        1: begin
            j_next3++;
            if (j_next3 < 3)
            begin
                N_next0 = j_next3;
                // Call f4() begin
                i_next5 = 0;
                if (i_next5 < N_next0)
                begin
                    test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:148:13;
                end
                // Call f4() end
                test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:351:17;
            end
            test_thread_in_while1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:355:13;
        end
        2: begin
            // Call f4() begin
            i_next5++;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:148:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:351:17;
        end
        3: begin
            j_next3 = 0;
            N_next0 = j_next3;
            // Call f4() begin
            i_next5 = 0;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:148:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:351:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_while1_ff
    if ( ~arstn ) begin
        test_thread_in_while1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:344:9;
    end
    else begin
        i5 <= i_next5;
        N0 <= N_next0;
        j3 <= j_next3;
        test_thread_in_while1_PROC_STATE <= test_thread_in_while1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break1 (test_cthread_fcall.cpp:359:5) 

// Thread-local variables
logic signed [31:0] j4;
logic signed [31:0] j_next4;
logic [1:0] test_thread_with_break1_PROC_STATE;
logic [1:0] test_thread_with_break1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break1_comb     // test_cthread_fcall.cpp:359:5
    test_thread_with_break1_func;
end
function void test_thread_with_break1_func;
    integer k;
    j_next4 = j4;
    test_thread_with_break1_PROC_STATE_next = test_thread_with_break1_PROC_STATE;
    
    case (test_thread_with_break1_PROC_STATE)
        0: begin
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:156:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:372:17;
        end
        1: begin
            // Call f5() begin
            k = 1;
            test_thread_with_break1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:159:9;
            // Call f5() end
        end
        2: begin
            // Call f5() begin
            k = 2;
            // Call f5() end
            // break begin
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:156:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:372:17;
            // break end
        end
        3: begin
            j_next4++;
            if (j_next4 < 3)
            begin
                if (|in)
                begin
                    // Call f5() begin
                    k = 0;
                    test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:156:9;
                    // Call f5() end
                end
                test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:372:17;
            end
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:156:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:372:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break1_ff
    if ( ~arstn ) begin
        test_thread_with_break1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:361:9;
    end
    else begin
        j4 <= j_next4;
        test_thread_with_break1_PROC_STATE <= test_thread_with_break1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break2 (test_cthread_fcall.cpp:378:5) 

// Thread-local variables
logic signed [31:0] j5;
logic signed [31:0] j_next5;
logic signed [31:0] i6;
logic signed [31:0] i_next6;
logic [1:0] test_thread_with_break2_PROC_STATE;
logic [1:0] test_thread_with_break2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break2_comb     // test_cthread_fcall.cpp:378:5
    test_thread_with_break2_func;
end
function void test_thread_with_break2_func;
    integer TMP_0;
    i_next6 = i6;
    j_next5 = j5;
    test_thread_with_break2_PROC_STATE_next = test_thread_with_break2_PROC_STATE;
    
    case (test_thread_with_break2_PROC_STATE)
        0: begin
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:386:17;
        end
        1: begin
            if (|in)
            begin
                // break begin
                j_next5 = 0;
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:386:17;
                // break end
            end
            i_next6 = j_next5;
            // Call f3() begin
            if (|i_next6)
            begin
                test_thread_with_break2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:140:13;
            end
            TMP_0 = i_next6 + 1;
            // Call f3() end
            j_next5++;
            if (j_next5 < 3)
            begin
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:386:17;
            end
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:386:17;
        end
        2: begin
            // Call f3() begin
            TMP_0 = i_next6 + 1;
            // Call f3() end
            j_next5++;
            if (j_next5 < 3)
            begin
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:386:17;
            end
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:386:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break2_ff
    if ( ~arstn ) begin
        test_thread_with_break2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:380:9;
    end
    else begin
        j5 <= j_next5;
        i6 <= i_next6;
        test_thread_with_break2_PROC_STATE <= test_thread_with_break2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break3 (test_cthread_fcall.cpp:399:5) 

// Thread-local variables
logic signed [31:0] j6;
logic signed [31:0] j_next6;
logic test_thread_with_break3_PROC_STATE;
logic test_thread_with_break3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break3_comb     // test_cthread_fcall.cpp:399:5
    test_thread_with_break3_func;
end
function void test_thread_with_break3_func;
    j_next6 = j6;
    test_thread_with_break3_PROC_STATE_next = test_thread_with_break3_PROC_STATE;
    
    case (test_thread_with_break3_PROC_STATE)
        0: begin
            j_next6 = 0;
            test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:407:17;
        end
        1: begin
            if (|in)
            begin
                // break begin
                j_next6 = 0;
                test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:407:17;
                // break end
            end
            j_next6++;
            if (j_next6 < 3)
            begin
                test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:407:17;
            end
            j_next6 = 0;
            test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:407:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break3_ff
    if ( ~arstn ) begin
        test_thread_with_break3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:401:9;
    end
    else begin
        j6 <= j_next6;
        test_thread_with_break3_PROC_STATE <= test_thread_with_break3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_reg_arg (test_cthread_fcall.cpp:622:5) 

// Thread-local variables
logic signed [31:0] i7;
logic signed [31:0] i_next7;
logic test_thread_reg_arg_PROC_STATE;
logic test_thread_reg_arg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_reg_arg_comb     // test_cthread_fcall.cpp:622:5
    test_thread_reg_arg_func;
end
function void test_thread_reg_arg_func;
    integer TMP_0;
    integer val;
    integer TMP_1;
    i_next7 = i7;
    test_thread_reg_arg_PROC_STATE_next = test_thread_reg_arg_PROC_STATE;
    
    case (test_thread_reg_arg_PROC_STATE)
        0: begin
            val = i_next7;
            // Call f0() begin
            TMP_0 = val - 1;
            // Call f0() end
            test_thread_reg_arg_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:628:13;
        end
        1: begin
            i_next7 = i_next7 + 1;
            val = i_next7;
            // Call f0() begin
            TMP_1 = val - 1;
            // Call f0() end
            test_thread_reg_arg_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:628:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_reg_arg_ff
    if ( ~arstn ) begin
        i7 <= 0;
        test_thread_reg_arg_PROC_STATE <= 0;    // test_cthread_fcall.cpp:625:9;
    end
    else begin
        i7 <= i_next7;
        test_thread_reg_arg_PROC_STATE <= test_thread_reg_arg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: func_in_cond1 (test_cthread_fcall.cpp:643:5) 

// Thread-local variables
logic signed [31:0] val1;
logic signed [31:0] val_next1;
logic [1:0] func_in_cond1_PROC_STATE;
logic [1:0] func_in_cond1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : func_in_cond1_comb     // test_cthread_fcall.cpp:643:5
    func_in_cond1_func;
end
function void func_in_cond1_func;
    integer TMP_0;
    integer TMP_1;
    val_next1 = val1;
    func_in_cond1_PROC_STATE_next = func_in_cond1_PROC_STATE;
    
    case (func_in_cond1_PROC_STATE)
        0: begin
            val_next1 = in;
            // Call multi_wait_f() begin
            val_next1--;
            func_in_cond1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:639:9;
            // Call multi_wait_f() end
        end
        1: begin
            // Call multi_wait_f() begin
            TMP_0 = val_next1 - 1;
            // Call multi_wait_f() end
            if (|TMP_0)
            begin
                func_in_cond1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:649:17;
            end
            func_in_cond1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:652:13;
        end
        2: begin
            func_in_cond1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:652:13;
        end
        3: begin
            val_next1 = in;
            // Call multi_wait_f() begin
            val_next1--;
            func_in_cond1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:639:9;
            // Call multi_wait_f() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : func_in_cond1_ff
    if ( ~arstn ) begin
        func_in_cond1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:645:9;
    end
    else begin
        val1 <= val_next1;
        func_in_cond1_PROC_STATE <= func_in_cond1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: func_in_cond2 (test_cthread_fcall.cpp:663:5) 

// Thread-local variables
logic signed [31:0] l;
logic signed [31:0] l_next;
logic [3:0] par;
logic [3:0] par_next;
logic [1:0] func_in_cond2_PROC_STATE;
logic [1:0] func_in_cond2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : func_in_cond2_comb     // test_cthread_fcall.cpp:663:5
    func_in_cond2_func;
end
function void func_in_cond2_func;
    integer TMP_0;
    integer TMP_1;
    integer TMP_2;
    l_next = l;
    par_next = par;
    func_in_cond2_PROC_STATE_next = func_in_cond2_PROC_STATE;
    
    case (func_in_cond2_PROC_STATE)
        0: begin
            // Call multi_wait_g() begin
            l_next = s0 + 1;
            func_in_cond2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:659:9;
            // Call multi_wait_g() end
        end
        1: begin
            // Call multi_wait_g() begin
            TMP_0 = signed'({1'b0, s0}) + l_next;
            // Call multi_wait_g() end
            if (TMP_0 > 4)
            begin
                func_in_cond2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:669:17;
            end
            func_in_cond2_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:672:13;
        end
        2: begin
            // Call multi_wait_g() begin
            l_next = s0 + 1;
            func_in_cond2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:659:9;
            // Call multi_wait_g() end
        end
        3: begin
            // Call multi_wait_g() begin
            l_next = s0 + 1;
            func_in_cond2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:659:9;
            // Call multi_wait_g() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : func_in_cond2_ff
    if ( ~arstn ) begin
        func_in_cond2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:665:9;
    end
    else begin
        l <= l_next;
        par <= par_next;
        func_in_cond2_PROC_STATE <= func_in_cond2_PROC_STATE_next;
    end
end

endmodule



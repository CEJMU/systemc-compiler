//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
);

// SystemC signals
logic clk;
logic arstn;
logic signed [31:0] in;
logic signed [31:0] out;

//------------------------------------------------------------------------------
// Method process: tmp (test_if.cpp:106:5) 

always_comb 
begin : tmp     // test_if.cpp:106:5
    logic b1;
    logic b2;
    integer i;
    b1 = |in;
    b2 = |in;
end

//------------------------------------------------------------------------------
// Method process: tmp1 (test_if.cpp:115:5) 

always_comb 
begin : tmp1     // test_if.cpp:115:5
    logic b1;
    logic b2;
    integer i;
    b1 = |in;
    b2 = |in;
end

//------------------------------------------------------------------------------
// Method process: tmp2 (test_if.cpp:124:5) 

always_comb 
begin : tmp2     // test_if.cpp:124:5
    logic b1;
    integer i;
    b1 = |in;
    i = 0;
end

//------------------------------------------------------------------------------
// Method process: tmp3 (test_if.cpp:134:5) 

always_comb 
begin : tmp3     // test_if.cpp:134:5
    integer n;
    n = 1;
end

//------------------------------------------------------------------------------
// Clocked THREAD: variable_read_in_binaryop (test_if.cpp:143:5) 

// Thread-local variables
logic closeWaLine;
logic closeWaLine_next;

// Next-state combinational logic
always_comb begin : variable_read_in_binaryop_comb     // test_if.cpp:143:5
    variable_read_in_binaryop_func;
end
function void variable_read_in_binaryop_func;
    logic updateLine;
    closeWaLine_next = closeWaLine;
    updateLine = |in;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : variable_read_in_binaryop_ff
    if ( ~arstn ) begin
        closeWaLine <= 0;
    end
    else begin
        closeWaLine <= closeWaLine_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: smem_if_binary_const (test_if.cpp:162:5) 

// Thread-local variables
logic b;
logic b_next;

// Next-state combinational logic
always_comb begin : smem_if_binary_const_comb     // test_if.cpp:162:5
    smem_if_binary_const_func;
end
function void smem_if_binary_const_func;
    b_next = b;
    if (1)
    begin
        b_next = !b_next;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : smem_if_binary_const_ff
    if ( ~arstn ) begin
        b <= 0;
    end
    else begin
        b <= b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: simple_no_wait (test_if.cpp:174:5) 

always_comb 
begin : simple_no_wait     // test_if.cpp:174:5
    integer k;
    k = 0;
    if (|in)
    begin
        k = 1;
        if (|out)
        begin
            k = 2;
        end else begin
            k = 3;
        end
    end else begin
        if (|out)
        begin
            k = 4;
        end
    end
    k = 6;
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_wait (test_if.cpp:197:5) 

// Thread-local variables
logic [2:0] simple_wait_PROC_STATE;
logic [2:0] simple_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : simple_wait_comb     // test_if.cpp:197:5
    simple_wait_func;
end
function void simple_wait_func;
    integer k;
    simple_wait_PROC_STATE_next = simple_wait_PROC_STATE;
    
    case (simple_wait_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                simple_wait_PROC_STATE_next = 1; return;    // test_if.cpp:205:17;
            end else begin
                if (|out)
                begin
                    k = 4;
                    simple_wait_PROC_STATE_next = 3; return;    // test_if.cpp:217:21;
                end
            end
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:221:13;
        end
        1: begin
            if (|out)
            begin
                k = 2;
                simple_wait_PROC_STATE_next = 2; return;    // test_if.cpp:209:21;
            end else begin
                k = 3;
            end
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:221:13;
        end
        2: begin
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:221:13;
        end
        3: begin
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:221:13;
        end
        4: begin
            k = 6;
            if (|in)
            begin
                k = 1;
                simple_wait_PROC_STATE_next = 1; return;    // test_if.cpp:205:17;
            end else begin
                if (|out)
                begin
                    k = 4;
                    simple_wait_PROC_STATE_next = 3; return;    // test_if.cpp:217:21;
                end
            end
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:221:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : simple_wait_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        simple_wait_PROC_STATE <= 0;    // test_if.cpp:200:9;
    end
    else begin
        simple_wait_PROC_STATE <= simple_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait0 (test_if.cpp:226:5) 

// Thread-local variables
logic [1:0] if_stmt_wait0_PROC_STATE;
logic [1:0] if_stmt_wait0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait0_comb     // test_if.cpp:226:5
    if_stmt_wait0_func;
end
function void if_stmt_wait0_func;
    integer k;
    if_stmt_wait0_PROC_STATE_next = if_stmt_wait0_PROC_STATE;
    
    case (if_stmt_wait0_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait0_PROC_STATE_next = 1; return;    // test_if.cpp:234:17;
            end
            k = 2;
            if_stmt_wait0_PROC_STATE_next = 2; return;    // test_if.cpp:238:13;
        end
        1: begin
            k = 2;
            if_stmt_wait0_PROC_STATE_next = 2; return;    // test_if.cpp:238:13;
        end
        2: begin
            k = 3;
            if (|in)
            begin
                k = 1;
                if_stmt_wait0_PROC_STATE_next = 1; return;    // test_if.cpp:234:17;
            end
            k = 2;
            if_stmt_wait0_PROC_STATE_next = 2; return;    // test_if.cpp:238:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait0_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait0_PROC_STATE <= 0;    // test_if.cpp:229:9;
    end
    else begin
        if_stmt_wait0_PROC_STATE <= if_stmt_wait0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait1 (test_if.cpp:244:5) 

// Thread-local variables
logic [1:0] if_stmt_wait1_PROC_STATE;
logic [1:0] if_stmt_wait1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait1_comb     // test_if.cpp:244:5
    if_stmt_wait1_func;
end
function void if_stmt_wait1_func;
    integer k;
    if_stmt_wait1_PROC_STATE_next = if_stmt_wait1_PROC_STATE;
    
    case (if_stmt_wait1_PROC_STATE)
        0: begin
            k = 1;
            if_stmt_wait1_PROC_STATE_next = 1; return;    // test_if.cpp:251:13;
        end
        1: begin
            if (|in)
            begin
                k = 2;
                if_stmt_wait1_PROC_STATE_next = 2; return;    // test_if.cpp:255:17;
            end
            k = 1;
            if_stmt_wait1_PROC_STATE_next = 1; return;    // test_if.cpp:251:13;
        end
        2: begin
            k = 3;
            k = 1;
            if_stmt_wait1_PROC_STATE_next = 1; return;    // test_if.cpp:251:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait1_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait1_PROC_STATE <= 0;    // test_if.cpp:247:9;
    end
    else begin
        if_stmt_wait1_PROC_STATE <= if_stmt_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait2 (test_if.cpp:261:5) 

// Thread-local variables
logic [1:0] if_stmt_wait2_PROC_STATE;
logic [1:0] if_stmt_wait2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait2_comb     // test_if.cpp:261:5
    if_stmt_wait2_func;
end
function void if_stmt_wait2_func;
    integer k;
    if_stmt_wait2_PROC_STATE_next = if_stmt_wait2_PROC_STATE;
    
    case (if_stmt_wait2_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait2_PROC_STATE_next = 1; return;    // test_if.cpp:269:17;
            end else begin
                k = 3;
                if_stmt_wait2_PROC_STATE_next = 2; return;    // test_if.cpp:274:17;
            end
        end
        1: begin
            k = 2;
            if (|in)
            begin
                k = 1;
                if_stmt_wait2_PROC_STATE_next = 1; return;    // test_if.cpp:269:17;
            end else begin
                k = 3;
                if_stmt_wait2_PROC_STATE_next = 2; return;    // test_if.cpp:274:17;
            end
        end
        2: begin
            k = 4;
            if (|in)
            begin
                k = 1;
                if_stmt_wait2_PROC_STATE_next = 1; return;    // test_if.cpp:269:17;
            end else begin
                k = 3;
                if_stmt_wait2_PROC_STATE_next = 2; return;    // test_if.cpp:274:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait2_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait2_PROC_STATE <= 0;    // test_if.cpp:264:9;
    end
    else begin
        if_stmt_wait2_PROC_STATE <= if_stmt_wait2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait2a (test_if.cpp:280:5) 

// Thread-local variables
logic [1:0] if_stmt_wait2a_PROC_STATE;
logic [1:0] if_stmt_wait2a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait2a_comb     // test_if.cpp:280:5
    if_stmt_wait2a_func;
end
function void if_stmt_wait2a_func;
    integer k;
    if_stmt_wait2a_PROC_STATE_next = if_stmt_wait2a_PROC_STATE;
    
    case (if_stmt_wait2a_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait2a_PROC_STATE_next = 1; return;    // test_if.cpp:288:17;
            end else begin
                k = 3;
                if_stmt_wait2a_PROC_STATE_next = 2; return;    // test_if.cpp:293:17;
            end
        end
        1: begin
            k = 2;
            if (|in)
            begin
                k = 1;
                if_stmt_wait2a_PROC_STATE_next = 1; return;    // test_if.cpp:288:17;
            end else begin
                k = 3;
                if_stmt_wait2a_PROC_STATE_next = 2; return;    // test_if.cpp:293:17;
            end
        end
        2: begin
            if (|out)
            begin
                k = 4;
            end
            if (|in)
            begin
                k = 1;
                if_stmt_wait2a_PROC_STATE_next = 1; return;    // test_if.cpp:288:17;
            end else begin
                k = 3;
                if_stmt_wait2a_PROC_STATE_next = 2; return;    // test_if.cpp:293:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait2a_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait2a_PROC_STATE <= 0;    // test_if.cpp:283:9;
    end
    else begin
        if_stmt_wait2a_PROC_STATE <= if_stmt_wait2a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait3 (test_if.cpp:302:5) 

// Thread-local variables
logic [2:0] if_stmt_wait3_PROC_STATE;
logic [2:0] if_stmt_wait3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait3_comb     // test_if.cpp:302:5
    if_stmt_wait3_func;
end
function void if_stmt_wait3_func;
    integer k;
    if_stmt_wait3_PROC_STATE_next = if_stmt_wait3_PROC_STATE;
    
    case (if_stmt_wait3_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait3_PROC_STATE_next = 1; return;    // test_if.cpp:310:17;
            end else begin
                if (|out)
                begin
                    if (out == in)
                    begin
                        k = 4;
                        if_stmt_wait3_PROC_STATE_next = 3; return;    // test_if.cpp:323:25;
                    end
                end
            end
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:329:13;
        end
        1: begin
            if (|out)
            begin
                k = 2;
                if_stmt_wait3_PROC_STATE_next = 2; return;    // test_if.cpp:314:21;
            end else begin
                k = 3;
            end
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:329:13;
        end
        2: begin
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:329:13;
        end
        3: begin
            k = 5;
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:329:13;
        end
        4: begin
            k = 6;
            if (|in)
            begin
                k = 1;
                if_stmt_wait3_PROC_STATE_next = 1; return;    // test_if.cpp:310:17;
            end else begin
                if (|out)
                begin
                    if (out == in)
                    begin
                        k = 4;
                        if_stmt_wait3_PROC_STATE_next = 3; return;    // test_if.cpp:323:25;
                    end
                end
            end
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:329:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait3_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait3_PROC_STATE <= 0;    // test_if.cpp:305:9;
    end
    else begin
        if_stmt_wait3_PROC_STATE <= if_stmt_wait3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for0 (test_if.cpp:335:5) 

// Thread-local variables
logic signed [31:0] k;
logic signed [31:0] k_next;
logic [1:0] if_stmt_wait_for0_PROC_STATE;
logic [1:0] if_stmt_wait_for0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for0_comb     // test_if.cpp:335:5
    if_stmt_wait_for0_func;
end
function void if_stmt_wait_for0_func;
    k_next = k;
    if_stmt_wait_for0_PROC_STATE_next = if_stmt_wait_for0_PROC_STATE;
    
    case (if_stmt_wait_for0_PROC_STATE)
        0: begin
            for (integer i = 0; i < 3; i++)
            begin
                k_next++;
            end
            if (|in)
            begin
                k_next = 1;
                if_stmt_wait_for0_PROC_STATE_next = 1; return;    // test_if.cpp:348:17;
            end
            for (integer i = 0; i < 3; i++)
            begin
                k_next--;
            end
            if (|in)
            begin
                k_next = 2;
                if_stmt_wait_for0_PROC_STATE_next = 2; return;    // test_if.cpp:357:17;
            end
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:360:13;
        end
        1: begin
            for (integer i = 0; i < 3; i++)
            begin
                k_next--;
            end
            if (|in)
            begin
                k_next = 2;
                if_stmt_wait_for0_PROC_STATE_next = 2; return;    // test_if.cpp:357:17;
            end
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:360:13;
        end
        2: begin
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:360:13;
        end
        3: begin
            k_next = 3;
            for (integer i = 0; i < 3; i++)
            begin
                k_next++;
            end
            if (|in)
            begin
                k_next = 1;
                if_stmt_wait_for0_PROC_STATE_next = 1; return;    // test_if.cpp:348:17;
            end
            for (integer i = 0; i < 3; i++)
            begin
                k_next--;
            end
            if (|in)
            begin
                k_next = 2;
                if_stmt_wait_for0_PROC_STATE_next = 2; return;    // test_if.cpp:357:17;
            end
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:360:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for0_ff
    if ( ~arstn ) begin
        k <= 0;
        if_stmt_wait_for0_PROC_STATE <= 0;    // test_if.cpp:338:9;
    end
    else begin
        k <= k_next;
        if_stmt_wait_for0_PROC_STATE <= if_stmt_wait_for0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for1 (test_if.cpp:366:5) 

// Thread-local variables
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic [2:0] if_stmt_wait_for1_PROC_STATE;
logic [2:0] if_stmt_wait_for1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for1_comb     // test_if.cpp:366:5
    if_stmt_wait_for1_func;
end
function void if_stmt_wait_for1_func;
    k_next0 = k0;
    if_stmt_wait_for1_PROC_STATE_next = if_stmt_wait_for1_PROC_STATE;
    
    case (if_stmt_wait_for1_PROC_STATE)
        0: begin
            if (|in)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    k_next0++;
                end
                k_next0 = 1;
                if_stmt_wait_for1_PROC_STATE_next = 1; return;    // test_if.cpp:378:17;
            end else begin
                k_next0 = 4;
                if_stmt_wait_for1_PROC_STATE_next = 4; return;    // test_if.cpp:394:17;
            end
        end
        1: begin
            if (|out)
            begin
                for (integer j = 0; j < 3; j++)
                begin
                    k_next0--;
                end
            end else begin
                k_next0 = 3;
                if_stmt_wait_for1_PROC_STATE_next = 2; return;    // test_if.cpp:386:21;
            end
            k_next0 = 2;
            if_stmt_wait_for1_PROC_STATE_next = 3; return;    // test_if.cpp:389:17;
        end
        2: begin
            k_next0 = 2;
            if_stmt_wait_for1_PROC_STATE_next = 3; return;    // test_if.cpp:389:17;
        end
        3: begin
            k_next0 = 5;
            if (|in)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    k_next0++;
                end
                k_next0 = 1;
                if_stmt_wait_for1_PROC_STATE_next = 1; return;    // test_if.cpp:378:17;
            end else begin
                k_next0 = 4;
                if_stmt_wait_for1_PROC_STATE_next = 4; return;    // test_if.cpp:394:17;
            end
        end
        4: begin
            k_next0 = 6;
            if (|in)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    k_next0++;
                end
                k_next0 = 1;
                if_stmt_wait_for1_PROC_STATE_next = 1; return;    // test_if.cpp:378:17;
            end else begin
                k_next0 = 4;
                if_stmt_wait_for1_PROC_STATE_next = 4; return;    // test_if.cpp:394:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for1_ff
    if ( ~arstn ) begin
        k0 <= 0;
        if_stmt_wait_for1_PROC_STATE <= 0;    // test_if.cpp:369:9;
    end
    else begin
        k0 <= k_next0;
        if_stmt_wait_for1_PROC_STATE <= if_stmt_wait_for1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for2 (test_if.cpp:401:5) 

// Thread-local variables
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [1:0] if_stmt_wait_for2_PROC_STATE;
logic [1:0] if_stmt_wait_for2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for2_comb     // test_if.cpp:401:5
    if_stmt_wait_for2_func;
end
function void if_stmt_wait_for2_func;
    integer k;
    i_next = i;
    if_stmt_wait_for2_PROC_STATE_next = if_stmt_wait_for2_PROC_STATE;
    
    case (if_stmt_wait_for2_PROC_STATE)
        0: begin
            i_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2_PROC_STATE_next = 1; return;    // test_if.cpp:411:21;
            end
            if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:414:17;
        end
        1: begin
            if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:414:17;
        end
        2: begin
            i_next++;
            if (i_next < 3)
            begin
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2_PROC_STATE_next = 1; return;    // test_if.cpp:411:21;
                end
                if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:414:17;
            end
            i_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2_PROC_STATE_next = 1; return;    // test_if.cpp:411:21;
            end
            if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:414:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for2_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait_for2_PROC_STATE <= 0;    // test_if.cpp:404:9;
    end
    else begin
        i <= i_next;
        if_stmt_wait_for2_PROC_STATE <= if_stmt_wait_for2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for2a (test_if.cpp:419:5) 

// Thread-local variables
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] if_stmt_wait_for2a_PROC_STATE;
logic [1:0] if_stmt_wait_for2a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for2a_comb     // test_if.cpp:419:5
    if_stmt_wait_for2a_func;
end
function void if_stmt_wait_for2a_func;
    integer k;
    i_next0 = i0;
    j_next = j;
    if_stmt_wait_for2a_PROC_STATE_next = if_stmt_wait_for2a_PROC_STATE;
    
    case (if_stmt_wait_for2a_PROC_STATE)
        0: begin
            i_next0 = 0;
            j_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:430:25;
            end
            if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:433:21;
        end
        1: begin
            if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:433:21;
        end
        2: begin
            j_next++;
            if (j_next < 3)
            begin
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:430:25;
                end
                if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:433:21;
            end
            i_next0++;
            if (i_next0 < 3)
            begin
                j_next = 0;
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:430:25;
                end
                if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:433:21;
            end
            if_stmt_wait_for2a_PROC_STATE_next = 3; return;    // test_if.cpp:437:13;
        end
        3: begin
            i_next0 = 0;
            j_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:430:25;
            end
            if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:433:21;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for2a_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait_for2a_PROC_STATE <= 0;    // test_if.cpp:422:9;
    end
    else begin
        j <= j_next;
        i0 <= i_next0;
        if_stmt_wait_for2a_PROC_STATE <= if_stmt_wait_for2a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for2b (test_if.cpp:441:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic [2:0] if_stmt_wait_for2b_PROC_STATE;
logic [2:0] if_stmt_wait_for2b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for2b_comb     // test_if.cpp:441:5
    if_stmt_wait_for2b_func;
end
function void if_stmt_wait_for2b_func;
    integer k;
    i_next1 = i1;
    j_next0 = j0;
    if_stmt_wait_for2b_PROC_STATE_next = if_stmt_wait_for2b_PROC_STATE;
    
    case (if_stmt_wait_for2b_PROC_STATE)
        0: begin
            i_next1 = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2b_PROC_STATE_next = 1; return;    // test_if.cpp:451:21;
            end
            j_next0 = 0;
            if (|out)
            begin
                k = 2;
            end else begin
                k = 3;
                if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:459:25;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:461:21;
        end
        1: begin
            j_next0 = 0;
            if (|out)
            begin
                k = 2;
            end else begin
                k = 3;
                if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:459:25;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:461:21;
        end
        2: begin
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:461:21;
        end
        3: begin
            j_next0++;
            if (j_next0 < 3)
            begin
                if (|out)
                begin
                    k = 2;
                end else begin
                    k = 3;
                    if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:459:25;
                end
                if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:461:21;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 4; return;    // test_if.cpp:464:17;
        end
        4: begin
            i_next1++;
            if (i_next1 < 3)
            begin
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2b_PROC_STATE_next = 1; return;    // test_if.cpp:451:21;
                end
                j_next0 = 0;
                if (|out)
                begin
                    k = 2;
                end else begin
                    k = 3;
                    if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:459:25;
                end
                if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:461:21;
            end
            i_next1 = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2b_PROC_STATE_next = 1; return;    // test_if.cpp:451:21;
            end
            j_next0 = 0;
            if (|out)
            begin
                k = 2;
            end else begin
                k = 3;
                if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:459:25;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:461:21;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for2b_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait_for2b_PROC_STATE <= 0;    // test_if.cpp:444:9;
    end
    else begin
        i1 <= i_next1;
        j0 <= j_next0;
        if_stmt_wait_for2b_PROC_STATE <= if_stmt_wait_for2b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_const_prop1 (test_if.cpp:469:5) 

// Next-state combinational logic
always_comb begin : if_stmt_const_prop1_comb     // test_if.cpp:469:5
    if_stmt_const_prop1_func;
end
function void if_stmt_const_prop1_func;
    integer k;
    if (1)
    begin
        k = 1;
    end
    k = 3;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_const_prop1_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_const_prop2 (test_if.cpp:487:5) 

// Next-state combinational logic
always_comb begin : if_stmt_const_prop2_comb     // test_if.cpp:487:5
    if_stmt_const_prop2_func;
end
function void if_stmt_const_prop2_func;
    integer k;
    if (0)
    begin
    end else begin
        k = 2;
    end
    k = 3;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_const_prop2_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
    end
    else begin
    end
end

endmodule



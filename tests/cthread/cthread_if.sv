//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
);

// SystemC signals
logic clk;
logic arstn;
logic signed [31:0] in;
logic signed [31:0] out;

//------------------------------------------------------------------------------
// Method process: tmp (test_if.cpp:99:5) 

always_comb 
begin : tmp     // test_if.cpp:99:5
    logic b1;
    logic b2;
    integer i;
    b1 = |in;
    b2 = |in;
end

//------------------------------------------------------------------------------
// Method process: tmp1 (test_if.cpp:108:5) 

always_comb 
begin : tmp1     // test_if.cpp:108:5
    logic b1;
    logic b2;
    integer i;
    b1 = |in;
    b2 = |in;
end

//------------------------------------------------------------------------------
// Method process: tmp2 (test_if.cpp:117:5) 

always_comb 
begin : tmp2     // test_if.cpp:117:5
    logic b1;
    integer i;
    b1 = |in;
    i = 0;
end

//------------------------------------------------------------------------------
// Method process: tmp3 (test_if.cpp:127:5) 

always_comb 
begin : tmp3     // test_if.cpp:127:5
    integer n;
    n = 1;
end

//------------------------------------------------------------------------------
// Clocked THREAD: variable_read_in_binaryop (test_if.cpp:136:5) 

// Thread-local variables
logic closeWaLine;
logic closeWaLine_next;

// Next-state combinational logic
always_comb begin : variable_read_in_binaryop_comb     // test_if.cpp:136:5
    variable_read_in_binaryop_func;
end
function void variable_read_in_binaryop_func;
    logic updateLine;
    closeWaLine_next = closeWaLine;
    updateLine = |in;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : variable_read_in_binaryop_ff
    if ( ~arstn ) begin
        closeWaLine <= 0;
    end
    else begin
        closeWaLine <= closeWaLine_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: smem_if_binary_const (test_if.cpp:155:5) 

// Thread-local variables
logic b;
logic b_next;

// Next-state combinational logic
always_comb begin : smem_if_binary_const_comb     // test_if.cpp:155:5
    smem_if_binary_const_func;
end
function void smem_if_binary_const_func;
    b_next = b;
    if (1)
    begin
        b_next = !b_next;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : smem_if_binary_const_ff
    if ( ~arstn ) begin
        b <= 0;
    end
    else begin
        b <= b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: simple_no_wait (test_if.cpp:167:5) 

always_comb 
begin : simple_no_wait     // test_if.cpp:167:5
    integer k;
    k = 0;
    if (|in)
    begin
        k = 1;
        if (|out)
        begin
            k = 2;
        end else begin
            k = 3;
        end
    end else begin
        if (|out)
        begin
            k = 4;
        end
    end
    k = 6;
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_wait (test_if.cpp:190:5) 

// Thread-local variables
logic [2:0] simple_wait_PROC_STATE;
logic [2:0] simple_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : simple_wait_comb     // test_if.cpp:190:5
    simple_wait_func;
end
function void simple_wait_func;
    integer k;
    simple_wait_PROC_STATE_next = simple_wait_PROC_STATE;
    
    case (simple_wait_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                simple_wait_PROC_STATE_next = 1; return;    // test_if.cpp:198:17;
            end else begin
                if (|out)
                begin
                    k = 4;
                    simple_wait_PROC_STATE_next = 3; return;    // test_if.cpp:210:21;
                end
            end
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:214:13;
        end
        1: begin
            if (|out)
            begin
                k = 2;
                simple_wait_PROC_STATE_next = 2; return;    // test_if.cpp:202:21;
            end else begin
                k = 3;
            end
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:214:13;
        end
        2: begin
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:214:13;
        end
        3: begin
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:214:13;
        end
        4: begin
            k = 6;
            if (|in)
            begin
                k = 1;
                simple_wait_PROC_STATE_next = 1; return;    // test_if.cpp:198:17;
            end else begin
                if (|out)
                begin
                    k = 4;
                    simple_wait_PROC_STATE_next = 3; return;    // test_if.cpp:210:21;
                end
            end
            simple_wait_PROC_STATE_next = 4; return;    // test_if.cpp:214:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : simple_wait_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        simple_wait_PROC_STATE <= 0;    // test_if.cpp:193:9;
    end
    else begin
        simple_wait_PROC_STATE <= simple_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait0 (test_if.cpp:219:5) 

// Thread-local variables
logic [1:0] if_stmt_wait0_PROC_STATE;
logic [1:0] if_stmt_wait0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait0_comb     // test_if.cpp:219:5
    if_stmt_wait0_func;
end
function void if_stmt_wait0_func;
    integer k;
    if_stmt_wait0_PROC_STATE_next = if_stmt_wait0_PROC_STATE;
    
    case (if_stmt_wait0_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait0_PROC_STATE_next = 1; return;    // test_if.cpp:227:17;
            end
            k = 2;
            if_stmt_wait0_PROC_STATE_next = 2; return;    // test_if.cpp:231:13;
        end
        1: begin
            k = 2;
            if_stmt_wait0_PROC_STATE_next = 2; return;    // test_if.cpp:231:13;
        end
        2: begin
            k = 3;
            if (|in)
            begin
                k = 1;
                if_stmt_wait0_PROC_STATE_next = 1; return;    // test_if.cpp:227:17;
            end
            k = 2;
            if_stmt_wait0_PROC_STATE_next = 2; return;    // test_if.cpp:231:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait0_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait0_PROC_STATE <= 0;    // test_if.cpp:222:9;
    end
    else begin
        if_stmt_wait0_PROC_STATE <= if_stmt_wait0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait1 (test_if.cpp:237:5) 

// Thread-local variables
logic [1:0] if_stmt_wait1_PROC_STATE;
logic [1:0] if_stmt_wait1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait1_comb     // test_if.cpp:237:5
    if_stmt_wait1_func;
end
function void if_stmt_wait1_func;
    integer k;
    if_stmt_wait1_PROC_STATE_next = if_stmt_wait1_PROC_STATE;
    
    case (if_stmt_wait1_PROC_STATE)
        0: begin
            k = 1;
            if_stmt_wait1_PROC_STATE_next = 1; return;    // test_if.cpp:244:13;
        end
        1: begin
            if (|in)
            begin
                k = 2;
                if_stmt_wait1_PROC_STATE_next = 2; return;    // test_if.cpp:248:17;
            end
            k = 1;
            if_stmt_wait1_PROC_STATE_next = 1; return;    // test_if.cpp:244:13;
        end
        2: begin
            k = 3;
            k = 1;
            if_stmt_wait1_PROC_STATE_next = 1; return;    // test_if.cpp:244:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait1_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait1_PROC_STATE <= 0;    // test_if.cpp:240:9;
    end
    else begin
        if_stmt_wait1_PROC_STATE <= if_stmt_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait2 (test_if.cpp:254:5) 

// Thread-local variables
logic [1:0] if_stmt_wait2_PROC_STATE;
logic [1:0] if_stmt_wait2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait2_comb     // test_if.cpp:254:5
    if_stmt_wait2_func;
end
function void if_stmt_wait2_func;
    integer k;
    if_stmt_wait2_PROC_STATE_next = if_stmt_wait2_PROC_STATE;
    
    case (if_stmt_wait2_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait2_PROC_STATE_next = 1; return;    // test_if.cpp:262:17;
            end else begin
                k = 3;
                if_stmt_wait2_PROC_STATE_next = 2; return;    // test_if.cpp:267:17;
            end
        end
        1: begin
            k = 2;
            if (|in)
            begin
                k = 1;
                if_stmt_wait2_PROC_STATE_next = 1; return;    // test_if.cpp:262:17;
            end else begin
                k = 3;
                if_stmt_wait2_PROC_STATE_next = 2; return;    // test_if.cpp:267:17;
            end
        end
        2: begin
            k = 4;
            if (|in)
            begin
                k = 1;
                if_stmt_wait2_PROC_STATE_next = 1; return;    // test_if.cpp:262:17;
            end else begin
                k = 3;
                if_stmt_wait2_PROC_STATE_next = 2; return;    // test_if.cpp:267:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait2_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait2_PROC_STATE <= 0;    // test_if.cpp:257:9;
    end
    else begin
        if_stmt_wait2_PROC_STATE <= if_stmt_wait2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait2a (test_if.cpp:273:5) 

// Thread-local variables
logic [1:0] if_stmt_wait2a_PROC_STATE;
logic [1:0] if_stmt_wait2a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait2a_comb     // test_if.cpp:273:5
    if_stmt_wait2a_func;
end
function void if_stmt_wait2a_func;
    integer k;
    if_stmt_wait2a_PROC_STATE_next = if_stmt_wait2a_PROC_STATE;
    
    case (if_stmt_wait2a_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait2a_PROC_STATE_next = 1; return;    // test_if.cpp:281:17;
            end else begin
                k = 3;
                if_stmt_wait2a_PROC_STATE_next = 2; return;    // test_if.cpp:286:17;
            end
        end
        1: begin
            k = 2;
            if (|in)
            begin
                k = 1;
                if_stmt_wait2a_PROC_STATE_next = 1; return;    // test_if.cpp:281:17;
            end else begin
                k = 3;
                if_stmt_wait2a_PROC_STATE_next = 2; return;    // test_if.cpp:286:17;
            end
        end
        2: begin
            if (|out)
            begin
                k = 4;
            end
            if (|in)
            begin
                k = 1;
                if_stmt_wait2a_PROC_STATE_next = 1; return;    // test_if.cpp:281:17;
            end else begin
                k = 3;
                if_stmt_wait2a_PROC_STATE_next = 2; return;    // test_if.cpp:286:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait2a_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait2a_PROC_STATE <= 0;    // test_if.cpp:276:9;
    end
    else begin
        if_stmt_wait2a_PROC_STATE <= if_stmt_wait2a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait3 (test_if.cpp:295:5) 

// Thread-local variables
logic [2:0] if_stmt_wait3_PROC_STATE;
logic [2:0] if_stmt_wait3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait3_comb     // test_if.cpp:295:5
    if_stmt_wait3_func;
end
function void if_stmt_wait3_func;
    integer k;
    if_stmt_wait3_PROC_STATE_next = if_stmt_wait3_PROC_STATE;
    
    case (if_stmt_wait3_PROC_STATE)
        0: begin
            if (|in)
            begin
                k = 1;
                if_stmt_wait3_PROC_STATE_next = 1; return;    // test_if.cpp:303:17;
            end else begin
                if (|out)
                begin
                    if (out == in)
                    begin
                        k = 4;
                        if_stmt_wait3_PROC_STATE_next = 3; return;    // test_if.cpp:316:25;
                    end
                end
            end
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:322:13;
        end
        1: begin
            if (|out)
            begin
                k = 2;
                if_stmt_wait3_PROC_STATE_next = 2; return;    // test_if.cpp:307:21;
            end else begin
                k = 3;
            end
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:322:13;
        end
        2: begin
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:322:13;
        end
        3: begin
            k = 5;
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:322:13;
        end
        4: begin
            k = 6;
            if (|in)
            begin
                k = 1;
                if_stmt_wait3_PROC_STATE_next = 1; return;    // test_if.cpp:303:17;
            end else begin
                if (|out)
                begin
                    if (out == in)
                    begin
                        k = 4;
                        if_stmt_wait3_PROC_STATE_next = 3; return;    // test_if.cpp:316:25;
                    end
                end
            end
            if_stmt_wait3_PROC_STATE_next = 4; return;    // test_if.cpp:322:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait3_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait3_PROC_STATE <= 0;    // test_if.cpp:298:9;
    end
    else begin
        if_stmt_wait3_PROC_STATE <= if_stmt_wait3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for0 (test_if.cpp:328:5) 

// Thread-local variables
logic signed [31:0] k;
logic signed [31:0] k_next;
logic [1:0] if_stmt_wait_for0_PROC_STATE;
logic [1:0] if_stmt_wait_for0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for0_comb     // test_if.cpp:328:5
    if_stmt_wait_for0_func;
end
function void if_stmt_wait_for0_func;
    k_next = k;
    if_stmt_wait_for0_PROC_STATE_next = if_stmt_wait_for0_PROC_STATE;
    
    case (if_stmt_wait_for0_PROC_STATE)
        0: begin
            for (integer i = 0; i < 3; i++)
            begin
                k_next++;
            end
            if (|in)
            begin
                k_next = 1;
                if_stmt_wait_for0_PROC_STATE_next = 1; return;    // test_if.cpp:341:17;
            end
            for (integer i = 0; i < 3; i++)
            begin
                k_next--;
            end
            if (|in)
            begin
                k_next = 2;
                if_stmt_wait_for0_PROC_STATE_next = 2; return;    // test_if.cpp:350:17;
            end
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:353:13;
        end
        1: begin
            for (integer i = 0; i < 3; i++)
            begin
                k_next--;
            end
            if (|in)
            begin
                k_next = 2;
                if_stmt_wait_for0_PROC_STATE_next = 2; return;    // test_if.cpp:350:17;
            end
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:353:13;
        end
        2: begin
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:353:13;
        end
        3: begin
            k_next = 3;
            for (integer i = 0; i < 3; i++)
            begin
                k_next++;
            end
            if (|in)
            begin
                k_next = 1;
                if_stmt_wait_for0_PROC_STATE_next = 1; return;    // test_if.cpp:341:17;
            end
            for (integer i = 0; i < 3; i++)
            begin
                k_next--;
            end
            if (|in)
            begin
                k_next = 2;
                if_stmt_wait_for0_PROC_STATE_next = 2; return;    // test_if.cpp:350:17;
            end
            if_stmt_wait_for0_PROC_STATE_next = 3; return;    // test_if.cpp:353:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for0_ff
    if ( ~arstn ) begin
        k <= 0;
        if_stmt_wait_for0_PROC_STATE <= 0;    // test_if.cpp:331:9;
    end
    else begin
        k <= k_next;
        if_stmt_wait_for0_PROC_STATE <= if_stmt_wait_for0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for1 (test_if.cpp:359:5) 

// Thread-local variables
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic [2:0] if_stmt_wait_for1_PROC_STATE;
logic [2:0] if_stmt_wait_for1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for1_comb     // test_if.cpp:359:5
    if_stmt_wait_for1_func;
end
function void if_stmt_wait_for1_func;
    k_next0 = k0;
    if_stmt_wait_for1_PROC_STATE_next = if_stmt_wait_for1_PROC_STATE;
    
    case (if_stmt_wait_for1_PROC_STATE)
        0: begin
            if (|in)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    k_next0++;
                end
                k_next0 = 1;
                if_stmt_wait_for1_PROC_STATE_next = 1; return;    // test_if.cpp:371:17;
            end else begin
                k_next0 = 4;
                if_stmt_wait_for1_PROC_STATE_next = 4; return;    // test_if.cpp:387:17;
            end
        end
        1: begin
            if (|out)
            begin
                for (integer j = 0; j < 3; j++)
                begin
                    k_next0--;
                end
            end else begin
                k_next0 = 3;
                if_stmt_wait_for1_PROC_STATE_next = 2; return;    // test_if.cpp:379:21;
            end
            k_next0 = 2;
            if_stmt_wait_for1_PROC_STATE_next = 3; return;    // test_if.cpp:382:17;
        end
        2: begin
            k_next0 = 2;
            if_stmt_wait_for1_PROC_STATE_next = 3; return;    // test_if.cpp:382:17;
        end
        3: begin
            k_next0 = 5;
            if (|in)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    k_next0++;
                end
                k_next0 = 1;
                if_stmt_wait_for1_PROC_STATE_next = 1; return;    // test_if.cpp:371:17;
            end else begin
                k_next0 = 4;
                if_stmt_wait_for1_PROC_STATE_next = 4; return;    // test_if.cpp:387:17;
            end
        end
        4: begin
            k_next0 = 6;
            if (|in)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    k_next0++;
                end
                k_next0 = 1;
                if_stmt_wait_for1_PROC_STATE_next = 1; return;    // test_if.cpp:371:17;
            end else begin
                k_next0 = 4;
                if_stmt_wait_for1_PROC_STATE_next = 4; return;    // test_if.cpp:387:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for1_ff
    if ( ~arstn ) begin
        k0 <= 0;
        if_stmt_wait_for1_PROC_STATE <= 0;    // test_if.cpp:362:9;
    end
    else begin
        k0 <= k_next0;
        if_stmt_wait_for1_PROC_STATE <= if_stmt_wait_for1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for2 (test_if.cpp:394:5) 

// Thread-local variables
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [1:0] if_stmt_wait_for2_PROC_STATE;
logic [1:0] if_stmt_wait_for2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for2_comb     // test_if.cpp:394:5
    if_stmt_wait_for2_func;
end
function void if_stmt_wait_for2_func;
    integer k;
    i_next = i;
    if_stmt_wait_for2_PROC_STATE_next = if_stmt_wait_for2_PROC_STATE;
    
    case (if_stmt_wait_for2_PROC_STATE)
        0: begin
            i_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2_PROC_STATE_next = 1; return;    // test_if.cpp:404:21;
            end
            if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:407:17;
        end
        1: begin
            if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:407:17;
        end
        2: begin
            i_next++;
            if (i_next < 3)
            begin
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2_PROC_STATE_next = 1; return;    // test_if.cpp:404:21;
                end
                if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:407:17;
            end
            i_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2_PROC_STATE_next = 1; return;    // test_if.cpp:404:21;
            end
            if_stmt_wait_for2_PROC_STATE_next = 2; return;    // test_if.cpp:407:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for2_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait_for2_PROC_STATE <= 0;    // test_if.cpp:397:9;
    end
    else begin
        i <= i_next;
        if_stmt_wait_for2_PROC_STATE <= if_stmt_wait_for2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for2a (test_if.cpp:412:5) 

// Thread-local variables
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] if_stmt_wait_for2a_PROC_STATE;
logic [1:0] if_stmt_wait_for2a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for2a_comb     // test_if.cpp:412:5
    if_stmt_wait_for2a_func;
end
function void if_stmt_wait_for2a_func;
    integer k;
    i_next0 = i0;
    j_next = j;
    if_stmt_wait_for2a_PROC_STATE_next = if_stmt_wait_for2a_PROC_STATE;
    
    case (if_stmt_wait_for2a_PROC_STATE)
        0: begin
            i_next0 = 0;
            j_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:423:25;
            end
            if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:426:21;
        end
        1: begin
            if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:426:21;
        end
        2: begin
            j_next++;
            if (j_next < 3)
            begin
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:423:25;
                end
                if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:426:21;
            end
            i_next0++;
            if (i_next0 < 3)
            begin
                j_next = 0;
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:423:25;
                end
                if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:426:21;
            end
            if_stmt_wait_for2a_PROC_STATE_next = 3; return;    // test_if.cpp:430:13;
        end
        3: begin
            i_next0 = 0;
            j_next = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2a_PROC_STATE_next = 1; return;    // test_if.cpp:423:25;
            end
            if_stmt_wait_for2a_PROC_STATE_next = 2; return;    // test_if.cpp:426:21;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for2a_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait_for2a_PROC_STATE <= 0;    // test_if.cpp:415:9;
    end
    else begin
        j <= j_next;
        i0 <= i_next0;
        if_stmt_wait_for2a_PROC_STATE <= if_stmt_wait_for2a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_wait_for2b (test_if.cpp:434:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic [2:0] if_stmt_wait_for2b_PROC_STATE;
logic [2:0] if_stmt_wait_for2b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_stmt_wait_for2b_comb     // test_if.cpp:434:5
    if_stmt_wait_for2b_func;
end
function void if_stmt_wait_for2b_func;
    integer k;
    i_next1 = i1;
    j_next0 = j0;
    if_stmt_wait_for2b_PROC_STATE_next = if_stmt_wait_for2b_PROC_STATE;
    
    case (if_stmt_wait_for2b_PROC_STATE)
        0: begin
            i_next1 = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2b_PROC_STATE_next = 1; return;    // test_if.cpp:444:21;
            end
            j_next0 = 0;
            if (|out)
            begin
                k = 2;
            end else begin
                k = 3;
                if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:452:25;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:454:21;
        end
        1: begin
            j_next0 = 0;
            if (|out)
            begin
                k = 2;
            end else begin
                k = 3;
                if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:452:25;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:454:21;
        end
        2: begin
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:454:21;
        end
        3: begin
            j_next0++;
            if (j_next0 < 3)
            begin
                if (|out)
                begin
                    k = 2;
                end else begin
                    k = 3;
                    if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:452:25;
                end
                if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:454:21;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 4; return;    // test_if.cpp:457:17;
        end
        4: begin
            i_next1++;
            if (i_next1 < 3)
            begin
                if (|in)
                begin
                    k = 1;
                    if_stmt_wait_for2b_PROC_STATE_next = 1; return;    // test_if.cpp:444:21;
                end
                j_next0 = 0;
                if (|out)
                begin
                    k = 2;
                end else begin
                    k = 3;
                    if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:452:25;
                end
                if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:454:21;
            end
            i_next1 = 0;
            if (|in)
            begin
                k = 1;
                if_stmt_wait_for2b_PROC_STATE_next = 1; return;    // test_if.cpp:444:21;
            end
            j_next0 = 0;
            if (|out)
            begin
                k = 2;
            end else begin
                k = 3;
                if_stmt_wait_for2b_PROC_STATE_next = 2; return;    // test_if.cpp:452:25;
            end
            if_stmt_wait_for2b_PROC_STATE_next = 3; return;    // test_if.cpp:454:21;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_wait_for2b_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
        if_stmt_wait_for2b_PROC_STATE <= 0;    // test_if.cpp:437:9;
    end
    else begin
        i1 <= i_next1;
        j0 <= j_next0;
        if_stmt_wait_for2b_PROC_STATE <= if_stmt_wait_for2b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_const_prop1 (test_if.cpp:462:5) 

// Next-state combinational logic
always_comb begin : if_stmt_const_prop1_comb     // test_if.cpp:462:5
    if_stmt_const_prop1_func;
end
function void if_stmt_const_prop1_func;
    integer k;
    if (1)
    begin
        k = 1;
    end
    k = 3;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_const_prop1_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_stmt_const_prop2 (test_if.cpp:480:5) 

// Next-state combinational logic
always_comb begin : if_stmt_const_prop2_comb     // test_if.cpp:480:5
    if_stmt_const_prop2_func;
end
function void if_stmt_const_prop2_func;
    integer k;
    if (0)
    begin
    end else begin
        k = 2;
    end
    k = 3;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : if_stmt_const_prop2_ff
    if ( ~arstn ) begin
        integer k;
        k = 0;
    end
    else begin
    end
end

endmodule



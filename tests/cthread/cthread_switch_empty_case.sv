//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
);

// SystemC signals
logic clk;
logic arstn;
logic signed [31:0] out;
logic signed [31:0] in;

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty1 (test_cthread_switch_empty_case.cpp:124:5) 

// Thread-local variables
logic signed [31:0] j;
logic signed [31:0] j_next;
logic test_switch_empty1_PROC_STATE;
logic test_switch_empty1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty1_comb     // test_cthread_switch_empty_case.cpp:124:5
    test_switch_empty1_func;
end
function void test_switch_empty1_func;
    integer i;
    j_next = j;
    test_switch_empty1_PROC_STATE_next = test_switch_empty1_PROC_STATE;
    
    case (test_switch_empty1_PROC_STATE)
        0: begin
            i = j_next;
            case (i)
            0 : begin  // Empty case without break
                j_next = 2;
            end
            1 : begin
                j_next = 2;
            end
            default : begin
                j_next = 3;
            end
            endcase
            test_switch_empty1_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:138:13;
        end
        1: begin
            i = 1;
            i = j_next;
            case (i)
            0 : begin  // Empty case without break
                j_next = 2;
            end
            1 : begin
                j_next = 2;
            end
            default : begin
                j_next = 3;
            end
            endcase
            test_switch_empty1_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:138:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty1_ff
    if ( ~arstn ) begin
        j <= 0;
        test_switch_empty1_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:127:9;
    end
    else begin
        j <= j_next;
        test_switch_empty1_PROC_STATE <= test_switch_empty1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty2 (test_cthread_switch_empty_case.cpp:144:5) 

// Thread-local variables
logic [1:0] test_switch_empty2_PROC_STATE;
logic [1:0] test_switch_empty2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty2_comb     // test_cthread_switch_empty_case.cpp:144:5
    test_switch_empty2_func;
end
function void test_switch_empty2_func;
    integer j;
    integer i;
    test_switch_empty2_PROC_STATE_next = test_switch_empty2_PROC_STATE;
    
    case (test_switch_empty2_PROC_STATE)
        0: begin
            i = 0;
            case (0)
            0 : begin  // Empty case without break
                j = 2;
                test_switch_empty2_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:155:32;
            end
            1 : begin
                j = 2;
                test_switch_empty2_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:155:32;
            end
            default : begin
            end
            endcase
        end
        1: begin
            test_switch_empty2_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:158:13;
        end
        2: begin
            i = 1;
            i = 0;
            case (0)
            0 : begin  // Empty case without break
                j = 2;
                test_switch_empty2_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:155:32;
            end
            1 : begin
                j = 2;
                test_switch_empty2_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:155:32;
            end
            default : begin
            end
            endcase
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty2_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty2_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:147:9;
    end
    else begin
        test_switch_empty2_PROC_STATE <= test_switch_empty2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty2a (test_cthread_switch_empty_case.cpp:163:5) 

// Thread-local variables
logic [1:0] test_switch_empty2a_PROC_STATE;
logic [1:0] test_switch_empty2a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty2a_comb     // test_cthread_switch_empty_case.cpp:163:5
    test_switch_empty2a_func;
end
function void test_switch_empty2a_func;
    integer j;
    test_switch_empty2a_PROC_STATE_next = test_switch_empty2a_PROC_STATE;
    
    case (test_switch_empty2a_PROC_STATE)
        0: begin
            case (in)
            0 : begin  // Empty case without break
                j = 2;
                test_switch_empty2a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:173:32;
            end
            1 : begin
                j = 2;
                test_switch_empty2a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:173:32;
            end
            default : begin
                j = 3;
            end
            endcase
            test_switch_empty2a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:176:13;
        end
        1: begin
            test_switch_empty2a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:176:13;
        end
        2: begin
            case (in)
            0 : begin  // Empty case without break
                j = 2;
                test_switch_empty2a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:173:32;
            end
            1 : begin
                j = 2;
                test_switch_empty2a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:173:32;
            end
            default : begin
                j = 3;
            end
            endcase
            test_switch_empty2a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:176:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty2a_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty2a_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:166:9;
    end
    else begin
        test_switch_empty2a_PROC_STATE <= test_switch_empty2a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty3 (test_cthread_switch_empty_case.cpp:181:5) 

// Thread-local variables
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [1:0] test_switch_empty3_PROC_STATE;
logic [1:0] test_switch_empty3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty3_comb     // test_cthread_switch_empty_case.cpp:181:5
    test_switch_empty3_func;
end
function void test_switch_empty3_func;
    integer j;
    integer k;
    i_next = i;
    test_switch_empty3_PROC_STATE_next = test_switch_empty3_PROC_STATE;
    
    case (test_switch_empty3_PROC_STATE)
        0: begin
            i_next = 0;
            test_switch_empty3_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:189:13;
        end
        1: begin
            case (0)
            0 : begin  // Empty case without break
                j = 2;
                // Call f() begin
                k = 0;
                test_switch_empty3_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:97:9;
                // Call f() end
            end
            1 : begin
                j = 2;
                // Call f() begin
                k = 0;
                test_switch_empty3_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:97:9;
                // Call f() end
            end
            default : begin
            end
            endcase
        end
        2: begin
            // Call f() begin
            k = 1;
            // Call f() end
            i_next = 1;
            i_next = 0;
            test_switch_empty3_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:189:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty3_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty3_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:184:9;
    end
    else begin
        i <= i_next;
        test_switch_empty3_PROC_STATE <= test_switch_empty3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty3a (test_cthread_switch_empty_case.cpp:201:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic [1:0] test_switch_empty3a_PROC_STATE;
logic [1:0] test_switch_empty3a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty3a_comb     // test_cthread_switch_empty_case.cpp:201:5
    test_switch_empty3a_func;
end
function void test_switch_empty3a_func;
    integer k;
    j_next0 = j0;
    test_switch_empty3a_PROC_STATE_next = test_switch_empty3a_PROC_STATE;
    
    case (test_switch_empty3a_PROC_STATE)
        0: begin
            test_switch_empty3a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:208:13;
        end
        1: begin
            case (in)
            0 : begin  // Empty case without break
                j_next0 = 2;
                // Call f() begin
                k = 0;
                test_switch_empty3a_PROC_STATE_next = 3; return;    // test_cthread_switch_empty_case.cpp:97:9;
                // Call f() end
            end
            1 : begin
                j_next0 = 2;
                // Call f() begin
                k = 0;
                test_switch_empty3a_PROC_STATE_next = 3; return;    // test_cthread_switch_empty_case.cpp:97:9;
                // Call f() end
            end
            default : begin
                j_next0 = 3;
                test_switch_empty3a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:214:33;
            end
            endcase
        end
        2: begin
            j_next0++;
            test_switch_empty3a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:208:13;
        end
        3: begin
            // Call f() begin
            k = 1;
            // Call f() end
            j_next0++;
            test_switch_empty3a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:208:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty3a_ff
    if ( ~arstn ) begin
        j0 <= 0;
        test_switch_empty3a_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:204:9;
    end
    else begin
        j0 <= j_next0;
        test_switch_empty3a_PROC_STATE <= test_switch_empty3a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4 (test_cthread_switch_empty_case.cpp:221:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] test_switch_empty4_PROC_STATE;
logic [1:0] test_switch_empty4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4_comb     // test_cthread_switch_empty_case.cpp:221:5
    test_switch_empty4_func;
end
function void test_switch_empty4_func;
    integer j;
    i_next0 = i0;
    test_switch_empty4_PROC_STATE_next = test_switch_empty4_PROC_STATE;
    
    case (test_switch_empty4_PROC_STATE)
        0: begin
            i_next0 = 0;
            test_switch_empty4_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:229:13;
        end
        1: begin
            case (0)
            0 : begin  // Empty case without break
                j = 2;
                if (|in)
                begin
                    test_switch_empty4_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:235:40;
                end
            end
            1 : begin
                j = 2;
                if (|in)
                begin
                    test_switch_empty4_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:235:40;
                end
            end
            default : begin
            end
            endcase
            i_next0 = 1;
            i_next0 = 0;
            test_switch_empty4_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:229:13;
        end
        2: begin
            i_next0 = 1;
            i_next0 = 0;
            test_switch_empty4_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:229:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty4_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:224:9;
    end
    else begin
        i0 <= i_next0;
        test_switch_empty4_PROC_STATE <= test_switch_empty4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4a (test_cthread_switch_empty_case.cpp:243:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic [1:0] test_switch_empty4a_PROC_STATE;
logic [1:0] test_switch_empty4a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4a_comb     // test_cthread_switch_empty_case.cpp:243:5
    test_switch_empty4a_func;
end
function void test_switch_empty4a_func;
    integer j;
    i_next1 = i1;
    test_switch_empty4a_PROC_STATE_next = test_switch_empty4a_PROC_STATE;
    
    case (test_switch_empty4a_PROC_STATE)
        0: begin
            i_next1 = 1;
            test_switch_empty4a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:251:13;
        end
        1: begin
            case (1)
            0 : begin  // Empty case without break
                j = 2;
                if (|in)
                begin
                    test_switch_empty4a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:257:40;
                end
            end
            1 : begin
                j = 2;
                if (|in)
                begin
                    test_switch_empty4a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:257:40;
                end
            end
            default : begin
            end
            endcase
            i_next1 = 1;
            i_next1 = 1;
            test_switch_empty4a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:251:13;
        end
        2: begin
            i_next1 = 1;
            i_next1 = 1;
            test_switch_empty4a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:251:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4a_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty4a_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:246:9;
    end
    else begin
        i1 <= i_next1;
        test_switch_empty4a_PROC_STATE <= test_switch_empty4a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4b (test_cthread_switch_empty_case.cpp:265:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next2;
logic test_switch_empty4b_PROC_STATE;
logic test_switch_empty4b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4b_comb     // test_cthread_switch_empty_case.cpp:265:5
    test_switch_empty4b_func;
end
function void test_switch_empty4b_func;
    integer j;
    i_next2 = i2;
    test_switch_empty4b_PROC_STATE_next = test_switch_empty4b_PROC_STATE;
    
    case (test_switch_empty4b_PROC_STATE)
        0: begin
            i_next2 = 2;
            test_switch_empty4b_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:273:13;
        end
        1: begin
            case (2)
            0 : begin  // Empty case without break
            end
            1 : begin
            end
            default : begin
                j = 3;
            end
            endcase
            i_next2 = 1;
            i_next2 = 2;
            test_switch_empty4b_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:273:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4b_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty4b_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:268:9;
    end
    else begin
        i2 <= i_next2;
        test_switch_empty4b_PROC_STATE <= test_switch_empty4b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4c (test_cthread_switch_empty_case.cpp:287:5) 

// Thread-local variables
logic [1:0] test_switch_empty4c_PROC_STATE;
logic [1:0] test_switch_empty4c_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4c_comb     // test_cthread_switch_empty_case.cpp:287:5
    test_switch_empty4c_func;
end
function void test_switch_empty4c_func;
    integer j;
    integer i;
    test_switch_empty4c_PROC_STATE_next = test_switch_empty4c_PROC_STATE;
    
    case (test_switch_empty4c_PROC_STATE)
        0: begin
            i = 0;
            test_switch_empty4c_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:295:13;
        end
        1: begin
            case (in)
            0 : begin  // Empty case without break
                j = 2;
                if (|in)
                begin
                    test_switch_empty4c_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:301:40;
                end
            end
            1 : begin
                j = 2;
                if (|in)
                begin
                    test_switch_empty4c_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:301:40;
                end
            end
            default : begin
                j = 3;
            end
            endcase
            i = 1;
            i = 0;
            test_switch_empty4c_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:295:13;
        end
        2: begin
            i = 1;
            i = 0;
            test_switch_empty4c_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:295:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4c_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty4c_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:290:9;
    end
    else begin
        test_switch_empty4c_PROC_STATE <= test_switch_empty4c_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4d (test_cthread_switch_empty_case.cpp:310:5) 

// Thread-local variables
logic signed [31:0] j1;
logic signed [31:0] j_next1;
logic signed [31:0] k;
logic signed [31:0] k_next;
logic [1:0] test_switch_empty4d_PROC_STATE;
logic [1:0] test_switch_empty4d_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4d_comb     // test_cthread_switch_empty_case.cpp:310:5
    test_switch_empty4d_func;
end
function void test_switch_empty4d_func;
    integer i;
    j_next1 = j1;
    k_next = k;
    test_switch_empty4d_PROC_STATE_next = test_switch_empty4d_PROC_STATE;
    
    case (test_switch_empty4d_PROC_STATE)
        0: begin
            i = 0;
            test_switch_empty4d_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:318:13;
        end
        1: begin
            case (in)
            0 : begin  // Empty case without break
                j_next1 = 2;
                k_next = 0;
                test_switch_empty4d_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:325:29;
            end
            1 : begin
                j_next1 = 2;
                k_next = 0;
                test_switch_empty4d_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:325:29;
            end
            default : begin
                j_next1 = 3;
            end
            endcase
            i = 1;
            i = 0;
            test_switch_empty4d_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:318:13;
        end
        2: begin
            j_next1++;
            k_next++;
            if (k_next < 2)
            begin
                test_switch_empty4d_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:325:29;
            end
            i = 1;
            i = 0;
            test_switch_empty4d_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:318:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4d_ff
    if ( ~arstn ) begin
        j1 <= 0;
        test_switch_empty4d_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:313:9;
    end
    else begin
        j1 <= j_next1;
        k <= k_next;
        test_switch_empty4d_PROC_STATE <= test_switch_empty4d_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4e (test_cthread_switch_empty_case.cpp:336:5) 

// Thread-local variables
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic test_switch_empty4e_PROC_STATE;
logic test_switch_empty4e_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4e_comb     // test_cthread_switch_empty_case.cpp:336:5
    test_switch_empty4e_func;
end
function void test_switch_empty4e_func;
    k_next0 = k0;
    test_switch_empty4e_PROC_STATE_next = test_switch_empty4e_PROC_STATE;
    
    case (test_switch_empty4e_PROC_STATE)
        0: begin
            case (in)
            0 : begin  // Empty case without break
                k_next0 = 0;
                test_switch_empty4e_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:346:29;
            end
            1 : begin
                k_next0 = 0;
                test_switch_empty4e_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:346:29;
            end
            default : begin
            end
            endcase
            test_switch_empty4e_PROC_STATE_next = 0; return;    // test_cthread_switch_empty_case.cpp:340:13;
        end
        1: begin
            k_next0++;
            if (k_next0 < 2)
            begin
                test_switch_empty4e_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:346:29;
            end
            test_switch_empty4e_PROC_STATE_next = 0; return;    // test_cthread_switch_empty_case.cpp:340:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4e_ff
    if ( ~arstn ) begin
        test_switch_empty4e_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:340:13;
    end
    else begin
        k0 <= k_next0;
        test_switch_empty4e_PROC_STATE <= test_switch_empty4e_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4f (test_cthread_switch_empty_case.cpp:354:5) 

// Thread-local variables
logic signed [31:0] k1;
logic signed [31:0] k_next1;
logic test_switch_empty4f_PROC_STATE;
logic test_switch_empty4f_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4f_comb     // test_cthread_switch_empty_case.cpp:354:5
    test_switch_empty4f_func;
end
function void test_switch_empty4f_func;
    k_next1 = k1;
    test_switch_empty4f_PROC_STATE_next = test_switch_empty4f_PROC_STATE;
    
    case (test_switch_empty4f_PROC_STATE)
        0: begin
            case (in)
            0 : begin  // Empty case without break
                k_next1 = 0;
                test_switch_empty4f_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:364:29;
            end
            1 : begin
                k_next1 = 0;
                test_switch_empty4f_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:364:29;
            end
            2 : begin  // Empty case without break
            end
            default : begin
            end
            endcase
            test_switch_empty4f_PROC_STATE_next = 0; return;    // test_cthread_switch_empty_case.cpp:358:13;
        end
        1: begin
            k_next1++;
            if (k_next1 < 2)
            begin
                test_switch_empty4f_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:364:29;
            end
            test_switch_empty4f_PROC_STATE_next = 0; return;    // test_cthread_switch_empty_case.cpp:358:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4f_ff
    if ( ~arstn ) begin
        test_switch_empty4f_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:358:13;
    end
    else begin
        k1 <= k_next1;
        test_switch_empty4f_PROC_STATE <= test_switch_empty4f_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4g (test_cthread_switch_empty_case.cpp:373:5) 

// Thread-local variables
logic test_switch_empty4g_PROC_STATE;
logic test_switch_empty4g_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4g_comb     // test_cthread_switch_empty_case.cpp:373:5
    test_switch_empty4g_func;
end
function void test_switch_empty4g_func;
    test_switch_empty4g_PROC_STATE_next = test_switch_empty4g_PROC_STATE;
    
    case (test_switch_empty4g_PROC_STATE)
        0: begin
            case (in)
            0 : begin  // Empty case without break
                test_switch_empty4g_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:382:25;
            end
            1 : begin
                test_switch_empty4g_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:382:25;
            end
            default : begin
            end
            endcase
            test_switch_empty4g_PROC_STATE_next = 0; return;    // test_cthread_switch_empty_case.cpp:377:13;
        end
        1: begin
            test_switch_empty4g_PROC_STATE_next = 0; return;    // test_cthread_switch_empty_case.cpp:377:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4g_ff
    if ( ~arstn ) begin
        test_switch_empty4g_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:377:13;
    end
    else begin
        test_switch_empty4g_PROC_STATE <= test_switch_empty4g_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty4i (test_cthread_switch_empty_case.cpp:389:5) 

// Thread-local variables
logic [1:0] test_switch_empty4i_PROC_STATE;
logic [1:0] test_switch_empty4i_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty4i_comb     // test_cthread_switch_empty_case.cpp:389:5
    test_switch_empty4i_func;
end
function void test_switch_empty4i_func;
    integer j;
    integer i;
    test_switch_empty4i_PROC_STATE_next = test_switch_empty4i_PROC_STATE;
    
    case (test_switch_empty4i_PROC_STATE)
        0: begin
            i = 0;
            test_switch_empty4i_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:397:13;
        end
        1: begin
            case (in)
            0 : begin
                j = 1;
            end
            1 : begin  // Empty case without break
                j = 2;
                if (|in)
                begin
                    test_switch_empty4i_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:404:41;
                end
            end
            default : begin
                j = 2;
                if (|in)
                begin
                    test_switch_empty4i_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:404:41;
                end
            end
            endcase
            i = 1;
            i = 0;
            test_switch_empty4i_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:397:13;
        end
        2: begin
            i = 1;
            i = 0;
            test_switch_empty4i_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:397:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty4i_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty4i_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:392:9;
    end
    else begin
        test_switch_empty4i_PROC_STATE <= test_switch_empty4i_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty5 (test_cthread_switch_empty_case.cpp:412:5) 

// Thread-local variables
logic [1:0] test_switch_empty5_PROC_STATE;
logic [1:0] test_switch_empty5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty5_comb     // test_cthread_switch_empty_case.cpp:412:5
    test_switch_empty5_func;
end
function void test_switch_empty5_func;
    integer j;
    integer i;
    integer k;
    test_switch_empty5_PROC_STATE_next = test_switch_empty5_PROC_STATE;
    
    case (test_switch_empty5_PROC_STATE)
        0: begin
            j = 1;
            test_switch_empty5_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:420:13;
        end
        1: begin
            j = 2;
            if (|in)
            begin
                i = j - 1;
                // Call f1() begin
                case (1)
                0 : begin  // Empty case without break
                    k = 2;
                    test_switch_empty5_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:107:21;
                end
                1 : begin
                    k = 2;
                    test_switch_empty5_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:107:21;
                end
                endcase
                k = 3;
                // Call f1() end
            end
            j = 1;
            test_switch_empty5_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:420:13;
        end
        2: begin
            // Call f1() begin
            k = 3;
            // Call f1() end
            j = 1;
            test_switch_empty5_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:420:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty5_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty5_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:415:9;
    end
    else begin
        test_switch_empty5_PROC_STATE <= test_switch_empty5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty5a (test_cthread_switch_empty_case.cpp:429:5) 

// Thread-local variables
logic [1:0] test_switch_empty5a_PROC_STATE;
logic [1:0] test_switch_empty5a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty5a_comb     // test_cthread_switch_empty_case.cpp:429:5
    test_switch_empty5a_func;
end
function void test_switch_empty5a_func;
    integer j;
    integer i;
    integer k;
    test_switch_empty5a_PROC_STATE_next = test_switch_empty5a_PROC_STATE;
    
    case (test_switch_empty5a_PROC_STATE)
        0: begin
            j = 1;
            test_switch_empty5a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:437:13;
        end
        1: begin
            if (|in)
            begin
                i = in;
                // Call f1() begin
                case (i)
                0 : begin  // Empty case without break
                    k = 2;
                    test_switch_empty5a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:107:21;
                end
                1 : begin
                    k = 2;
                    test_switch_empty5a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:107:21;
                end
                endcase
                k = 3;
                // Call f1() end
            end
            j = 1;
            test_switch_empty5a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:437:13;
        end
        2: begin
            // Call f1() begin
            k = 3;
            // Call f1() end
            j = 1;
            test_switch_empty5a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:437:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty5a_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty5a_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:432:9;
    end
    else begin
        test_switch_empty5a_PROC_STATE <= test_switch_empty5a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty6 (test_cthread_switch_empty_case.cpp:446:5) 

// Thread-local variables
logic signed [31:0] j2;
logic signed [31:0] j_next2;
logic signed [31:0] i3;
logic signed [31:0] i_next3;
logic [1:0] test_switch_empty6_PROC_STATE;
logic [1:0] test_switch_empty6_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty6_comb     // test_cthread_switch_empty_case.cpp:446:5
    test_switch_empty6_func;
end
function void test_switch_empty6_func;
    integer TMP_0;
    integer TMP_1;
    i_next3 = i3;
    j_next2 = j2;
    test_switch_empty6_PROC_STATE_next = test_switch_empty6_PROC_STATE;
    
    case (test_switch_empty6_PROC_STATE)
        0: begin
            i_next3 = j_next2;
            // Call f2() begin
            case (i_next3)
            0 : begin  // Empty case without break
                test_switch_empty6_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            1 : begin
                test_switch_empty6_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            default : begin
                TMP_0 = i_next3;
            end
            endcase
            // Call f2() end
            j_next2 = TMP_0;
            test_switch_empty6_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:454:13;
        end
        1: begin
            // Call f2() begin
            TMP_0 = i_next3 + 2;
            // Call f2() end
            j_next2 = TMP_0;
            test_switch_empty6_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:454:13;
        end
        2: begin
            i_next3 = j_next2;
            // Call f2() begin
            case (i_next3)
            0 : begin  // Empty case without break
                test_switch_empty6_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            1 : begin
                test_switch_empty6_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            default : begin
                TMP_1 = i_next3;
            end
            endcase
            // Call f2() end
            j_next2 = TMP_1;
            test_switch_empty6_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:454:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty6_ff
    if ( ~arstn ) begin
        j2 <= 0;
        test_switch_empty6_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:449:9;
    end
    else begin
        j2 <= j_next2;
        i3 <= i_next3;
        test_switch_empty6_PROC_STATE <= test_switch_empty6_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_switch_empty6a (test_cthread_switch_empty_case.cpp:458:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next4;
logic [1:0] test_switch_empty6a_PROC_STATE;
logic [1:0] test_switch_empty6a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_switch_empty6a_comb     // test_cthread_switch_empty_case.cpp:458:5
    test_switch_empty6a_func;
end
function void test_switch_empty6a_func;
    integer j;
    integer TMP_0;
    integer TMP_1;
    i_next4 = i4;
    test_switch_empty6a_PROC_STATE_next = test_switch_empty6a_PROC_STATE;
    
    case (test_switch_empty6a_PROC_STATE)
        0: begin
            i_next4 = in;
            // Call f2() begin
            case (i_next4)
            0 : begin  // Empty case without break
                test_switch_empty6a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            1 : begin
                test_switch_empty6a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            default : begin
                TMP_0 = i_next4;
            end
            endcase
            // Call f2() end
            j = TMP_0;
            test_switch_empty6a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:466:13;
        end
        1: begin
            // Call f2() begin
            TMP_0 = i_next4 + 2;
            // Call f2() end
            j = TMP_0;
            test_switch_empty6a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:466:13;
        end
        2: begin
            i_next4 = in;
            // Call f2() begin
            case (i_next4)
            0 : begin  // Empty case without break
                test_switch_empty6a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            1 : begin
                test_switch_empty6a_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:117:21;
            end
            default : begin
                TMP_1 = i_next4;
            end
            endcase
            // Call f2() end
            j = TMP_1;
            test_switch_empty6a_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:466:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_switch_empty6a_ff
    if ( ~arstn ) begin
        integer j;
        j = 0;
        test_switch_empty6a_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:461:9;
    end
    else begin
        i4 <= i_next4;
        test_switch_empty6a_PROC_STATE <= test_switch_empty6a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread (test_cthread_switch_empty_case.cpp:470:5) 

// Thread-local variables
logic signed [31:0] out_next;
logic [2:0] test_thread_PROC_STATE;
logic [2:0] test_thread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_comb     // test_cthread_switch_empty_case.cpp:470:5
    test_thread_func;
end
function void test_thread_func;
    out_next = out;
    test_thread_PROC_STATE_next = test_thread_PROC_STATE;
    
    case (test_thread_PROC_STATE)
        0: begin
            case (in)
            0 : begin  // Empty case without break
                out_next = 10;
            end
            1 : begin
                out_next = 10;
            end
            2 : begin
                out_next = 10;
                out_next = 11;
            end
            3 : begin  // Empty case without break
                out_next = 13;
            end
            default : begin
                out_next = 13;
            end
            endcase
            case (in)
            0 : begin  // Empty case without break
                test_thread_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:496:17;
            end
            1 : begin
                test_thread_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:496:17;
            end
            default : begin
                test_thread_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:502:17;
            end
            endcase
        end
        1: begin
            test_thread_PROC_STATE_next = 4; return;    // test_cthread_switch_empty_case.cpp:506:13;
        end
        2: begin
            out_next = 2;
            test_thread_PROC_STATE_next = 3; return;    // test_cthread_switch_empty_case.cpp:498:17;
        end
        3: begin
            test_thread_PROC_STATE_next = 4; return;    // test_cthread_switch_empty_case.cpp:506:13;
        end
        4: begin
            case (in)
            0 : begin  // Empty case without break
                out_next = 10;
            end
            1 : begin
                out_next = 10;
            end
            2 : begin
                out_next = 10;
                out_next = 11;
            end
            3 : begin  // Empty case without break
                out_next = 13;
            end
            default : begin
                out_next = 13;
            end
            endcase
            case (in)
            0 : begin  // Empty case without break
                test_thread_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:496:17;
            end
            1 : begin
                test_thread_PROC_STATE_next = 2; return;    // test_cthread_switch_empty_case.cpp:496:17;
            end
            default : begin
                test_thread_PROC_STATE_next = 1; return;    // test_cthread_switch_empty_case.cpp:502:17;
            end
            endcase
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_PROC_STATE <= 0;    // test_cthread_switch_empty_case.cpp:473:9;
    end
    else begin
        out <= out_next;
        test_thread_PROC_STATE <= test_thread_PROC_STATE_next;
    end
end

endmodule



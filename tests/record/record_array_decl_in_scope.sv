//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
);

// SystemC signals
logic clk;


//------------------------------------------------------------------------------

A a_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_array_decl_in_scope.cpp:327:5)
//
module A // "b_mod.a_mod"
(
    input logic clk
);

// SystemC signals
logic nrst;
logic signed [31:0] sig;

//------------------------------------------------------------------------------
// Method process: rec_arr_if_meth (test_array_decl_in_scope.cpp:68:5) 

always_comb 
begin : rec_arr_if_meth     // test_array_decl_in_scope.cpp:68:5
    integer i;
    logic signed [1:0] s_a;
    logic [3:0] s_b;
    logic TMP_0;
    logic signed [1:0] par_a;
    logic [3:0] par_b;
    logic signed [1:0] r_a[3];
    logic [3:0] r_b[3];
    i = sig;
    if (i == 1)
    begin
        s_a = 0;
        s_b = 0;
        s_a = 1;
        s_b = i + 1;
        par_a = s_a; par_b = s_b;
        // Call f1() begin
        TMP_0 = par_a > par_b;
        // Call f1() end
        if (TMP_0)
        begin
            r_a[s_b] = s_a++;
        end
    end
end

//------------------------------------------------------------------------------
// Method process: rec_arr_loop_meth (test_array_decl_in_scope.cpp:86:5) 

always_comb 
begin : rec_arr_loop_meth     // test_array_decl_in_scope.cpp:86:5
    integer i;
    logic signed [1:0] s_a[3];
    logic [3:0] s_b[3];
    integer unsigned k;
    i = 0;
    while (i < 10)
    begin
        s_a[2] = i;
        k = 0;
        for (integer j = 0; j < 3; j++)
        begin
            s_b[j] = s_a[j] + j;
        end
        i++;
    end
end

//------------------------------------------------------------------------------
// Method process: rec_arr_compl_meth (test_array_decl_in_scope.cpp:102:5) 

always_comb 
begin : rec_arr_compl_meth     // test_array_decl_in_scope.cpp:102:5
    logic signed [1:0] s_a[3];
    logic [3:0] s_b[3];
    logic signed [1:0] r_a[3];
    logic [3:0] r_b[3];
    logic signed [1:0] s_a_1;
    logic [3:0] s_b_1;
    for (integer i = 0; i < 3; i++)
    begin
        s_b[i] = i;
        for (integer j = 0; j < 3; j++)
        begin
            if (i == j)
            begin
                r_a[1] = s_a[j]; r_b[1] = s_b[j];
                s_a_1 = 0;
                s_b_1 = 0;
                s_a_1 = j;
            end
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_if_thread_comb (test_array_decl_in_scope.cpp:123:5) 

// Thread-local variables
logic signed [31:0] i;
logic signed [31:0] i_next;
logic rec_arr_if_thread_comb_PROC_STATE;
logic rec_arr_if_thread_comb_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_if_thread_comb_comb     // test_array_decl_in_scope.cpp:123:5
    rec_arr_if_thread_comb_func;
end
function void rec_arr_if_thread_comb_func;
    logic signed [1:0] s_a;
    logic [3:0] s_b;
    logic TMP_0;
    logic signed [1:0] par_a;
    logic [3:0] par_b;
    logic signed [1:0] r_a[3];
    logic [3:0] r_b[3];
    logic TMP_1;
    i_next = i;
    rec_arr_if_thread_comb_PROC_STATE_next = rec_arr_if_thread_comb_PROC_STATE;
    
    case (rec_arr_if_thread_comb_PROC_STATE)
        0: begin
            if (i_next == 1)
            begin
                s_a = 0;
                s_b = 0;
                s_b = i_next + 1;
                par_a = s_a; par_b = s_b;
                // Call f1() begin
                TMP_0 = par_a > par_b;
                // Call f1() end
                if (TMP_0)
                begin
                    r_a[i_next] = s_a;
                end
            end
            rec_arr_if_thread_comb_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:138:13;
        end
        1: begin
            i_next++;
            if (i_next == 1)
            begin
                s_a = 0;
                s_b = 0;
                s_b = i_next + 1;
                par_a = s_a; par_b = s_b;
                // Call f1() begin
                TMP_1 = par_a > par_b;
                // Call f1() end
                if (TMP_1)
                begin
                    r_a[i_next] = s_a;
                end
            end
            rec_arr_if_thread_comb_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:138:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_if_thread_comb_ff
    if ( ~nrst ) begin
        i <= sig;
        rec_arr_if_thread_comb_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:126:9;
    end
    else begin
        i <= i_next;
        rec_arr_if_thread_comb_PROC_STATE <= rec_arr_if_thread_comb_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_if_thread_reg (test_array_decl_in_scope.cpp:145:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] rec_if_thread_reg_PROC_STATE;
logic [1:0] rec_if_thread_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_if_thread_reg_comb     // test_array_decl_in_scope.cpp:145:5
    rec_if_thread_reg_func;
end
function void rec_if_thread_reg_func;
    logic signed [1:0] r_a;
    logic [3:0] r_b;
    i_next0 = i0;
    rec_if_thread_reg_PROC_STATE_next = rec_if_thread_reg_PROC_STATE;
    
    case (rec_if_thread_reg_PROC_STATE)
        0: begin
            if (|i_next0)
            begin
                r_a = 0;
                r_b = 0;
                rec_if_thread_reg_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:154:17;
            end
            rec_if_thread_reg_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:158:13;
        end
        1: begin
            r_a = 1;
            rec_if_thread_reg_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:158:13;
        end
        2: begin
            if (|i_next0)
            begin
                r_a = 0;
                r_b = 0;
                rec_if_thread_reg_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:154:17;
            end
            rec_if_thread_reg_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:158:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_if_thread_reg_ff
    if ( ~nrst ) begin
        i0 <= sig;
        rec_if_thread_reg_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:148:9;
    end
    else begin
        i0 <= i_next0;
        rec_if_thread_reg_PROC_STATE <= rec_if_thread_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_if_thread_reg2 (test_array_decl_in_scope.cpp:164:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic [1:0] rec_if_thread_reg2_PROC_STATE;
logic [1:0] rec_if_thread_reg2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_if_thread_reg2_comb     // test_array_decl_in_scope.cpp:164:5
    rec_if_thread_reg2_func;
end
function void rec_if_thread_reg2_func;
    logic signed [1:0] r_a;
    logic [3:0] r_b;
    i_next1 = i1;
    rec_if_thread_reg2_PROC_STATE_next = rec_if_thread_reg2_PROC_STATE;
    
    case (rec_if_thread_reg2_PROC_STATE)
        0: begin
            if (|i_next1)
            begin
                r_a = 0;
                r_b = 0;
                rec_if_thread_reg2_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:173:17;
            end
            rec_if_thread_reg2_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:181:13;
        end
        1: begin
            if (|i_next1)
            begin
                i_next1++;
            end
            r_a = 1;
            rec_if_thread_reg2_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:181:13;
        end
        2: begin
            if (|i_next1)
            begin
                r_a = 0;
                r_b = 0;
                rec_if_thread_reg2_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:173:17;
            end
            rec_if_thread_reg2_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:181:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_if_thread_reg2_ff
    if ( ~nrst ) begin
        i1 <= sig;
        rec_if_thread_reg2_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:167:9;
    end
    else begin
        i1 <= i_next1;
        rec_if_thread_reg2_PROC_STATE <= rec_if_thread_reg2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_if_thread_reg (test_array_decl_in_scope.cpp:187:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next2;
logic signed [1:0] r_a[3];
logic signed [1:0] r_a_next[3];
logic [3:0] r_b[3];
logic [3:0] r_b_next[3];
logic signed [1:0] s_a;
logic signed [1:0] s_a_next;
logic [3:0] s_b;
logic [3:0] s_b_next;
logic [1:0] rec_arr_if_thread_reg_PROC_STATE;
logic [1:0] rec_arr_if_thread_reg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_if_thread_reg_comb     // test_array_decl_in_scope.cpp:187:5
    rec_arr_if_thread_reg_func;
end
function void rec_arr_if_thread_reg_func;
    i_next2 = i2;
    r_a_next = r_a;
    r_b_next = r_b;
    s_a_next = s_a;
    s_b_next = s_b;
    rec_arr_if_thread_reg_PROC_STATE_next = rec_arr_if_thread_reg_PROC_STATE;
    
    case (rec_arr_if_thread_reg_PROC_STATE)
        0: begin
            if (i_next2 == 1)
            begin
                s_a_next = 0;
                s_b_next = 0;
                s_b_next = i_next2 + 1;
                if (i_next2 == 2)
                begin
                    i_next2 = r_b_next[i_next2];
                    rec_arr_if_thread_reg_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:201:21;
                end
                rec_arr_if_thread_reg_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:203:17;
            end
            rec_arr_if_thread_reg_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:207:13;
        end
        1: begin
            rec_arr_if_thread_reg_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:203:17;
        end
        2: begin
            r_a_next[i_next2] = s_a_next;
            rec_arr_if_thread_reg_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:207:13;
        end
        3: begin
            if (i_next2 == 1)
            begin
                s_a_next = 0;
                s_b_next = 0;
                s_b_next = i_next2 + 1;
                if (i_next2 == 2)
                begin
                    i_next2 = r_b_next[i_next2];
                    rec_arr_if_thread_reg_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:201:21;
                end
                rec_arr_if_thread_reg_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:203:17;
            end
            rec_arr_if_thread_reg_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:207:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_if_thread_reg_ff
    if ( ~nrst ) begin
        i2 <= sig;
        rec_arr_if_thread_reg_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:190:9;
    end
    else begin
        i2 <= i_next2;
        r_a <= r_a_next;
        r_b <= r_b_next;
        s_a <= s_a_next;
        s_b <= s_b_next;
        rec_arr_if_thread_reg_PROC_STATE <= rec_arr_if_thread_reg_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_if_thread_reg2 (test_array_decl_in_scope.cpp:212:5) 

// Thread-local variables
logic signed [31:0] i3;
logic signed [31:0] i_next3;
logic signed [1:0] e_a[3];
logic signed [1:0] e_a_next[3];
logic [3:0] e_b[3];
logic [3:0] e_b_next[3];
logic signed [1:0] f_a[3];
logic signed [1:0] f_a_next[3];
logic [3:0] f_b[3];
logic [3:0] f_b_next[3];
logic [2:0] rec_arr_if_thread_reg2_PROC_STATE;
logic [2:0] rec_arr_if_thread_reg2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_if_thread_reg2_comb     // test_array_decl_in_scope.cpp:212:5
    rec_arr_if_thread_reg2_func;
end
function void rec_arr_if_thread_reg2_func;
    logic signed [1:0] d_a[3];
    logic [3:0] d_b[3];
    e_a_next = e_a;
    e_b_next = e_b;
    f_a_next = f_a;
    f_b_next = f_b;
    i_next3 = i3;
    rec_arr_if_thread_reg2_PROC_STATE_next = rec_arr_if_thread_reg2_PROC_STATE;
    
    case (rec_arr_if_thread_reg2_PROC_STATE)
        0: begin
            if (i_next3 == 1)
            begin
                rec_arr_if_thread_reg2_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:222:17;
            end else begin
                f_a_next[1] = e_a_next[2]; f_b_next[1] = e_b_next[2];
                rec_arr_if_thread_reg2_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:230:17;
            end
        end
        1: begin
            i_next3++;
            if (i_next3 == 1)
            begin
                rec_arr_if_thread_reg2_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:222:17;
            end else begin
                f_a_next[1] = e_a_next[2]; f_b_next[1] = e_b_next[2];
                rec_arr_if_thread_reg2_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:230:17;
            end
        end
        2: begin
            if (i_next3 == 2)
            begin
                i_next3 = f_a_next[i_next3];
            end else begin
                rec_arr_if_thread_reg2_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:236:21;
            end
            rec_arr_if_thread_reg2_PROC_STATE_next = 4; return;    // test_array_decl_in_scope.cpp:239:17;
        end
        3: begin
            rec_arr_if_thread_reg2_PROC_STATE_next = 4; return;    // test_array_decl_in_scope.cpp:239:17;
        end
        4: begin
            i_next3 = e_b_next[i_next3 + 1];
            if (i_next3 == 1)
            begin
                rec_arr_if_thread_reg2_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:222:17;
            end else begin
                f_a_next[1] = e_a_next[2]; f_b_next[1] = e_b_next[2];
                rec_arr_if_thread_reg2_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:230:17;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_if_thread_reg2_ff
    if ( ~nrst ) begin
        i3 <= sig;
        rec_arr_if_thread_reg2_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:215:9;
    end
    else begin
        i3 <= i_next3;
        e_a <= e_a_next;
        e_b <= e_b_next;
        f_a <= f_a_next;
        f_b <= f_b_next;
        rec_arr_if_thread_reg2_PROC_STATE <= rec_arr_if_thread_reg2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_if_loop_thread (test_array_decl_in_scope.cpp:246:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next4;
logic signed [1:0] g_a[3];
logic signed [1:0] g_a_next[3];
logic [3:0] g_b[3];
logic [3:0] g_b_next[3];
logic [1:0] rec_arr_if_loop_thread_PROC_STATE;
logic [1:0] rec_arr_if_loop_thread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_if_loop_thread_comb     // test_array_decl_in_scope.cpp:246:5
    rec_arr_if_loop_thread_func;
end
function void rec_arr_if_loop_thread_func;
    g_a_next = g_a;
    g_b_next = g_b;
    i_next4 = i4;
    rec_arr_if_loop_thread_PROC_STATE_next = rec_arr_if_loop_thread_PROC_STATE;
    
    case (rec_arr_if_loop_thread_PROC_STATE)
        0: begin
            if (!(|sig))
            begin
                rec_arr_if_loop_thread_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:257:17;
            end
            rec_arr_if_loop_thread_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:271:13;
        end
        1: begin
            if (|i_next4)
            begin
                g_a_next[i_next4] = i_next4 + 1;
                rec_arr_if_loop_thread_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:261:21;
            end
            for (integer i = 0; i < 3; i++)
            begin
                g_b_next[i] = i + 1;
            end
            i_next4 = g_a_next[i_next4];
            if (!(|sig))
            begin
                rec_arr_if_loop_thread_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:257:17;
            end
            rec_arr_if_loop_thread_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:271:13;
        end
        2: begin
            for (integer i = 0; i < 3; i++)
            begin
                g_b_next[i] = i + 1;
            end
            i_next4 = g_a_next[i_next4];
            if (!(|sig))
            begin
                rec_arr_if_loop_thread_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:257:17;
            end
            rec_arr_if_loop_thread_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:271:13;
        end
        3: begin
            if (!(|sig))
            begin
                rec_arr_if_loop_thread_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:257:17;
            end
            rec_arr_if_loop_thread_PROC_STATE_next = 3; return;    // test_array_decl_in_scope.cpp:271:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_if_loop_thread_ff
    if ( ~nrst ) begin
        i4 <= sig;
        rec_arr_if_loop_thread_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:249:9;
    end
    else begin
        i4 <= i_next4;
        g_a <= g_a_next;
        g_b <= g_b_next;
        rec_arr_if_loop_thread_PROC_STATE <= rec_arr_if_loop_thread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_if_loop_thread_break (test_array_decl_in_scope.cpp:276:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next5;
logic signed [1:0] h_a[3];
logic signed [1:0] h_a_next[3];
logic [3:0] h_b[3];
logic [3:0] h_b_next[3];
logic [1:0] rec_arr_if_loop_thread_break_PROC_STATE;
logic [1:0] rec_arr_if_loop_thread_break_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_if_loop_thread_break_comb     // test_array_decl_in_scope.cpp:276:5
    rec_arr_if_loop_thread_break_func;
end
function void rec_arr_if_loop_thread_break_func;
    logic signed [1:0] m_a[3];
    logic [3:0] m_b[3];
    h_a_next = h_a;
    h_b_next = h_b;
    i_next5 = i5;
    rec_arr_if_loop_thread_break_PROC_STATE_next = rec_arr_if_loop_thread_break_PROC_STATE;
    
    case (rec_arr_if_loop_thread_break_PROC_STATE)
        0: begin
            if (|sig)
            begin
                // break begin
                m_b[i_next5 + 1] = i_next5;
                rec_arr_if_loop_thread_break_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:297:13;
                // break end
            end
            i_next5 = h_a_next[i_next5];
            rec_arr_if_loop_thread_break_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:292:17;
        end
        1: begin
            if (|sig)
            begin
                // break begin
                m_b[i_next5 + 1] = i_next5;
                rec_arr_if_loop_thread_break_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:297:13;
                // break end
            end
            i_next5 = h_a_next[i_next5];
            rec_arr_if_loop_thread_break_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:292:17;
        end
        2: begin
            if (|sig)
            begin
                // break begin
                m_b[i_next5 + 1] = i_next5;
                rec_arr_if_loop_thread_break_PROC_STATE_next = 2; return;    // test_array_decl_in_scope.cpp:297:13;
                // break end
            end
            i_next5 = h_a_next[i_next5];
            rec_arr_if_loop_thread_break_PROC_STATE_next = 1; return;    // test_array_decl_in_scope.cpp:292:17;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_if_loop_thread_break_ff
    if ( ~nrst ) begin
        i5 <= sig;
        rec_arr_if_loop_thread_break_PROC_STATE <= 0;    // test_array_decl_in_scope.cpp:279:9;
    end
    else begin
        i5 <= i_next5;
        h_a <= h_a_next;
        h_b <= h_b_next;
        rec_arr_if_loop_thread_break_PROC_STATE <= rec_arr_if_loop_thread_break_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_if_loop_thread_reset (test_array_decl_in_scope.cpp:302:5) 

// Thread-local variables
logic signed [1:0] n_a[3];
logic signed [1:0] n_a_next[3];
logic [3:0] n_b[3];
logic [3:0] n_b_next[3];
logic signed [31:0] j;
logic signed [31:0] j_next;

// Next-state combinational logic
always_comb begin : rec_arr_if_loop_thread_reset_comb     // test_array_decl_in_scope.cpp:302:5
    rec_arr_if_loop_thread_reset_func;
end
function void rec_arr_if_loop_thread_reset_func;
    j_next = j;
    n_a_next = n_a;
    n_b_next = n_b;
    j_next = n_b_next[j_next];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_if_loop_thread_reset_ff
    if ( ~nrst ) begin
        logic signed [1:0] p_a[3];
        logic [3:0] p_b[3];
        for (integer i = 0; i < 3; i++)
        begin
            n_b[i] <= i;
        end
        j <= sig;
        if (|j)
        begin
            p_b[j] = n_a[1];
        end
    end
    else begin
        n_a <= n_a_next;
        n_b <= n_b_next;
        j <= j_next;
    end
end

endmodule



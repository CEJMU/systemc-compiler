//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);


//------------------------------------------------------------------------------

A a_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_array_unknown_cthread.cpp:139:5)
//
module A // "b_mod.a_mod"
(
    input logic clk
);

// SystemC signals
logic nrst;
logic [3:0] sig;

//------------------------------------------------------------------------------
// Clocked THREAD: copy_rec_arr_elem (test_array_unknown_cthread.cpp:44:5) 

// Thread-local variables
logic signed [1:0] gr_a[2];
logic signed [1:0] gr_a_next[2];
logic [3:0] gr_b[2];
logic [3:0] gr_b_next[2];
logic signed [31:0] j;
logic signed [31:0] j_next;

// Next-state combinational logic
always_comb begin : copy_rec_arr_elem_comb     // test_array_unknown_cthread.cpp:44:5
    copy_rec_arr_elem_func;
end
function void copy_rec_arr_elem_func;
    logic signed [1:0] ar_a[3];
    logic [3:0] ar_b[3];
    gr_a_next = gr_a;
    gr_b_next = gr_b;
    j_next = j;
    ar_a[2] = gr_a_next[1]; ar_b[2] = gr_b_next[1];
    ar_a[j_next] = 0;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : copy_rec_arr_elem_ff
    if ( ~nrst ) begin
        j <= sig;
    end
    else begin
        gr_a <= gr_a_next;
        gr_b <= gr_b_next;
        j <= j_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: copy_rec_arr_elem2 (test_array_unknown_cthread.cpp:58:5) 

// Thread-local variables
logic signed [1:0] ap_a[3];
logic signed [1:0] ap_a_next[3];
logic [3:0] ap_b[3];
logic [3:0] ap_b_next[3];
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [1:0] gp_a[2];
logic [3:0] gp_b[2];
logic copy_rec_arr_elem2_PROC_STATE;
logic copy_rec_arr_elem2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : copy_rec_arr_elem2_comb     // test_array_unknown_cthread.cpp:58:5
    copy_rec_arr_elem2_func;
end
function void copy_rec_arr_elem2_func;
    ap_a_next = ap_a;
    ap_b_next = ap_b;
    j_next0 = j0;
    copy_rec_arr_elem2_PROC_STATE_next = copy_rec_arr_elem2_PROC_STATE;
    
    case (copy_rec_arr_elem2_PROC_STATE)
        0: begin
            copy_rec_arr_elem2_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:64:13;
        end
        1: begin
            gp_a[1] = ap_a_next[2]; gp_b[1] = ap_b_next[2];
            gp_a[j_next0] = 0;
            copy_rec_arr_elem2_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:64:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : copy_rec_arr_elem2_ff
    if ( ~nrst ) begin
        j0 <= sig;
        copy_rec_arr_elem2_PROC_STATE <= 0;    // test_array_unknown_cthread.cpp:61:9;
    end
    else begin
        ap_a <= ap_a_next;
        ap_b <= ap_b_next;
        j0 <= j_next0;
        copy_rec_arr_elem2_PROC_STATE <= copy_rec_arr_elem2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: copy_rec_arr_unknw (test_array_unknown_cthread.cpp:73:5) 

// Thread-local variables
logic signed [1:0] as_a[3];
logic signed [1:0] as_a_next[3];
logic [3:0] as_b[3];
logic [3:0] as_b_next[3];
logic signed [1:0] gs_a[2];
logic [3:0] gs_b[2];
logic copy_rec_arr_unknw_PROC_STATE;
logic copy_rec_arr_unknw_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : copy_rec_arr_unknw_comb     // test_array_unknown_cthread.cpp:73:5
    copy_rec_arr_unknw_func;
end
function void copy_rec_arr_unknw_func;
    integer j;
    as_a_next = as_a;
    as_b_next = as_b;
    copy_rec_arr_unknw_PROC_STATE_next = copy_rec_arr_unknw_PROC_STATE;
    
    case (copy_rec_arr_unknw_PROC_STATE)
        0: begin
            copy_rec_arr_unknw_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:78:13;
        end
        1: begin
            j = sig;
            gs_a[j] = as_a_next[j]; gs_b[j] = as_b_next[j];
            j = as_b_next[j];
            copy_rec_arr_unknw_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:78:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : copy_rec_arr_unknw_ff
    if ( ~nrst ) begin
        copy_rec_arr_unknw_PROC_STATE <= 0;    // test_array_unknown_cthread.cpp:75:9;
    end
    else begin
        as_a <= as_a_next;
        as_b <= as_b_next;
        copy_rec_arr_unknw_PROC_STATE <= copy_rec_arr_unknw_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: copy_rec_arr_unknw2 (test_array_unknown_cthread.cpp:88:5) 

// Thread-local variables
logic signed [1:0] gt_a[2];
logic signed [1:0] gt_a_next[2];
logic [3:0] gt_b[2];
logic [3:0] gt_b_next[2];
logic copy_rec_arr_unknw2_PROC_STATE;
logic copy_rec_arr_unknw2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : copy_rec_arr_unknw2_comb     // test_array_unknown_cthread.cpp:88:5
    copy_rec_arr_unknw2_func;
end
function void copy_rec_arr_unknw2_func;
    logic signed [1:0] at_a[3];
    logic [3:0] at_b[3];
    integer j;
    gt_a_next = gt_a;
    gt_b_next = gt_b;
    copy_rec_arr_unknw2_PROC_STATE_next = copy_rec_arr_unknw2_PROC_STATE;
    
    case (copy_rec_arr_unknw2_PROC_STATE)
        0: begin
            copy_rec_arr_unknw2_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:93:13;
        end
        1: begin
            j = sig;
            at_a[j] = gt_a_next[j]; at_b[j] = gt_b_next[j];
            at_b[j] = gt_a_next[j + 1];
            copy_rec_arr_unknw2_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:93:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : copy_rec_arr_unknw2_ff
    if ( ~nrst ) begin
        copy_rec_arr_unknw2_PROC_STATE <= 0;    // test_array_unknown_cthread.cpp:90:9;
    end
    else begin
        gt_a <= gt_a_next;
        gt_b <= gt_b_next;
        copy_rec_arr_unknw2_PROC_STATE <= copy_rec_arr_unknw2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: copy_rec_arr_unknw3 (test_array_unknown_cthread.cpp:103:5) 

// Thread-local variables
logic signed [1:0] gu_a[2];
logic signed [1:0] gu_a_next[2];
logic [3:0] gu_b[2];
logic [3:0] gu_b_next[2];
logic signed [1:0] au_a[3];
logic signed [1:0] au_a_next[3];
logic [3:0] au_b[3];
logic [3:0] au_b_next[3];
logic copy_rec_arr_unknw3_PROC_STATE;
logic copy_rec_arr_unknw3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : copy_rec_arr_unknw3_comb     // test_array_unknown_cthread.cpp:103:5
    copy_rec_arr_unknw3_func;
end
function void copy_rec_arr_unknw3_func;
    integer j;
    au_a_next = au_a;
    au_b_next = au_b;
    gu_a_next = gu_a;
    gu_b_next = gu_b;
    copy_rec_arr_unknw3_PROC_STATE_next = copy_rec_arr_unknw3_PROC_STATE;
    
    case (copy_rec_arr_unknw3_PROC_STATE)
        0: begin
            copy_rec_arr_unknw3_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:108:13;
        end
        1: begin
            j = sig;
            au_a_next[j] = gu_a_next[j]; au_b_next[j] = gu_b_next[j];
            gu_a_next[0] = au_a_next[j]; gu_b_next[0] = au_b_next[j];
            copy_rec_arr_unknw3_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:108:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : copy_rec_arr_unknw3_ff
    if ( ~nrst ) begin
        copy_rec_arr_unknw3_PROC_STATE <= 0;    // test_array_unknown_cthread.cpp:105:9;
    end
    else begin
        gu_a <= gu_a_next;
        gu_b <= gu_b_next;
        au_a <= au_a_next;
        au_b <= au_b_next;
        copy_rec_arr_unknw3_PROC_STATE <= copy_rec_arr_unknw3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: copy_rec_arr_mult (test_array_unknown_cthread.cpp:118:5) 

// Thread-local variables
logic signed [1:0] guu_a[2][3];
logic signed [1:0] guu_a_next[2][3];
logic [3:0] guu_b[2][3];
logic [3:0] guu_b_next[2][3];
logic copy_rec_arr_mult_PROC_STATE;
logic copy_rec_arr_mult_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : copy_rec_arr_mult_comb     // test_array_unknown_cthread.cpp:118:5
    copy_rec_arr_mult_func;
end
function void copy_rec_arr_mult_func;
    logic signed [1:0] auu_a[2][3];
    logic [3:0] auu_b[2][3];
    integer j;
    guu_a_next = guu_a;
    guu_b_next = guu_b;
    copy_rec_arr_mult_PROC_STATE_next = copy_rec_arr_mult_PROC_STATE;
    
    case (copy_rec_arr_mult_PROC_STATE)
        0: begin
            copy_rec_arr_mult_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:123:13;
        end
        1: begin
            j = sig;
            auu_a[j][0] = guu_a_next[1][j]; auu_b[j][0] = guu_b_next[1][j];
            auu_a[0][j + 1] = guu_a_next[j - 1][2]; auu_b[0][j + 1] = guu_b_next[j - 1][2];
            auu_a[0][j + 1] = j;
            j = guu_b_next[j][j + 1];
            copy_rec_arr_mult_PROC_STATE_next = 1; return;    // test_array_unknown_cthread.cpp:123:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : copy_rec_arr_mult_ff
    if ( ~nrst ) begin
        copy_rec_arr_mult_PROC_STATE <= 0;    // test_array_unknown_cthread.cpp:120:9;
    end
    else begin
        guu_a <= guu_a_next;
        guu_b <= guu_b_next;
        copy_rec_arr_mult_PROC_STATE <= copy_rec_arr_mult_PROC_STATE_next;
    end
end

endmodule



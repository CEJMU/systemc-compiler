//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.20
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] sig;

//------------------------------------------------------------------------------
// Method process: mem_record1 (test_member_record1.cpp:66:5) 

always_comb 
begin : mem_record1     // test_member_record1.cpp:66:5
    integer par;
    logic b_a;
    logic [7:0] b_b;
    integer par_1;
    logic s_a;
    logic [7:0] s_b;
    logic [3:0] s_c;
    logic [63:0] TMP_0;
    integer unsigned c_offset;
    logic [63:0] TMP_1;
    integer unsigned b_offset;
    logic [63:0] TMP_2;
    integer unsigned c_offset_1;
    logic [63:0] TMP_3;
    integer unsigned s_offset;
    logic [63:0] TMP_4;
    integer unsigned s_offset_1;
    integer l;
    par = sig + 1;
    b_b = par;
    par_1 = sig + 2;
    s_b = par_1;
    s_c = 0;
    c_offset = 1;
    // Call getB1() begin
    b_offset = c_offset;
    // Call getB() begin
    TMP_1 = b_b + b_offset;
    // Call getB() end
    TMP_0 = TMP_1;
    // Call getB1() end
    c_offset_1 = 2;
    // Call getB2() begin
    s_offset = c_offset_1;
    // Call getB() begin
    s_offset_1 = s_offset;
    // Call getB() begin
    TMP_4 = s_b + s_offset_1;
    // Call getB() end
    TMP_3 = TMP_4;
    // Call getB() end
    TMP_2 = TMP_3;
    // Call getB2() end
    l = TMP_0 + TMP_2;
    b_a = 1;
    b_b = sig;
    s_b = 42;
    s_c = l;
    l = b_b - s_c;
end

//------------------------------------------------------------------------------
// Clocked THREAD: mem_record2 (test_member_record1.cpp:82:5) 

// Thread-local variables
logic [7:0] b_b0;
logic [7:0] b_b_next;
logic [7:0] mc_b_b;

// Next-state combinational logic
always_comb begin : mem_record2_comb     // test_member_record1.cpp:82:5
    mem_record2_func;
end
function void mem_record2_func;
    integer par;
    integer par_1;
    integer par_2;
    logic [3:0] s_c;
    logic [63:0] TMP_0;
    integer unsigned offset;
    logic [63:0] TMP_1;
    integer unsigned offset_1;
    integer l;
    logic [63:0] TMP_3;
    integer unsigned cc_offset;
    b_b_next = b_b0;
    mc_b_b = sig;
    s_c = mc_b_b;
    offset = 1;
    // Call getB1() begin
    offset_1 = offset;
    // Call getB() begin
    TMP_1 = mc_b_b + offset_1;
    // Call getB() end
    TMP_0 = TMP_1;
    // Call getB1() end
    l = TMP_0;
    cc_offset = 1;
    // Call getB1() begin
    TMP_3 = 13;    // Call of getB()
    // Call getB1() end
    l = TMP_3;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : mem_record2_ff
    if ( ~nrst ) begin
        integer par;
        integer par_1;
        integer par_2;
        logic s_a;
        logic [7:0] s_b;
        logic [3:0] s_c;
        par = 11;
        par_1 = par + 1;
        b_b0 <= par_1;
        par_2 = par + 2;
        s_b = par_2;
        s_c = 0;
        s_a = 0;
    end
    else begin
        b_b0 <= b_b_next;
    end
end

endmodule



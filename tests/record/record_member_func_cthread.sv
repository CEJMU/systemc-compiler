//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.28
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk,
    output logic [3:0] nco_out[3]
);

// Variables generated for SystemC signals
logic rstn;

//------------------------------------------------------------------------------
// Clocked THREAD: func_call_in_reset (test_member_func_cthread.cpp:41:5) 

// Next-state combinational logic
always_comb begin : func_call_in_reset_comb     // test_member_func_cthread.cpp:41:5
    func_call_in_reset_func;
end
function void func_call_in_reset_func;
    integer par_1;
    integer c_1;
    par_1 = 1;
    // Call g() begin
    c_1 = par_1;
    // Call g() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : func_call_in_reset_ff
    if ( ~rstn ) begin
        logic par;
        logic c;
        par = 1;
        // Call f() begin
        c = par;
        // Call f() end
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: call_in_reset (test_member_func_cthread.cpp:74:5) 

// Thread-local variables
logic [3:0] nc_nco_acc;
logic [3:0] nc_nco_acc_next;

// Next-state combinational logic
always_comb begin : call_in_reset_comb     // test_member_func_cthread.cpp:74:5
    call_in_reset_func;
end
function void call_in_reset_func;
    logic [3:0] TMP_0;
    logic [3:0] i;
    nc_nco_acc_next = nc_nco_acc;
    // Call get_acc() begin
    TMP_0 = nc_nco_acc_next;
    // Call get_acc() end
    i = TMP_0;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : call_in_reset_ff
    if ( ~rstn ) begin
        logic [3:0] val;
        val = 0;
        // Call acc_init() begin
        nc_nco_acc <= val;
        // Call acc_init() end
    end
    else begin
        nc_nco_acc <= nc_nco_acc_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: arr_call_in_reset (test_member_func_cthread.cpp:89:5) 

// Thread-local variables
logic [3:0] ncc_nco_acc[3];
logic [3:0] ncc_nco_acc_next[3];
logic [3:0] nco_out_next[3];

// Next-state combinational logic
always_comb begin : arr_call_in_reset_comb     // test_member_func_cthread.cpp:89:5
    arr_call_in_reset_func;
end
function void arr_call_in_reset_func;
    logic [3:0] TMP_0;
    ncc_nco_acc_next = ncc_nco_acc;
    nco_out_next = nco_out;
    for (integer i_1 = 0; i_1 < 3; i_1++)
    begin
        // Call get_acc() begin
        TMP_0 = ncc_nco_acc_next[i_1];
        // Call get_acc() end
        nco_out_next[i_1] = TMP_0 >>> 2;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : arr_call_in_reset_ff
    if ( ~rstn ) begin
        logic [3:0] val;
        for (integer i = 0; i < 3; i++)
        begin
            val = 0;
            // Call acc_init() begin
            ncc_nco_acc[i] <= val;
            // Call acc_init() end
            nco_out[i] <= 0;
        end
    end
    else begin
        ncc_nco_acc <= ncc_nco_acc_next;
        nco_out <= nco_out_next;
    end
end

endmodule



//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// SystemC signals
logic rst;
logic [3:0] sig;

//------------------------------------------------------------------------------
// Clocked THREAD: mult_array_decl (test_member_array_cthread.cpp:106:5) 

// Thread-local variables
logic qarr_a[5][4][3];
logic qarr_a_next[5][4][3];
logic [3:0] qarr_b[5][4][3];
logic [3:0] qarr_b_next[5][4][3];
logic [3:0] parr_b[4][3][2];
logic [3:0] parr_b_next[4][3][2];

// Next-state combinational logic
always_comb begin : mult_array_decl_comb     // test_member_array_cthread.cpp:106:5
    mult_array_decl_func;
end
function void mult_array_decl_func;
    logic aa;
    logic [3:0] bb;
    parr_b_next = parr_b;
    qarr_a_next = qarr_a;
    qarr_b_next = qarr_b;
    aa = qarr_a_next[3][2][1];
    bb = parr_b_next[2][1][0];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : mult_array_decl_ff
    if (rst ) begin
        qarr_b[4][3][2] <= 0;
        parr_b[3][2][1] <= 0;
    end
    else begin
        qarr_a <= qarr_a_next;
        qarr_b <= qarr_b_next;
        parr_b <= parr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl1 (test_member_array_cthread.cpp:124:5) 

// Next-state combinational logic
always_comb begin : loc_array_decl1_comb     // test_member_array_cthread.cpp:124:5
    loc_array_decl1_func;
end
function void loc_array_decl1_func;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl1_ff
    if (rst ) begin
        logic xarr1_a[2][3];
        logic [3:0] xarr1_b[2][3];
        xarr1_b[1][2] = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl2 (test_member_array_cthread.cpp:136:5) 

// Next-state combinational logic
always_comb begin : loc_array_decl2_comb     // test_member_array_cthread.cpp:136:5
    loc_array_decl2_func;
end
function void loc_array_decl2_func;
    logic xarr2_a[2][3];
    logic [3:0] xarr2_b[2][3];
    xarr2_b[1][2] = 0;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl2_ff
    if (rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl3 (test_member_array_cthread.cpp:148:5) 

// Thread-local variables
logic xarr3_a[2][3];
logic xarr3_a_next[2][3];
logic [3:0] xarr3_b[2][3];
logic [3:0] xarr3_b_next[2][3];
logic loc_array_decl3_PROC_STATE;
logic loc_array_decl3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_decl3_comb     // test_member_array_cthread.cpp:148:5
    loc_array_decl3_func;
end
function void loc_array_decl3_func;
    logic [3:0] l;
    xarr3_a_next = xarr3_a;
    xarr3_b_next = xarr3_b;
    loc_array_decl3_PROC_STATE_next = loc_array_decl3_PROC_STATE;
    
    case (loc_array_decl3_PROC_STATE)
        0: begin
            xarr3_b_next[1][2] = 0;
            loc_array_decl3_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:156:13;
        end
        1: begin
            l = xarr3_b_next[1][1];
            xarr3_b_next[1][2] = 0;
            loc_array_decl3_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:156:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl3_ff
    if (rst ) begin
        loc_array_decl3_PROC_STATE <= 0;    // test_member_array_cthread.cpp:150:9;
    end
    else begin
        xarr3_a <= xarr3_a_next;
        xarr3_b <= xarr3_b_next;
        loc_array_decl3_PROC_STATE <= loc_array_decl3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl4 (test_member_array_cthread.cpp:161:5) 

// Thread-local variables
logic xarr4_a[2][3];
logic xarr4_a_next[2][3];
logic [3:0] xarr4_b[2][3];
logic [3:0] xarr4_b_next[2][3];
logic loc_array_decl4_PROC_STATE;
logic loc_array_decl4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_decl4_comb     // test_member_array_cthread.cpp:161:5
    loc_array_decl4_func;
end
function void loc_array_decl4_func;
    logic [3:0] l;
    xarr4_a_next = xarr4_a;
    xarr4_b_next = xarr4_b;
    loc_array_decl4_PROC_STATE_next = loc_array_decl4_PROC_STATE;
    
    case (loc_array_decl4_PROC_STATE)
        0: begin
            xarr4_b_next[1][2] = 0;
            loc_array_decl4_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:169:13;
        end
        1: begin
            l = xarr4_b_next[1][2];
            xarr4_b_next[1][2] = 0;
            loc_array_decl4_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:169:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl4_ff
    if (rst ) begin
        loc_array_decl4_PROC_STATE <= 0;    // test_member_array_cthread.cpp:163:9;
    end
    else begin
        xarr4_a <= xarr4_a_next;
        xarr4_b <= xarr4_b_next;
        loc_array_decl4_PROC_STATE <= loc_array_decl4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl5 (test_member_array_cthread.cpp:176:5) 

// Thread-local variables
logic xlarr5_a[2][3];
logic xlarr5_a_next[2][3];
logic [3:0] xlarr5_b[2][3];
logic [3:0] xlarr5_b_next[2][3];
logic xarr5_a[2][3];
logic xarr5_a_next[2][3];
logic [3:0] xarr5_b[2][3];
logic [3:0] xarr5_b_next[2][3];
logic loc_array_decl5_PROC_STATE;
logic loc_array_decl5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_decl5_comb     // test_member_array_cthread.cpp:176:5
    loc_array_decl5_func;
end
function void loc_array_decl5_func;
    integer j;
    logic [63:0] l;
    xarr5_a_next = xarr5_a;
    xarr5_b_next = xarr5_b;
    xlarr5_a_next = xlarr5_a;
    xlarr5_b_next = xlarr5_b;
    loc_array_decl5_PROC_STATE_next = loc_array_decl5_PROC_STATE;
    
    case (loc_array_decl5_PROC_STATE)
        0: begin
            j = sig;
            xarr5_b_next[1][j] = 0;
            xlarr5_b_next[1][j] = 0;
            loc_array_decl5_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:188:13;
        end
        1: begin
            l = xarr5_b_next[1][2] + xlarr5_b_next[1][2];
            j = sig;
            xarr5_b_next[1][j] = 0;
            xlarr5_b_next[1][j] = 0;
            loc_array_decl5_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:188:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl5_ff
    if (rst ) begin
        loc_array_decl5_PROC_STATE <= 0;    // test_member_array_cthread.cpp:178:9;
    end
    else begin
        xlarr5_a <= xlarr5_a_next;
        xlarr5_b <= xlarr5_b_next;
        xarr5_a <= xarr5_a_next;
        xarr5_b <= xarr5_b_next;
        loc_array_decl5_PROC_STATE <= loc_array_decl5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl6 (test_member_array_cthread.cpp:194:5) 

// Thread-local variables
logic xarr6_a[2][3];
logic xarr6_a_next[2][3];
logic [3:0] xarr6_b[2][3];
logic [3:0] xarr6_b_next[2][3];

// Next-state combinational logic
always_comb begin : loc_array_decl6_comb     // test_member_array_cthread.cpp:194:5
    loc_array_decl6_func;
end
function void loc_array_decl6_func;
    integer j;
    logic [3:0] l;
    xarr6_a_next = xarr6_a;
    xarr6_b_next = xarr6_b;
    j = sig;
    xarr6_b_next[j][2] = 0;
    l = xarr6_b_next[1][2];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl6_ff
    if (rst ) begin
    end
    else begin
        xarr6_a <= xarr6_a_next;
        xarr6_b <= xarr6_b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: loc_array_decl6_meth (test_member_array_cthread.cpp:210:5) 

always_comb 
begin : loc_array_decl6_meth     // test_member_array_cthread.cpp:210:5
    integer j;
    logic xarr6_a[2][3];
    logic [3:0] xarr6_b[2][3];
    logic [3:0] l;
    j = sig;
    xarr6_b[j][2] = 0;
    l = xarr6_b[1][2];
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_copy (test_member_array_cthread.cpp:230:5) 

// Thread-local variables
logic par_a[3];
logic par_a_next[3];
logic [3:0] par_b[3];
logic [3:0] par_b_next[3];
logic [1:0] loc_array_copy_PROC_STATE;
logic [1:0] loc_array_copy_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_copy_comb     // test_member_array_cthread.cpp:230:5
    loc_array_copy_func;
end
function void loc_array_copy_func;
    logic xlarr_a[3];
    logic [3:0] xlarr_b[3];
    integer j;
    logic [3:0] l;
    par_a_next = par_a;
    par_b_next = par_b;
    loc_array_copy_PROC_STATE_next = loc_array_copy_PROC_STATE;
    
    case (loc_array_copy_PROC_STATE)
        0: begin
            xlarr_b[0] = 0; xlarr_b[1] = 0; xlarr_b[2] = 0;
            par_a_next = xlarr_a; par_b_next = xlarr_b;
            // Call rec_param_copy() begin
            j = sig;
            par_b_next[j] = 1;
            loc_array_copy_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:225:9;
            // Call rec_param_copy() end
        end
        1: begin
            // Call rec_param_copy() begin
            l = par_b_next[1];
            // Call rec_param_copy() end
            loc_array_copy_PROC_STATE_next = 2; return;    // test_member_array_cthread.cpp:239:13;
        end
        2: begin
            xlarr_b[0] = 0; xlarr_b[1] = 0; xlarr_b[2] = 0;
            par_a_next = xlarr_a; par_b_next = xlarr_b;
            // Call rec_param_copy() begin
            j = sig;
            par_b_next[j] = 1;
            loc_array_copy_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:225:9;
            // Call rec_param_copy() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_copy_ff
    if (rst ) begin
        loc_array_copy_PROC_STATE <= 0;    // test_member_array_cthread.cpp:232:9;
    end
    else begin
        par_a <= par_a_next;
        par_b <= par_b_next;
        loc_array_copy_PROC_STATE <= loc_array_copy_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_init (test_member_array_cthread.cpp:268:5) 

// Next-state combinational logic
always_comb begin : loc_array_init_comb     // test_member_array_cthread.cpp:268:5
    loc_array_init_func;
end
function void loc_array_init_func;
    logic xarr_a[2][3];
    logic [3:0] xarr_b[2][3];
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_init_ff
    if (rst ) begin
        logic x_a[3];
        logic [3:0] x_b[3];
        logic xarr_a[2][3];
        logic [3:0] xarr_b[2][3];
        x_b[0] = 0; x_b[1] = 0; x_b[2] = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: fcall_array_unknown (test_member_array_cthread.cpp:281:5) 

// Thread-local variables
logic signed [31:0] j;
logic signed [31:0] j_next;
logic yarr_a[2][3];
logic yarr_a_next[2][3];
logic [3:0] yarr_b[2][3];
logic [3:0] yarr_b_next[2][3];

// Next-state combinational logic
always_comb begin : fcall_array_unknown_comb     // test_member_array_cthread.cpp:281:5
    fcall_array_unknown_func;
end
function void fcall_array_unknown_func;
    logic par_a[3];
    logic [3:0] par_b[3];
    logic [3:0] l;
    j_next = j;
    yarr_a_next = yarr_a;
    yarr_b_next = yarr_b;
    par_a = yarr_a_next[j_next]; par_b = yarr_b_next[j_next];
    // Call rec_param0() begin
    l = par_b[0];
    // Call rec_param0() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : fcall_array_unknown_ff
    if (rst ) begin
        j <= sig;
        yarr_a[j][0] <= 0;
    end
    else begin
        j <= j_next;
        yarr_a <= yarr_a_next;
        yarr_b <= yarr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_access (test_member_array_cthread.cpp:302:5) 

// Thread-local variables
logic s_a[3];
logic s_a_next[3];
logic [3:0] s_b[3];
logic [3:0] s_b_next[3];

// Next-state combinational logic
always_comb begin : simple_access_comb     // test_member_array_cthread.cpp:302:5
    simple_access_func;
end
function void simple_access_func;
    integer j;
    logic TMP_0;
    integer i_2;
    s_a_next = s_a;
    s_b_next = s_b;
    j = sig;
    i_2 = j + 1;
    // Call getA() begin
    TMP_0 = s_a_next[i_2];
    // Call getA() end
    s_b_next[j] = TMP_0 ? j : 0;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : simple_access_ff
    if (rst ) begin
        logic par;
        integer i_1;
        for (integer i = 0; i < 3; ++i)
        begin
            par = 0; i_1 = i;
            // Call setA() begin
            s_a[i_1] <= par;
            // Call setA() end
            s_b[i] <= 0;
        end
    end
    else begin
        s_a <= s_a_next;
        s_b <= s_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: array_access (test_member_array_cthread.cpp:324:5) 

// Thread-local variables
logic arr_a[2][3];
logic arr_a_next[2][3];
logic [3:0] arr_b[2][3];
logic [3:0] arr_b_next[2][3];

// Next-state combinational logic
always_comb begin : array_access_comb     // test_member_array_cthread.cpp:324:5
    array_access_func;
end
function void array_access_func;
    integer j_1;
    logic [3:0] l;
    logic TMP_0;
    integer i_2;
    arr_a_next = arr_a;
    arr_b_next = arr_b;
    j_1 = sig;
    l = arr_b_next[j_1][j_1 + 1];
    i_2 = j_1 + 1;
    // Call getA() begin
    TMP_0 = arr_a_next[j_1][i_2];
    // Call getA() end
    arr_b_next[j_1][j_1 + 1] = TMP_0 ? j_1 : 0;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : array_access_ff
    if (rst ) begin
        logic par;
        integer i_1;
        for (integer j = 0; j < 2; ++j)
        begin
            for (integer i = 0; i < 3; ++i)
            begin
                par = 0; i_1 = i;
                // Call setA() begin
                arr_a[j][i_1] <= par;
                // Call setA() end
                arr_b[j][i] <= 0;
            end
        end
    end
    else begin
        arr_a <= arr_a_next;
        arr_b <= arr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_access (test_member_array_cthread.cpp:348:5) 

// Thread-local variables
logic xarr_a[2][3];
logic xarr_a_next[2][3];
logic [3:0] xarr_b[2][3];
logic [3:0] xarr_b_next[2][3];
logic x_a[3];
logic x_a_next[3];
logic [3:0] x_b[3];
logic [3:0] x_b_next[3];

// Next-state combinational logic
always_comb begin : loc_array_access_comb     // test_member_array_cthread.cpp:348:5
    loc_array_access_func;
end
function void loc_array_access_func;
    integer j_1;
    logic [63:0] l;
    logic xarr_par;
    integer xarr_i;
    x_a_next = x_a;
    x_b_next = x_b;
    xarr_a_next = xarr_a;
    xarr_b_next = xarr_b;
    j_1 = sig;
    l = x_b_next[j_1] + xarr_b_next[j_1 + 1][j_1 + 2];
    x_b_next[j_1] = 1;
    xarr_b_next[j_1 + 1][j_1 + 2] = 2;
    xarr_par = 0; xarr_i = 1;
    // Call setA() begin
    xarr_a_next[j_1][xarr_i] = xarr_par;
    // Call setA() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_access_ff
    if (rst ) begin
        x_b[0] <= 0; x_b[1] <= 0; x_b[2] <= 0;
        for (integer i = 0; i < 3; ++i)
        begin
            x_b[i] <= i;
        end
        for (integer j = 0; j < 2; ++j)
        begin
            for (integer k = 0; k < 3; ++k)
            begin
                xarr_b[j][k] <= 0;
            end
        end
    end
    else begin
        xarr_a <= xarr_a_next;
        xarr_b <= xarr_b_next;
        x_a <= x_a_next;
        x_b <= x_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_fcall_param (test_member_array_cthread.cpp:401:5) 

// Thread-local variables
logic vv_a[3];
logic vv_a_next[3];
logic [3:0] vv_b[3];
logic [3:0] vv_b_next[3];
logic v_a[3];
logic v_a_next[3];
logic [3:0] v_b[3];
logic [3:0] v_b_next[3];
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic varr_a[2][3];
logic varr_a_next[2][3];
logic [3:0] varr_b[2][3];
logic [3:0] varr_b_next[2][3];

// Next-state combinational logic
always_comb begin : local_fcall_param_comb     // test_member_array_cthread.cpp:401:5
    local_fcall_param_func;
end
function void local_fcall_param_func;
    integer k;
    logic TMP_0;
    integer varr_i;
    integer i;
    logic TMP_1;
    integer v_i;
    logic par_a[3];
    logic [3:0] par_b[3];
    logic [3:0] l;
    logic par_a_1[3];
    logic [3:0] par_b_1[3];
    integer j;
    logic TMP_2;
    integer par_i;
    logic TMP_3;
    j_next0 = j0;
    v_a_next = v_a;
    v_b_next = v_b;
    varr_a_next = varr_a;
    varr_b_next = varr_b;
    vv_a_next = vv_a;
    vv_b_next = vv_b;
    i = 1;
    // Call rec_param1() begin
    vv_b_next[i] = vv_a_next[i] ? 1 : 2;
    // Call rec_param1() end
    k = 1;
    // Call rec_param2_ref() begin
    v_i = k;
    // Call getA() begin
    TMP_1 = v_a_next[v_i];
    // Call getA() end
    v_b_next[k] = TMP_1 ? 1 : 2;
    // Call rec_param2_ref() end
    par_a = varr_a_next[j_next0]; par_b = varr_b_next[j_next0];
    // Call rec_param0() begin
    l = par_b[0];
    // Call rec_param0() end
    par_a_1 = varr_a_next[j_next0]; par_b_1 = varr_b_next[j_next0]; j = 0;
    // Call rec_param2_val() begin
    par_i = j;
    // Call getA() begin
    TMP_2 = par_a_1[par_i];
    // Call getA() end
    par_b_1[j] = TMP_2 ? 1 : 2;
    // Call rec_param2_val() end
    k = 1;
    // Call rec_param2_ref() begin
    varr_i = k;
    // Call getA() begin
    TMP_3 = varr_a_next[j_next0][varr_i];
    // Call getA() end
    varr_b_next[j_next0][k] = 2;
    // Call rec_param2_ref() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : local_fcall_param_ff
    if (rst ) begin
        integer k;
        logic TMP_0;
        integer varr_i;
        v_b[0] <= 0; v_b[1] <= 0; v_b[2] <= 0;
        for (integer d = 0; d < 2; ++d)
        begin
            for (integer e = 0; e < 3; ++e)
            begin
                varr_a[d][e] <= 0;
            end
        end
        j0 <= sig;
        k = 0;
        // Call rec_param2_ref() begin
        varr_i = k;
        // Call getA() begin
        TMP_0 = varr_a[j0][varr_i];
        // Call getA() end
        varr_b[j0][k] <= 2;
        // Call rec_param2_ref() end
    end
    else begin
        vv_a <= vv_a_next;
        vv_b <= vv_b_next;
        v_a <= v_a_next;
        v_b <= v_b_next;
        j0 <= j_next0;
        varr_a <= varr_a_next;
        varr_b <= varr_b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: local_fcall_param_noinit (test_member_array_cthread.cpp:428:5) 

always_comb 
begin : local_fcall_param_noinit     // test_member_array_cthread.cpp:428:5
    logic varr_a[2][3];
    logic [3:0] varr_b[2][3];
    integer j;
    integer k;
    logic TMP_0;
    integer varr_i;
    j = sig;
    k = 0;
    // Call rec_param2_ref() begin
    varr_i = k;
    // Call getA() begin
    TMP_0 = varr_a[j][varr_i];
    // Call getA() end
    varr_b[j][k] = TMP_0 ? 1 : 2;
    // Call rec_param2_ref() end
end

//------------------------------------------------------------------------------
// Clocked THREAD: fcall_param (test_member_array_cthread.cpp:439:5) 

// Thread-local variables
logic r_a[3];
logic r_a_next[3];
logic [3:0] r_b[3];
logic [3:0] r_b_next[3];
logic par_a0[3];
logic par_a_next0[3];
logic [3:0] par_b0[3];
logic [3:0] par_b_next0[3];
logic rr_a[3];
logic rr_a_next[3];
logic [3:0] rr_b[3];
logic [3:0] rr_b_next[3];
logic rarr_a[2][3];
logic rarr_a_next[2][3];
logic [3:0] rarr_b[2][3];
logic [3:0] rarr_b_next[2][3];

// Next-state combinational logic
always_comb begin : fcall_param_comb     // test_member_array_cthread.cpp:439:5
    fcall_param_func;
end
function void fcall_param_func;
    integer j;
    logic TMP_0;
    integer par_i;
    integer i;
    integer k;
    logic TMP_1;
    integer i_1;
    integer j_1;
    logic par_a[3];
    logic [3:0] par_b[3];
    logic [3:0] l;
    logic TMP_2;
    logic TMP_3;
    integer i_2;
    par_a_next0 = par_a0;
    par_b_next0 = par_b0;
    r_a_next = r_a;
    r_b_next = r_b;
    rarr_a_next = rarr_a;
    rarr_b_next = rarr_b;
    rr_a_next = rr_a;
    rr_b_next = rr_b;
    i = 1;
    // Call rec_param1() begin
    rr_b_next[i] = rr_a_next[i] ? 1 : 2;
    // Call rec_param1() end
    k = 1;
    // Call rec_param2_ref() begin
    i_1 = k;
    // Call getA() begin
    TMP_1 = r_a_next[i_1];
    // Call getA() end
    r_b_next[k] = 2;
    // Call rec_param2_ref() end
    j_1 = sig;
    par_a = rarr_a_next[j_1]; par_b = rarr_b_next[j_1];
    // Call rec_param0() begin
    l = par_b[0];
    // Call rec_param0() end
    par_a_next0 = rarr_a_next[j_1]; par_b_next0 = rarr_b_next[j_1]; j = 0;
    // Call rec_param2_val() begin
    par_i = j;
    // Call getA() begin
    TMP_2 = par_a_next0[par_i];
    // Call getA() end
    par_b_next0[j] = TMP_2 ? 1 : 2;
    // Call rec_param2_val() end
    k = 1;
    // Call rec_param2_ref() begin
    i_2 = k;
    // Call getA() begin
    TMP_3 = rarr_a_next[j_1][i_2];
    // Call getA() end
    rarr_b_next[j_1][k] = TMP_3 ? 1 : 2;
    // Call rec_param2_ref() end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : fcall_param_ff
    if (rst ) begin
        integer j;
        logic TMP_0;
        integer par_i;
        for (integer e = 0; e < 3; ++e)
        begin
            r_a[e] <= 0;
        end
        par_a0 = r_a; par_b0 = r_b; j = 0;
        // Call rec_param2_val() begin
        par_i = j;
        // Call getA() begin
        TMP_0 = par_a0[par_i];
        // Call getA() end
        par_b0[j] <= 2;
        // Call rec_param2_val() end
    end
    else begin
        r_a <= r_a_next;
        r_b <= r_b_next;
        par_a0 <= par_a_next0;
        par_b0 <= par_b_next0;
        rr_a <= rr_a_next;
        rr_b <= rr_b_next;
        rarr_a <= rarr_a_next;
        rarr_b <= rarr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: fcall_return (test_member_array_cthread.cpp:481:5) 

// Thread-local variables
logic z_a[3];
logic z_a_next[3];
logic [3:0] z_b[3];
logic [3:0] z_b_next[3];
logic res_a[3];
logic res_a_next[3];
logic [3:0] res_b[3];
logic [3:0] res_b_next[3];
logic zarr_a[2][3];
logic zarr_a_next[2][3];
logic [3:0] zarr_b[2][3];
logic [3:0] zarr_b_next[2][3];
logic [1:0] fcall_return_PROC_STATE;
logic [1:0] fcall_return_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : fcall_return_comb     // test_member_array_cthread.cpp:481:5
    fcall_return_func;
end
function void fcall_return_func;
    logic TMP_0_a[3];
    logic [3:0] TMP_0_b[3];
    logic par_a_1[3];
    logic [3:0] par_b_1[3];
    logic TMP_1_a[3];
    logic [3:0] TMP_1_b[3];
    logic llrec_a[3];
    logic [3:0] llrec_b[3];
    integer j;
    logic TMP_2_a[3];
    logic [3:0] TMP_2_b[3];
    logic lllrec_a[3];
    logic [3:0] lllrec_b[3];
    res_a_next = res_a;
    res_b_next = res_b;
    z_a_next = z_a;
    z_b_next = z_b;
    zarr_a_next = zarr_a;
    zarr_b_next = zarr_b;
    fcall_return_PROC_STATE_next = fcall_return_PROC_STATE;
    
    case (fcall_return_PROC_STATE)
        0: begin
            par_a_1 = z_a_next; par_b_1 = z_b_next;
            // Call rec_return2() begin
            res_a_next = par_a_1; res_b_next = par_b_1;
            fcall_return_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:473:9;
            // Call rec_return2() end
        end
        1: begin
            // Call rec_return2() begin
            TMP_1_a = res_a_next; TMP_1_b = res_b_next;
            // Call rec_return2() end
            llrec_a = TMP_1_a; llrec_b = TMP_1_b;
            j = sig;
            par_a_1 = zarr_a_next[j]; par_b_1 = zarr_b_next[j];
            // Call rec_return2() begin
            res_a_next = par_a_1; res_b_next = par_b_1;
            fcall_return_PROC_STATE_next = 2; return;    // test_member_array_cthread.cpp:473:9;
            // Call rec_return2() end
        end
        2: begin
            // Call rec_return2() begin
            TMP_2_a = res_a_next; TMP_2_b = res_b_next;
            // Call rec_return2() end
            lllrec_a = TMP_2_a; lllrec_b = TMP_2_b;
            fcall_return_PROC_STATE_next = 3; return;    // test_member_array_cthread.cpp:495:13;
        end
        3: begin
            par_a_1 = z_a_next; par_b_1 = z_b_next;
            // Call rec_return2() begin
            res_a_next = par_a_1; res_b_next = par_b_1;
            fcall_return_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:473:9;
            // Call rec_return2() end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or posedge rst) 
begin : fcall_return_ff
    if (rst ) begin
        logic par_a[3];
        logic [3:0] par_b[3];
        logic TMP_0_a[3];
        logic [3:0] TMP_0_b[3];
        logic lrec_a[3];
        logic [3:0] lrec_b[3];
        for (integer e = 0; e < 3; ++e)
        begin
            z_a[e] <= 0;
            z_b[e] <= 0;
        end
        par_a = z_a; par_b = z_b;
        // Call rec_return1() begin
        TMP_0_a = par_a; TMP_0_b = par_b;
        // Call rec_return1() end
        lrec_a = TMP_0_a; lrec_b = TMP_0_b;
        fcall_return_PROC_STATE <= 0;    // test_member_array_cthread.cpp:487:9;
    end
    else begin
        z_a <= z_a_next;
        z_b <= z_b_next;
        res_a <= res_a_next;
        res_b <= res_b_next;
        zarr_a <= zarr_a_next;
        zarr_b <= zarr_b_next;
        fcall_return_PROC_STATE <= fcall_return_PROC_STATE_next;
    end
end

endmodule



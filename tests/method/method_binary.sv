//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
);

// SystemC signals
logic a;
logic b;
logic c;


//------------------------------------------------------------------------------

A a_mod
(
  .a(a),
  .b(b),
  .c(c)
);

endmodule



//==============================================================================
//
// Module: A (test_binary.cpp:589:5)
//
module A // "b_mod.a_mod"
(
    input logic a,
    output logic b,
    output logic c
);

// SystemC signals
logic clk;
logic rstn;
logic [31:0] s;
logic [65:0] sig;

//------------------------------------------------------------------------------
// Clocked THREAD: syncProc (test_binary.cpp:69:5) 

// Next-state combinational logic
always_comb begin : syncProc_comb     // test_binary.cpp:69:5
    syncProc_func;
end
function void syncProc_func;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge rstn) 
begin : syncProc_ff
    if ( ~rstn ) begin
        sig <= 66'd1 <<< 8'(66 - 1);
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: enumOperation (test_binary.cpp:93:5) 

always_comb 
begin : enumOperation     // test_binary.cpp:93:5
    logic [1:0] uvar;
    logic signed [2:0] ivar;
    logic b_1;
    integer i;
    logic [3:0] x;
    logic signed [3:0] y;
    integer unsigned u;
    logic [16:0] bu;
    logic signed [23:0] bi;
    logic signed [32:0] z;
    uvar = 1;
    ivar = -3'sd2;
    b_1 = 0;
    i = 11;
    x = 1;
    y = -2'sd1;
    u = 1;
    bu = 1;
    bi = -3'sd2;
    z = 0;
    i = b_1 + signed'({1'b0, uvar});
    i = signed'({1'b0, x}) + ivar;
    assert (i == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = x + uvar;
    assert (i == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = (-3'sd2) + signed'({1'b0, uvar});
    assert (i == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = -3'sd2;
    i = i + signed'({1'b0, uvar});
    assert (i == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = -3'sd2;
    i = i + ivar;
    assert (i == -4'sd4) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = u + uvar;
    assert (i == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = signed'({1'b0, u}) + ivar;
    assert (i == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, bu}) + signed'({1'b0, uvar});
    assert (z == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, bu}) + ivar;
    assert (z == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = bi + signed'({1'b0, uvar});
    assert (z == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = bi + ivar;
    assert (z == -4'sd4) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: comma (test_binary.cpp:139:5) 

always_comb 
begin : comma     // test_binary.cpp:139:5
    integer i;
    integer j;
    integer k_1;
    integer TMP_0;
    integer i_1;
    integer i_2;
    i++;
    k_1 = j++;
    j = i + k_1;
    k_1 = j;
    i_1 = 1;
    // Call f() begin
    TMP_0 = i_1 + 1;
    // Call f() end
    j = TMP_0;
    k_1 = j++;
    assert (j == 3) else $error("Assertion failed at test_binary.cpp:59:24>");
    i_2 = 2;
    // Call g() begin
    j = j + i_2;
    // Call g() end
    k_1 = j;
    assert (j == 5) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = 0;
    i = 1;
    k_1 = i + 1;
    assert (i == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
    assert (k_1 == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: shift (test_binary.cpp:156:5) 

// Process-local variables
logic signed [31:0] k;
logic signed [31:0] m;

always_comb 
begin : shift     // test_binary.cpp:156:5
    integer unsigned i;
    logic [3:0] x;
    logic [7:0] y;
    logic [11:0] ii;
    x = 0;
    y = 0;
    i = m <<< 2;
    ii = {x, y} <<< 2;
    i = a >>> 3;
    s = i <<< m;
    k = a <<< s;
    k++;
    b = |(s >>> k);
end

//------------------------------------------------------------------------------
// Method process: sc_type_shift (test_binary.cpp:170:5) 

always_comb 
begin : sc_type_shift     // test_binary.cpp:170:5
    logic [36:0] i;
    logic [38:0] j;
    logic [71:0] x;
    logic [129:0] y;
    integer ii;
    i = 15;
    j = i <<< 2;
    x = 70'(i) <<< 68;
    x = x <<< 70;
    assert (x == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    y = 130'(i) >>> 71;
    assert (y == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    y = x >>> 67;
    assert (y == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    y = x >>> i;
    y = x <<< 32'(j - 1);
    ii = 42;
    y = x <<< 12'(ii);
    y = x <<< 12'(ii);
end

//------------------------------------------------------------------------------
// Method process: compound_assign (test_binary.cpp:190:5) 

// Process-local variables
logic signed [31:0] m;
logic signed [31:0] k;

always_comb 
begin : compound_assign     // test_binary.cpp:190:5
    integer i;
    i = 1;
    i = i + 1;
    m = 1;
    assert (i == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = i - m;
    assert (i == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = i * k;
    i = i / i;
    i = i % (k + m);
    i = i | 2;
    i = i & 3;
    i = i ^ (4 + i);
end

//------------------------------------------------------------------------------
// Method process: compound_assign_brackets (test_binary.cpp:206:5) 

always_comb 
begin : compound_assign_brackets     // test_binary.cpp:206:5
    integer i;
    integer e;
    integer d;
    e = 2;
    d = -3'sd3;
    i = 1;
    i = i * (e + d);
    assert (i == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = 12;
    i = i / (e - d * 2 + i - 10);
    assert (i == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = 5;
    i = i % (1 + 1);
    assert (i == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: sc_compound_assign (test_binary.cpp:224:5) 

// Process-local variables
logic signed [31:0] k;

always_comb 
begin : sc_compound_assign     // test_binary.cpp:224:5
    logic [2:0] u;
    logic signed [3:0] i;
    logic signed [3:0] m2;
    u = 3;
    i = -3'sd2;
    m2 = 1;
    i = i + 1;
    assert (i == -2'sd1) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = i - m2;
    assert (i == -3'sd2) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = i * 1;
    assert (i == -3'sd2) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = i / signed'({1'b0, u});
    assert (i == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    u = u % k;
    u = u | 2;
    u = u & 3;
    u = u ^ 5'd4;
    u = u <<< k;
    u = u >>> (4'(2 + i));
end

//------------------------------------------------------------------------------
// Method process: sc_type_main (test_binary.cpp:275:5) 

always_comb 
begin : sc_type_main     // test_binary.cpp:275:5
    logic [2:0] x;
    logic signed [3:0] y;
    logic signed [32:0] bx;
    logic [32:0] bux;
    logic signed [41:0] z;
    logic signed [41:0] bz;
    x = 1;
    y = 5;
    bx = 4;
    bux = 7;
    z = 0;
    bz = 0;
    z = signed'({1'b0, x}) + y;
    assert (z == 6) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, 3 * x}) + y * 2 + 2 * 3;
    assert (z == 19) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, x + 3}) + y + 0;
    assert (z == 9) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = 5'(signed'({1'b0, x - 1}) + y) / bx;
    assert (bz == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = 34'(signed'({1'b0, x}) / y + bx) / signed'({1'b0, bux});
    assert (bz == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = signed'({1'b0, x}) * (signed'({1'b0, bux}) + 1) + y / bx;
    assert (bz == 9) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = (y >>> 1) + (bx >>> x);
    assert (z == 4) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = (y <<< (4'(x + 1) >>> 1)) * signed'({1'b0, bux});
    assert (z == 70) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = (signed'({1'b0, x}) * y) <<< (32'(bux) >>> 1);
    assert (z == 40) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = (signed'({1'b0, x}) + y) - signed'({1'b0, (++bux)});
    assert (bz == -3'sd2) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = (y % 2) * (14 % bx + 1);
    assert (bz == 3) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = 9'((y % bx) * signed'({1'b0, (x + 10)})) / signed'({1'b0, bux});
    assert (bz == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: sc_type_main_neg (test_binary.cpp:245:5) 

always_comb 
begin : sc_type_main_neg     // test_binary.cpp:245:5
    logic [4:0] x;
    logic signed [4:0] y;
    logic signed [32:0] bx;
    logic signed [41:0] bz;
    logic [32:0] bux;
    logic signed [41:0] z;
    x = 1;
    y = -4'sd5;
    bx = 4;
    bz = 0;
    bux = 7;
    z = 0;
    z = signed'({1'b0, (-3'sd3) - x}) + y;
    z = signed'({1'b0, x}) * y;
    assert (z == -4'sd5) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = y / signed'({1'b0, (x + 1)});
    bz = 7'(signed'({1'b0, x}) + y - 1) / bx;
    bz = 7'(signed'({1'b0, x - 1}) + y) / bx;
end

//------------------------------------------------------------------------------
// Method process: sc_type_main_signed (test_binary.cpp:322:5) 

always_comb 
begin : sc_type_main_signed     // test_binary.cpp:322:5
    logic signed [2:0] x;
    logic signed [3:0] y;
    logic signed [32:0] bx;
    logic signed [32:0] by;
    logic signed [41:0] z;
    logic signed [41:0] bz;
    x = 1;
    y = 5;
    bx = 4;
    by = 7;
    z = 0;
    bz = 0;
    z = x + y;
    assert (z == 6) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = 3 * x + y * 2 + 2 * 3;
    assert (z == 19) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = x + 3 + y + 0;
    assert (z == 9) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = 5'(x - 1 + y) / bx;
    assert (bz == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = 34'(x / y + bx) / by;
    assert (bz == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = x * (by + 1) + y / bx;
    assert (bz == 9) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = (x * y) <<< (32'(by) >>> 1);
    assert (bz == 40) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = (x + y) - (++by);
    assert (bz == -3'sd2) else $error("Assertion failed at test_binary.cpp:59:24>");
    bz = 9'((y % bx) * (x + 10)) / by;
    assert (bz == 1) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: sc_type_logic_bitwise (test_binary.cpp:359:5) 

always_comb 
begin : sc_type_logic_bitwise     // test_binary.cpp:359:5
    integer i;
    integer unsigned uu;
    logic [4:0] x;
    logic signed [3:0] y;
    logic [9:0] bx;
    logic signed [9:0] by;
    logic [17:0] z;
    logic b_1;
    i = 10;
    uu = 3;
    x = 2;
    y = 3;
    bx = 7;
    by = 5;
    z = 0;
    z = i | signed'({1'b0, uu});
    assert (z == 11) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = i & signed'({1'b0, uu});
    assert (z == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = i ^ signed'({1'b0, uu});
    assert (z == 9) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, x}) | signed'({1'b0, uu + bx}) & by;
    assert (z == 2) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, (x ^ (uu + 1))}) + (y | signed'({1'b0, bx}) | by);
    assert (z == 13) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = signed'({1'b0, (x & 11)}) * (10 | (2 * i));
    assert (z == 60) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = |x && |y;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = |x && !(|y);
    assert (!b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = 1;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = 1;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = 0 || |(x - 1);
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = !(|i) || |(y + signed'({1'b0, 32'(bx)})) && 1;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: sc_type_comp (test_binary.cpp:402:5) 

always_comb 
begin : sc_type_comp     // test_binary.cpp:402:5
    integer i;
    integer unsigned uu;
    logic [4:0] x;
    logic signed [3:0] y;
    logic [9:0] bx;
    logic signed [9:0] by;
    logic b_1;
    i = 10;
    uu = 3;
    x = 2;
    y = 3;
    bx = 7;
    by = 5;
    b_1 = x > y;
    assert (!b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x != y;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x != 1 && bx != i;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x == y - 1;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = 0 == y - signed'({1'b0, uu});
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x == 2 && bx == uu + 4;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x <= y;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x <= y && bx > by && 1;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x < y;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
    b_1 = x < (y + 1) && 1;
    assert (b_1) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: large_types (test_binary.cpp:437:5) 

always_comb 
begin : large_types     // test_binary.cpp:437:5
    logic signed [127:0] i;
    logic [127:0] j;
    logic signed [99:0] x;
    logic [99:0] y;
    logic signed [99:0] z;
    i = -5'sd10;
    j = 10;
    i = 140 / j;
    assert (i == 14) else $error("Assertion failed at test_binary.cpp:59:24>");
    i = j <<< 2;
    assert (i == 40) else $error("Assertion failed at test_binary.cpp:59:24>");
    x = -5'sd11;
    y = 11;
    z = 0;
    z = x + signed'({1'b0, y});
    assert (z == 0) else $error("Assertion failed at test_binary.cpp:59:24>");
    z = x * signed'({1'b0, y});
    assert (z == -8'sd121) else $error("Assertion failed at test_binary.cpp:59:24>");
    x = signed'({1'b0, y}) * 2;
    assert (x == 22) else $error("Assertion failed at test_binary.cpp:59:24>");
    y = x <<< 50;
    assert (y == 'h58000000000000) else $error("Assertion failed at test_binary.cpp:59:24>");
end

//------------------------------------------------------------------------------
// Method process: sc_relational_ops (test_binary.cpp:465:5) 

always_comb 
begin : sc_relational_ops     // test_binary.cpp:465:5
    integer unsigned rel_a;
    integer unsigned rel_b;
    logic [31:0] rel_c;
    logic [31:0] rel_d;
    integer rel_e;
    integer rel_f;
    logic rel_less_than;
    logic rel_greater_than;
    logic rel_not_eq;
    logic rel_less_than_eq;
    logic rel_greater_than_eq;
    rel_a = 0;
    rel_b = rel_a - 1;
    rel_c = 0;
    rel_d = rel_c - 1;
    rel_e = rel_d;
    rel_f = rel_a;
    rel_less_than = rel_a < rel_b;
    rel_greater_than = rel_d > rel_c;
    rel_not_eq = rel_d != rel_c;
    rel_b = rel_a;
    rel_c = rel_d;
    rel_less_than_eq = rel_a <= rel_b;
    rel_greater_than_eq = rel_d >= rel_c;
end

//------------------------------------------------------------------------------
// Method process: sc_fp_bitwise_fns (test_binary.cpp:540:5) 

// Process-local variables
logic signed [31:0] iter;

always_comb 
begin : sc_fp_bitwise_fns     // test_binary.cpp:540:5
    logic [9:0] par1;
    logic [11:0] par2;
    logic [21:0] par3;
    logic [29:0] par4;
    logic [15:0] par5;
    logic [13:0] par6;
    logic [21:0] par7;
    logic [9:0] B;
    logic [11:0] C;
    logic [21:0] i;
    logic [29:0] s2;
    logic [15:0] s3;
    logic [13:0] u2;
    logic [21:0] u3;
    logic [21:0] A0;
    logic [21:0] A1;
    logic [21:0] A2;
    logic [21:0] A3;
    logic [21:0] A4;
    logic [21:0] A5;
    logic [21:0] s10;
    logic [21:0] s11;
    logic [21:0] s12;
    logic [21:0] u10;
    logic [21:0] u11;
    logic [21:0] u12;
    logic signed [12:0] par1_1;
    logic signed [11:0] par2_1;
    logic signed [11:0] par3_1;
    logic signed [11:0] par4_1;
    logic signed [9:0] par5_1;
    logic signed [11:0] par6_1;
    logic signed [31:0] par7_1;
    logic signed [12:0] B_1;
    logic signed [11:0] C_1;
    logic signed [11:0] i_1;
    logic signed [11:0] s2_1;
    logic signed [9:0] s3_1;
    logic signed [11:0] u2_1;
    logic signed [31:0] u3_1;
    logic signed [31:0] A0_1;
    logic signed [31:0] A1_1;
    logic signed [31:0] A2_1;
    logic signed [31:0] A3_1;
    logic signed [31:0] A4_1;
    logic signed [31:0] A5_1;
    logic signed [31:0] s10_1;
    logic signed [31:0] s11_1;
    logic signed [31:0] s12_1;
    logic signed [31:0] u10_1;
    logic signed [31:0] u11_1;
    logic signed [31:0] u12_1;
    logic signed [11:0] par1_2;
    logic signed [11:0] par2_2;
    logic signed [11:0] par3_2;
    logic signed [11:0] par4_2;
    logic signed [9:0] par5_2;
    logic signed [11:0] par6_2;
    logic signed [31:0] par7_2;
    logic signed [11:0] B_2;
    logic signed [11:0] C_2;
    logic signed [11:0] i_2;
    logic signed [11:0] s2_2;
    logic signed [9:0] s3_2;
    logic signed [11:0] u2_2;
    logic signed [31:0] u3_2;
    logic signed [31:0] A0_2;
    logic signed [31:0] A1_2;
    logic signed [31:0] A2_2;
    logic signed [31:0] A3_2;
    logic signed [31:0] A4_2;
    logic signed [31:0] A5_2;
    logic signed [31:0] s10_2;
    logic signed [31:0] s11_2;
    logic signed [31:0] s12_2;
    logic signed [31:0] u10_2;
    logic signed [31:0] u11_2;
    logic signed [31:0] u12_2;
    logic [9:0] par1_3;
    logic [11:0] par2_3;
    logic [11:0] par3_3;
    logic [11:0] par4_3;
    logic [9:0] par5_3;
    logic [11:0] par6_3;
    logic [31:0] par7_3;
    logic [9:0] B_3;
    logic [11:0] C_3;
    logic [11:0] i_3;
    logic [11:0] s2_3;
    logic [9:0] s3_3;
    logic [11:0] u2_3;
    logic [31:0] u3_3;
    logic [31:0] A0_3;
    logic [31:0] A1_3;
    logic [31:0] A2_3;
    logic [31:0] A3_3;
    logic [31:0] A4_3;
    logic [31:0] A5_3;
    logic [31:0] s10_3;
    logic [31:0] s11_3;
    logic [31:0] s12_3;
    logic [31:0] u10_3;
    logic [31:0] u11_3;
    logic [31:0] u12_3;
    integer x0;
    integer x1;
    integer x2;
    integer x3;
    integer x4;
    integer x5;
    integer x6;
    integer x7;
    logic [19:0] par1_4;
    logic [31:0] par2_4;
    logic [51:0] par3_4;
    logic [71:0] par4_4;
    logic [19:0] par5_4;
    logic [31:0] par6_4;
    logic [51:0] par7_4;
    logic [19:0] B_4;
    logic [31:0] C_4;
    logic [51:0] i_4;
    logic [71:0] s2_4;
    logic [19:0] s3_4;
    logic [31:0] u2_4;
    logic [51:0] u3_4;
    logic [51:0] A0_4;
    logic [51:0] A1_4;
    logic [51:0] A2_4;
    logic [51:0] A3_4;
    logic [51:0] A4_4;
    logic [51:0] A5_4;
    logic [51:0] s10_4;
    logic [51:0] s11_4;
    logic [51:0] s12_4;
    logic [51:0] u10_4;
    logic [51:0] u11_4;
    logic [51:0] u12_4;
    par1 = 10'd5; par2 = 12'd1; par3 = 22'd3; par4 = 30'd12; par5 = 16'd90; par6 = 14'd64; par7 = 22'd14;
    // Call sc_fp_bitwise_fns_types() begin
    B = par1;
    C = par2;
    i = par3;
    s2 = par4;
    s3 = par5;
    u2 = par6;
    u3 = par7;
    iter++;
    A0 = B + C;
    A1 = B - C;
    A2 = B * C;
    A3 = B / C;
    A4 = B <<< i;
    A5 = B >>> i;
    s10 = s2 & s3;
    s11 = s2 | s3;
    s12 = s2 ^ s3;
    u10 = u2 & u3;
    u11 = u2 | u3;
    u12 = u2 ^ u3;
    // Call sc_fp_bitwise_fns_types() end
    par1_1 = 13'd15; par2_1 = 12'd11; par3_1 = 12'd2; par4_1 = 12'd22; par5_1 = 10'd40; par6_1 = 12'd44; par7_1 = 32'd24;
    // Call sc_fp_bitwise_fns_types() begin
    B_1 = par1_1;
    C_1 = par2_1;
    i_1 = par3_1;
    s2_1 = par4_1;
    s3_1 = par5_1;
    u2_1 = par6_1;
    u3_1 = par7_1;
    iter++;
    A0_1 = B_1 + C_1;
    A1_1 = B_1 - C_1;
    A2_1 = B_1 * C_1;
    A3_1 = B_1 / C_1;
    A4_1 = B_1 <<< i_1;
    A5_1 = B_1 >>> i_1;
    s10_1 = s2_1 & s3_1;
    s11_1 = s2_1 | s3_1;
    s12_1 = s2_1 ^ s3_1;
    u10_1 = u2_1 & u3_1;
    u11_1 = u2_1 | u3_1;
    u12_1 = u2_1 ^ u3_1;
    // Call sc_fp_bitwise_fns_types() end
    par1_2 = 12'd5; par2_2 = 12'd1; par3_2 = 12'd3; par4_2 = 12'd12; par5_2 = 10'd90; par6_2 = 12'd64; par7_2 = 32'd14;
    // Call sc_fp_bitwise_fns_types() begin
    B_2 = par1_2;
    C_2 = par2_2;
    i_2 = par3_2;
    s2_2 = par4_2;
    s3_2 = par5_2;
    u2_2 = par6_2;
    u3_2 = par7_2;
    iter++;
    A0_2 = B_2 + C_2;
    A1_2 = B_2 - C_2;
    A2_2 = B_2 * C_2;
    A3_2 = B_2 / C_2;
    A4_2 = B_2 <<< i_2;
    A5_2 = B_2 >>> i_2;
    s10_2 = s2_2 & s3_2;
    s11_2 = s2_2 | s3_2;
    s12_2 = s2_2 ^ s3_2;
    u10_2 = u2_2 & u3_2;
    u11_2 = u2_2 | u3_2;
    u12_2 = u2_2 ^ u3_2;
    // Call sc_fp_bitwise_fns_types() end
    par1_3 = 10'd5; par2_3 = 12'd1; par3_3 = 12'd3; par4_3 = 12'd12; par5_3 = 10'd90; par6_3 = 12'd64; par7_3 = 32'd14;
    // Call sc_fp_bitwise_fns_types() begin
    B_3 = par1_3;
    C_3 = par2_3;
    i_3 = par3_3;
    s2_3 = par4_3;
    s3_3 = par5_3;
    u2_3 = par6_3;
    u3_3 = par7_3;
    iter++;
    A0_3 = B_3 + C_3;
    A1_3 = B_3 - C_3;
    A2_3 = B_3 * C_3;
    A3_3 = B_3 / C_3;
    A4_3 = B_3 <<< i_3;
    A5_3 = B_3 >>> i_3;
    s10_3 = s2_3 & s3_3;
    s11_3 = s2_3 | s3_3;
    s12_3 = s2_3 ^ s3_3;
    u10_3 = u2_3 & u3_3;
    u11_3 = u2_3 | u3_3;
    u12_3 = u2_3 ^ u3_3;
    // Call sc_fp_bitwise_fns_types() end
    x0 = 5;
    x1 = 1;
    x2 = 1;
    x3 = 12;
    x4 = 90;
    x5 = 64;
    x6 = 14;
    for (integer loopcount = 0; loopcount < 10; loopcount++)
    begin
        x0 = x0 + 5;
        x1 = x1 + 1;
        x2 = x2 + 1;
        x3 = x3 + 12;
        x4 = x4 + 90;
        x5 = x5 + 64;
        x6 = x6 + 14;
        par1_4 = 20'(x0); par2_4 = 32'(x1); par3_4 = 52'(x2); par4_4 = 72'(x3); par5_4 = 20'(x4); par6_4 = 32'(x5); par7_4 = 52'(x6);
        // Call sc_fp_bitwise_fns_types() begin
        B_4 = par1_4;
        C_4 = par2_4;
        i_4 = par3_4;
        s2_4 = par4_4;
        s3_4 = par5_4;
        u2_4 = par6_4;
        u3_4 = par7_4;
        iter++;
        A0_4 = B_4 + C_4;
        A1_4 = B_4 - C_4;
        A2_4 = B_4 * C_4;
        A3_4 = B_4 / C_4;
        A4_4 = B_4 <<< i_4;
        A5_4 = B_4 >>> i_4;
        s10_4 = s2_4 & s3_4;
        s11_4 = s2_4 | s3_4;
        s12_4 = s2_4 ^ s3_4;
        u10_4 = u2_4 & u3_4;
        u11_4 = u2_4 | u3_4;
        u12_4 = u2_4 ^ u3_4;
        // Call sc_fp_bitwise_fns_types() end
    end
end

endmodule



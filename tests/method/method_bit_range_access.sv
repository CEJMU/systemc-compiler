//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
);

// SystemC signals
logic [31:0] sig_inp;
logic [31:0] sig_outp;


//------------------------------------------------------------------------------

A a_mod
(
  .inp(sig_inp),
  .outp(sig_outp)
);

endmodule



//==============================================================================
//
// Module: A (test_bit_range_access.cpp:218:5)
//
module A // "b_mod.a_mod"
(
    input logic [31:0] inp,
    output logic [31:0] outp
);

// SystemC signals
logic [7:0] ssig[2];
logic sig;
logic bsig;
logic signed [31:0] isig;
logic as;
logic signed bs;
logic cs;
logic signed ds;

//------------------------------------------------------------------------------
// Method process: sc_uint_wide (test_bit_range_access.cpp:55:5) 

always_comb 
begin : sc_uint_wide     // test_bit_range_access.cpp:55:5
    logic b;
    logic k;
    logic [1:0] x_1;
    k = 0;
    b = k;
    x_1 = k;
end

//------------------------------------------------------------------------------
// Method process: sc_uint_ctor (test_bit_range_access.cpp:64:5) 

always_comb 
begin : sc_uint_ctor     // test_bit_range_access.cpp:64:5
    logic [2:0] i;
    logic [1:0] j;
    logic k;
    logic b;
    i = 1;
    j = i;
    k = i;
    b = |i;
    b = i;
    b = i[0];
    b = k;
    b = k;
    b = inp;
    b = 1'(inp[1]);
end

//------------------------------------------------------------------------------
// Method process: signal_array_part_sel (test_bit_range_access.cpp:82:5) 

always_comb 
begin : signal_array_part_sel     // test_bit_range_access.cpp:82:5
    logic b;
    logic [4:0] x_1;
    b = ssig[1][2];
    x_1 = ssig[1][4 : 3];
end

//------------------------------------------------------------------------------
// Method process: sc_uint_to_bool (test_bit_range_access.cpp:89:5) 

always_comb 
begin : sc_uint_to_bool     // test_bit_range_access.cpp:89:5
    logic [1:0] i;
    logic b;
    i = 1;
    b = as;
    sig = |i;
    sig = as;
    sig = as;
end

//------------------------------------------------------------------------------
// Method process: int_to_bool (test_bit_range_access.cpp:100:5) 

always_comb 
begin : int_to_bool     // test_bit_range_access.cpp:100:5
    integer i;
    logic b;
    logic [1:0] x_1;
    i = 1;
    b = |i;
    b = 1;
    b = |(2 - 1);
    b = |isig;
    b = 1'(i);
    x_1 = 1;
    b = |x_1;
    b = 1'(x_1);
    b = |x_1;
    bsig = |i;
    bsig = |isig;
    bsig = |isig;
end

//------------------------------------------------------------------------------
// Method process: zero_zero_range (test_bit_range_access.cpp:132:5) 

always_comb 
begin : zero_zero_range     // test_bit_range_access.cpp:132:5
    logic a;
    logic aa;
    logic ab;
    logic [4:0] j;
    logic [4:0] jj;
    logic signed b;
    logic signed bb;
    integer i;
    a = 0;
    aa = a;
    a = 1;
    ab = as;
    j = as;
    jj = 5'(as);
    b = 0;
    bb = b;
    b = 1;
    i = bs;
    i = bs + 1;
end

//------------------------------------------------------------------------------
// Method process: zero_zero_range_big (test_bit_range_access.cpp:148:5) 

always_comb 
begin : zero_zero_range_big     // test_bit_range_access.cpp:148:5
    logic c;
    logic cc;
    logic ab;
    logic [4:0] j;
    logic [4:0] jj;
    logic signed d;
    logic signed dd;
    integer i;
    c = 0;
    cc = c;
    c = 1;
    ab = cs != 0;
    j = 5'(cs);
    jj = cs + j;
    d = 0;
    dd = d;
    d = 1;
    i = ds;
    i = ds + 1;
end

//------------------------------------------------------------------------------
// Method process: zero_zero_bit (test_bit_range_access.cpp:164:5) 

always_comb 
begin : zero_zero_bit     // test_bit_range_access.cpp:164:5
    logic a;
    logic aa;
    logic ab;
    integer j;
    logic signed [63:0] jj;
    a = 0;
    aa = a;
    a = 1;
    ab = as;
    j = as;
    jj = as;
end

//------------------------------------------------------------------------------
// Method process: zero_zero_bit_big (test_bit_range_access.cpp:174:5) 

always_comb 
begin : zero_zero_bit_big     // test_bit_range_access.cpp:174:5
    logic c;
    logic cc;
    logic ab;
    logic [4:0] j;
    logic [4:0] jj;
    c = 0;
    cc = c;
    c = 1;
    ab = cs != 0;
    j = 5'(cs);
    jj = cs + j;
end

//------------------------------------------------------------------------------
// Method process: bit_range_sel (test_bit_range_access.cpp:184:5) 

// Process-local variables
logic signed [7:0] x;
logic signed [7:0] y;
logic [7:0] ux;
logic [7:0] uy;

always_comb 
begin : bit_range_sel     // test_bit_range_access.cpp:184:5
    x[1] = y[0];
    ux[1] = uy[0];
    x[3 : 2] = y[2 : 1];
    x[5 : 3] = y[4 : 2];
    ux[3 : 2] = uy[2 : 1];
    ux[5 : 3] = uy[4 : 2];
end

//------------------------------------------------------------------------------
// Method process: bit_range_array (test_bit_range_access.cpp:198:5) 

always_comb 
begin : bit_range_array     // test_bit_range_access.cpp:198:5
    logic [3:0] uarr[3];
    logic [64:0] barr[3];
    logic b;
    uarr[0] = 0; uarr[1] = 0; uarr[2] = 0;
    barr[0] = 0; barr[1] = 0; barr[2] = 0;
    uarr[0][2 : 1] = 1;
    b = uarr[2][0] || uarr[3 - 1][3];
    b = |uarr[4 - 3][1 : 0];
    barr[2 - 1][64 : 63] = uarr[2 - 2][1 : 0];
end

endmodule



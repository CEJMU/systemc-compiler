//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "top_inst"
(
    input logic clk
);

// SystemC signals
logic nrst;

// C++ data variables
localparam logic mrec1_a = 0;
localparam logic [3:0] mrec1_b = 'd4;
localparam logic mrec2_a = 0;
localparam logic [3:0] mrec2_b = 'd5;
localparam logic [15:0] B = 'd42;
localparam logic signed [64:0] BB = 'd18446744073709551573;
localparam logic [15:0] BBB = 'd43;
localparam logic [31:0] C = 'd1;
localparam logic signed [31:0] ARR[3] = '{ 'd1, 'd2, 'd3 };
localparam logic signed [7:0] ARRI[3] = '{ 'd4, -'d5, 'd6 };

//------------------------------------------------------------------------------
// Method process: const_cond_stmt (test_const_static_mem.cpp:59:5) 

always_comb 
begin : const_cond_stmt     // test_const_static_mem.cpp:59:5
    integer j;
    j = 4'd1;
    assert (j == 1) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    j = 4'd2;
    assert (j == 2) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
end

//------------------------------------------------------------------------------
// Method process: const_method (test_const_static_mem.cpp:76:5) 

always_comb 
begin : const_method     // test_const_static_mem.cpp:76:5
    integer a;
    integer unsigned TMP_0;
    integer unsigned b;
    a = B;
    a = 32'(BB);
    assert (a == -7'sd43) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    a = BBB;
    assert (a == 43) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    a = ARR[1];
    assert (a == 2) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    a = ARRI[1];
    assert (a == -4'sd5) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    // Call getvar() begin
    TMP_0 = C;
    // Call getvar() end
    a = TMP_0;
    b = a + signed'({1'b0, C});
    assert (b == 2) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
end

//------------------------------------------------------------------------------
// Method process: const_record_method (test_const_static_mem.cpp:97:5) 

always_comb 
begin : const_record_method     // test_const_static_mem.cpp:97:5
    logic a;
    logic [3:0] b;
    logic rec_a;
    logic [3:0] rec_b;
    integer j;
    a = 1; b = 1;
    rec_a = a;
    rec_b = b;
    j = rec_b + mrec1_b;
    assert (j == 5) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    j = rec_b;
    assert (j == 1) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
    j = mrec1_b;
    assert (j == 4) else $error("Assertion failed at test_const_static_mem.cpp:56:24>");
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread (test_const_static_mem.cpp:112:5) 

// Thread-local constants
logic rec_a;
logic [3:0] rec_b;

// Next-state combinational logic
always_comb begin : const_record_thread_comb     // test_const_static_mem.cpp:112:5
    const_record_thread_func;
end
function void const_record_thread_func;
    integer j;
    j = rec_b + mrec2_b;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread_ff
    if ( ~nrst ) begin
        logic a;
        logic [3:0] b;
        a = 0; b = 1;
        rec_a = a;
        rec_b = b;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread2 (test_const_static_mem.cpp:124:5) 

// Thread-local constants
logic rec_a0;
logic [3:0] rec_b0;

// Next-state combinational logic
always_comb begin : const_record_thread2_comb     // test_const_static_mem.cpp:124:5
    const_record_thread2_func;
end
function void const_record_thread2_func;
    integer j;
    j = rec_b0 + B;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread2_ff
    if ( ~nrst ) begin
        logic a;
        logic [3:0] b;
        a = 1; b = 2;
        rec_a0 = a;
        rec_b0 = b;
    end
    else begin
    end
end

endmodule



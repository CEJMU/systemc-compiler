//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "top_inst"
(
    input logic clk
);

// SystemC signals
logic nrst;

// C++ data variables
localparam logic mrec1_a = 0;
localparam logic [3:0] mrec1_b = 'd4;
localparam logic mrec2_a = 0;
localparam logic [3:0] mrec2_b = 'd5;
localparam logic signed [31:0] ARR[3] = '{ 'd1, 'd2, 'd3 };
localparam logic signed [7:0] ARRI[3] = '{ 'd4, -'d5, 'd6 };

//------------------------------------------------------------------------------
// Method process: const_method (test_const_static_mem.cpp:51:5) 

always_comb 
begin : const_method     // test_const_static_mem.cpp:51:5
    integer a;
    integer unsigned TMP_0;
    integer unsigned b;
    a = 42;
    a = -7'sd43;
    a = 43;
    a = 2;
    a = -4'sd5;
    // Call getvar() begin
    TMP_0 = 1;
    // Call getvar() end
    a = TMP_0;
    b = a + 1;
end

//------------------------------------------------------------------------------
// Method process: const_record_method (test_const_static_mem.cpp:67:5) 

always_comb 
begin : const_record_method     // test_const_static_mem.cpp:67:5
    logic a;
    logic [3:0] b;
    logic rec_a;
    logic [3:0] rec_b;
    integer j;
    a = 0; b = 1;
    rec_a = a;
    rec_b = b;
    j = rec_b + mrec1_b;
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread (test_const_static_mem.cpp:73:5) 

// Thread-local constants
logic rec_a;
logic [3:0] rec_b;

// Next-state combinational logic
always_comb begin : const_record_thread_comb     // test_const_static_mem.cpp:73:5
    const_record_thread_func;
end
function void const_record_thread_func;
    integer j;
    j = rec_b + mrec2_b;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread_ff
    if ( ~nrst ) begin
        logic a;
        logic [3:0] b;
        a = 0; b = 1;
        rec_a = a;
        rec_b = b;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: const_record_thread2 (test_const_static_mem.cpp:85:5) 

// Thread-local constants
logic rec_a0;
logic [3:0] rec_b0;

// Next-state combinational logic
always_comb begin : const_record_thread2_comb     // test_const_static_mem.cpp:85:5
    const_record_thread2_func;
end
function void const_record_thread2_func;
    integer j;
    j = rec_b0;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : const_record_thread2_ff
    if ( ~nrst ) begin
        logic a;
        logic [3:0] b;
        a = 1; b = 2;
        rec_a0 = a;
        rec_b0 = b;
    end
    else begin
    end
end

endmodule



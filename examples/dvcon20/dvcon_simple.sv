//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.3.7
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Tb ()
//
module Tb // "top"
(
    input logic clk
);

// SystemC signals
logic nrst;
logic [31:0] a;
logic [31:0] b;
logic [31:0] sum;
logic crr;

//------------------------------------------------------------------------------
// Clocked THREAD: tests (test_simple.cpp:107:5) 

// Thread-local variables
logic [3:0] tests_WAIT_N_COUNTER;
logic [3:0] tests_WAIT_N_COUNTER_next;
logic nrst_next;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [31:0] a_next;
logic [31:0] b_next;
logic tests_PROC_STATE;
logic tests_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : tests_comb     // test_simple.cpp:107:5
    tests_func;
end
function void tests_func;
    a_next = a;
    b_next = b;
    i_next = i;
    nrst_next = nrst;
    tests_WAIT_N_COUNTER_next = tests_WAIT_N_COUNTER;
    tests_PROC_STATE_next = tests_PROC_STATE;
    
    case (tests_PROC_STATE)
        default : begin
            nrst_next = 0;
            tests_WAIT_N_COUNTER_next = 10;
            tests_PROC_STATE_next = 0; return;    // test_simple.cpp:109:9;
        end
        0: begin
            if (tests_WAIT_N_COUNTER != 1) begin
                tests_WAIT_N_COUNTER_next = tests_WAIT_N_COUNTER - 1;
                tests_PROC_STATE_next = 0; return;    // test_simple.cpp:109:9;
            end;
            nrst_next = 1;
            i_next = 0;
            a_next = i_next;
            b_next = i_next + 1;
            tests_PROC_STATE_next = 1; return;    // test_simple.cpp:115:13;
        end
        1: begin
            i_next++;
            if (i_next < 4000000)
            begin
                a_next = i_next;
                b_next = i_next + 1;
                tests_PROC_STATE_next = 1; return;    // test_simple.cpp:115:13;
            end
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk) 
begin : tests_ff
    begin
        tests_WAIT_N_COUNTER <= tests_WAIT_N_COUNTER_next;
        nrst <= nrst_next;
        i <= i_next;
        a <= a_next;
        b <= b_next;
        tests_PROC_STATE <= tests_PROC_STATE_next;
    end
end


//------------------------------------------------------------------------------

Dut dut
(
  .clk(clk),
  .nrst(nrst),
  .a(a),
  .b(b),
  .sum(sum),
  .crr(crr)
);

endmodule



//==============================================================================
//
// Module: Dut (test_simple.cpp:92:5)
//
module Dut // "top.dut"
(
    input logic clk,
    input logic nrst,
    input logic [31:0] a,
    input logic [31:0] b,
    output logic [31:0] sum,
    output logic crr
);

// SystemC signals
logic enbl[4];
logic actv[4][32];

//------------------------------------------------------------------------------
// Clocked THREAD: proc (test_simple.cpp:34:5) 

// Thread-local variables
logic [31:0] sum_next;
logic [4:0] res;
logic [4:0] res_next;
logic crr_next;
logic proc_PROC_STATE;
logic proc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : proc_comb     // test_simple.cpp:34:5
    proc_func;
end
function void proc_func;
    crr_next = crr;
    res_next = res;
    sum_next = sum;
    proc_PROC_STATE_next = proc_PROC_STATE;
    
    case (proc_PROC_STATE)
        0: begin
            res_next = a + b;
            proc_PROC_STATE_next = 1; return;    // test_simple.cpp:40:13;
        end
        1: begin
            sum_next = res_next;
            crr_next = res_next[4];
            res_next = a + b;
            proc_PROC_STATE_next = 1; return;    // test_simple.cpp:40:13;
        end
    endcase
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : proc_ff
    if ( ~nrst ) begin
        sum <= 0;
        proc_PROC_STATE <= 0;    // test_simple.cpp:36:9;
    end
    else begin
        sum <= sum_next;
        res <= res_next;
        crr <= crr_next;
        proc_PROC_STATE <= proc_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_proc (test_simple.cpp:67:1) 

// Next-state combinational logic
always_comb begin : thread_proc_comb     // test_simple.cpp:67:1
    thread_proc_func;
end
function void thread_proc_func;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : thread_proc_ff
    if ( ~nrst ) begin
    end
    else begin
    end

`ifndef INTEL_SVA_OFF
    for (integer i = 0; i < 4; ++i) begin
        sctAssertLine70 : assert property ( enbl[i] |=> !enbl[i] );
    end
    for (integer i = 0; i < 4; ++i) begin
        for (integer j = 0; j < 32; ++j) begin
            sctAssertLine72 : assert property ( actv[i][j] |-> ##2 actv[i][32 - j - 1] );
        end
    end
`endif // INTEL_SVA_OFF
end

`ifndef INTEL_SVA_OFF
sctAssertLine32 : assert property (
    @(posedge clk) |a |-> ##[10:30] |b );
`endif // INTEL_SVA_OFF

endmodule


